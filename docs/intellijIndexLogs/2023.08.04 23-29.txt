entDescriptorImpl);
      try {
        return getChildValueExpression("this.get(" + ((ArrayElementDescriptorImpl)node.getDescriptor()).getIndex() + ")", node, context);
      }
      catch (IncorrectOperationException e) {
        // fallback to original
        return super.getChildValueExpression(node, context);
      }
    }
  }

  static void visitAnnotatedElements(String annotationFqn,
                                     Project project,
                                     BiConsumer<? super PsiModifierListOwner, ? super PsiAnnotation> consumer) {
    Collection<PsiAnnotation> annotations =
      ReadAction.compute(
        () -> JavaAnnotationIndex.getInstance().get(StringUtil.getShortName(annotationFqn), project, GlobalSearchScope.allScope(project)));
    annotations.forEach(annotation -> ReadAction.run(() -> {
      if (!annotation.isValid()) return;
      PsiElement parent = annotation.getContext();
      if (parent instanceof PsiModifierList) {
        PsiElement owner = parent.getParent();
        if (owner instanceof PsiModifierListOwner && annotationFqn.equals(annotation.getQualifiedName())) {
          consumer.accept((PsiModifierListOwner)owner, annotation);
        }
      }
    }));
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.settings;

import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.ui.tree.render.NodeRenderer;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.util.JDOMExternalizable;
import com.intellij.openapi.util.WriteExternalException;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.util.containers.InternalIterator;
import org.jdom.Element;
import org.jetbrains.annotations.TestOnly;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class RendererConfiguration implements Cloneable, JDOMExternalizable {
  private static final Logger LOG = Logger.getInstance(NodeRendererSettings.class);

  private static final int VERSION = 8;

  private List<NodeRenderer> myRepresentationNodes = new CopyOnWriteArrayList<>();
  private final NodeRendererSettings myRendererSettings;

  protected RendererConfiguration(NodeRendererSettings rendererSettings) {
    myRendererSettings = rendererSettings;
  }

  @Override
  public RendererConfiguration clone() {
    RendererConfiguration result = null;
    try {
      result = (RendererConfiguration)super.clone();
    }
    catch (CloneNotSupportedException e) {
      LOG.error(e);
    }
    result.myRepresentationNodes = new CopyOnWriteArrayList<>();

    final ArrayList<NodeRenderer> cloned = new ArrayList<>();
    for (NodeRenderer renderer : myRepresentationNodes) {
      cloned.add((NodeRenderer)renderer.clone());
    }
    result.setRenderers(cloned);

    return result;
  }

  public boolean equals(Object o) {
    if (!(o instanceof RendererConfiguration)) return false;

    return DebuggerUtilsEx.externalizableEqual(this, (RendererConfiguration)o);
  }

  @Override
  public void writeExternal(final Element element) throws WriteExternalException {
    for (NodeRenderer renderer : myRepresentationNodes) {
      element.addContent(myRendererSettings.writeRenderer(renderer));
    }
    element.setAttribute("VERSION", String.valueOf(VERSION));
  }

  @Override
  public void readExternal(final Element root) {
    int configurationVersion = StringUtil.parseInt(root.getAttributeValue("VERSION"), -1);
    if (configurationVersion != VERSION) {
      return;
    }

    final List<Element> children = root.getChildren(NodeRendererSettings.RENDERER_TAG);
    final List<NodeRenderer> renderers = new ArrayList<>(children.size());
    for (Element nodeElement : children) {
      try {
        renderers.add((NodeRenderer)myRendererSettings.readRenderer(nodeElement));
      }
      catch (Exception e) {
        LOG.debug(e);
      }
    }
    setRenderers(renderers);
  }

  public void addRenderer(NodeRenderer renderer) {
    myRepresentationNodes.add(0, renderer);
  }

  @TestOnly
  public void removeRenderer(NodeRenderer renderer) {
    myRepresentationNodes.remove(renderer);
  }

  public void setRenderers(Collection<? extends NodeRenderer> renderers) {
    myRepresentationNodes.clear();
    myRepresentationNodes.addAll(renderers);
  }

  public void iterateRenderers(InternalIterator<NodeRenderer> iterator) {
    for (final NodeRenderer renderer : myRepresentationNodes) {
      final boolean shouldContinue = iterator.visit(renderer);
      if (!shouldContinue) {
        break;
      }
    }
  }

  public int getRendererCount() {
    return myRepresentationNodes.size();
  }

  public boolean contains(NodeRenderer renderer) {
    return myRepresentationNodes.contains(renderer);
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.settings;

import org.jetbrains.annotations.NonNls;

import javax.swing.text.JTextComponent;
import java.lang.reflect.Field;

/**
 * @author Eugene Zhuravlev
 */
public class TextComponentBinding extends FieldDataBinding {
  private final JTextComponent myTextComponent;

  public TextComponentBinding(@NonNls String dataFieldName, JTextComponent textComponent) {
    super(dataFieldName);
    myTextComponent = textComponent;
  }

  @Override
  public void doLoadData(Object from, Field field) throws IllegalAccessException {
    final String value = (String)field.get(from);
    myTextComponent.setText(value);
  }

  @Override
  public void doSaveData(Object to, Field field) throws IllegalAccessException {
    field.set(to, myTextComponent.getText().trim());
  }

  @Override
  protected boolean isModified(Object obj, Field field) throws IllegalAccessException {
    final String value = (String)field.get(obj);
    return myTextComponent.getText().trim().equals(value);
  }
}
<?xml version="1.0" encoding="UTF-8"?>
<form xmlns="http://www.intellij.com/uidesigner/form/" version="1" bind-to-class="com.intellij.debugger.settings.ThreadsViewConfigurable">
  <grid id="a2574" binding="myPanel" layout-manager="GridLayoutManager" row-count="2" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
    <margin top="0" left="0" bottom="0" right="0"/>
    <constraints>
      <xy x="126" y="76" width="271" height="217"/>
    </constraints>
    <properties/>
    <border type="none"/>
    <children>
      <grid id="4cb6d" layout-manager="GridLayoutManager" row-count="3" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="0">
        <margin top="0" left="0" bottom="0" right="0"/>
        <constraints>
          <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="1" fill="1" indent="0" use-parent-layout="false"/>
        </constraints>
        <properties/>
        <border type="etched"/>
        <children>
          <component id="b8249" class="javax.swing.JCheckBox" binding="myShowGroupsCheckBox">
            <constraints>
              <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <margin top="5" left="2" bottom="2" right="2"/>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.threads.view.configurable.show.thread.groups"/>
            </properties>
          </component>
          <component id="5bfe" class="javax.swing.JCheckBox" binding="myShowSyntheticsCheckBox">
            <constraints>
              <grid row="1" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.threads.view.configurable.show.stack.frames.for.synthetic.methods"/>
            </properties>
          </component>
          <component id="a7f8b" class="javax.swing.JCheckBox" binding="myShowCurrentThreadChechBox">
            <constraints>
              <grid row="2" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.threads.view.configurable.current.thread.on.top"/>
            </properties>
          </component>
        </children>
      </grid>
      <grid id="f4cba" layout-manager="GridLayoutManager" row-count="5" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="0">
        <margin top="0" left="0" bottom="0" right="0"/>
        <constraints>
          <grid row="1" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="1" fill="1" indent="0" use-parent-layout="false"/>
        </constraints>
        <properties/>
        <border type="etched"/>
        <children>
          <component id="4f5e9" class="javax.swing.JCheckBox" binding="myLineNumberCheckBox">
            <constraints>
              <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <margin top="5" left="2" bottom="2" right="2"/>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.threads.view.configurable.show.line.number"/>
            </properties>
          </component>
          <component id="2fbc6" class="javax.swing.JCheckBox" binding="myClassNameCheckBox">
            <constraints>
              <grid row="1" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.threads.view.configurable.show.class.name"/>
            </properties>
          </component>
          <component id="b56d7" class="javax.swing.JCheckBox" binding="mySourceCheckBox">
            <constraints>
              <grid row="3" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.threads.view.configurable.show.source.file.name"/>
            </properties>
          </component>
          <component id="99bb5" class="javax.swing.JCheckBox" binding="myPackageCheckBox">
            <constraints>
              <grid row="2" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.threads.view.configurable.show.package"/>
            </properties>
          </component>
          <component id="9be9b" class="javax.swing.JCheckBox" binding="myArgsTypesCheckBox">
            <constraints>
              <grid row="4" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.threads.view.configurable.show.prams.types"/>
            </properties>
          </component>
        </children>
      </grid>
    </children>
  </grid>
</form>
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.settings;

import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.impl.DebuggerSession;
import com.intellij.openapi.options.Configurable;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.project.ProjectManager;
import com.intellij.xdebugger.impl.XDebuggerUtilImpl;

import javax.swing.*;

/**
 * @author Eugene Belyaev
 */
public class ThreadsViewConfigurable implements Configurable {
  private final ThreadsViewSettings mySettings;
  private JPanel myPanel;
  private JCheckBox myShowGroupsCheckBox;
  private JCheckBox myLineNumberCheckBox;
  private JCheckBox myClassNameCheckBox;
  private JCheckBox mySourceCheckBox;
  private JCheckBox myShowSyntheticsCheckBox;
  private JCheckBox myShowCurrentThreadChechBox;
  private JCheckBox myPackageCheckBox;
  private JCheckBox myArgsTypesCheckBox;
  private final CompositeDataBinding myDataBinding = new CompositeDataBinding();

  public ThreadsViewConfigurable(ThreadsViewSettings settings) {
    mySettings = settings;

    myDataBinding.addBinding(new ToggleButtonBinding("SHOW_CLASS_NAME", myClassNameCheckBox));
    myDataBinding.addBinding(new ToggleButtonBinding("SHOW_PACKAGE_NAME", myPackageCheckBox));
    myDataBinding.addBinding(new ToggleButtonBinding("SHOW_ARGUMENTS_TYPES", myArgsTypesCheckBox));
    myDataBinding.addBinding(new ToggleButtonBinding("SHOW_LINE_NUMBER", myLineNumberCheckBox));
    myDataBinding.addBinding(new ToggleButtonBinding("SHOW_SOURCE_NAME", mySourceCheckBox));
    myDataBinding.addBinding(new ToggleButtonBinding("SHOW_THREAD_GROUPS", myShowGroupsCheckBox));
    myDataBinding.addBinding(new ToggleButtonBinding("SHOW_SYNTHETIC_FRAMES", myShowSyntheticsCheckBox));
    myDataBinding.addBinding(new ToggleButtonBinding("SHOW_CURRENT_THREAD", myShowCurrentThreadChechBox));
  }

  @Override
  public String getDisplayName() {
    return JavaDebuggerBundle.message("threads.view.configurable.display.name");
  }

  @Override
  public JComponent createComponent() {
    return myPanel;
  }

  @Override
  public void apply() {
    myDataBinding.saveData(mySettings);
    for (Project project : ProjectManager.getInstance().getOpenProjects()) {
      for (DebuggerSession session : (DebuggerManagerEx.getInstanceEx(project)).getSessions()) {
        (session).refresh(false);
      }
      XDebuggerUtilImpl.rebuildAllSessionsViews(project);
    }
  }

  @Override
  public void reset() {
    myDataBinding.loadData(mySettings);
  }

  @Override
  public boolean isModified() {
    return myDataBinding.isModified(mySettings);
  }

  @Override
  public String getHelpTopic() {
    return "reference.dialogs.customizeThreadView";
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.settings;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.PersistentStateComponent;
import com.intellij.openapi.components.SettingsCategory;
import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.util.xmlb.XmlSerializerUtil;
import org.jetbrains.annotations.NotNull;

@State(name = "ThreadsViewSettings", storages = @Storage("debugger.xml"), category = SettingsCategory.TOOLS)
public final class ThreadsViewSettings implements PersistentStateComponent<ThreadsViewSettings> {
  public boolean SHOW_THREAD_GROUPS = false;
  public boolean SHOW_LINE_NUMBER = true;
  public boolean SHOW_CLASS_NAME = true;
  public boolean SHOW_PACKAGE_NAME = true;
  public boolean SHOW_SOURCE_NAME = false;
  public boolean SHOW_SYNTHETIC_FRAMES = true;
  public boolean SHOW_CURRENT_THREAD = true;
  public boolean SHOW_ARGUMENTS_TYPES = false;

  public static ThreadsViewSettings getInstance() {
    return ApplicationManager.getApplication().getService(ThreadsViewSettings.class);
  }

  @Override
  public ThreadsViewSettings getState() {
    return this;
  }

  @Override
  public void loadState(@NotNull final ThreadsViewSettings state) {
    XmlSerializerUtil.copyBean(state, this);
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.settings;

import org.jetbrains.annotations.NonNls;

import javax.swing.*;
import java.lang.reflect.Field;

/**
 * @author Eugene Zhuravlev
 */
public class ToggleButtonBinding extends FieldDataBinding {
  private final JToggleButton myToggleButton;

  public ToggleButtonBinding(@NonNls String dataFieldName, JToggleButton checkBox) {
    super(dataFieldName);
    myToggleButton = checkBox;
  }

  @Override
  public void doLoadData(Object from, Field field) throws IllegalAccessException {
    final Boolean value = (Boolean)field.get(from);
    myToggleButton.setSelected(value.booleanValue());
  }

  @Override
  public void doSaveData(Object to, Field field) throws IllegalAccessException {
    field.set(to, myToggleButton.isSelected());
  }

  @Override
  protected boolean isModified(Object obj, Field field) throws IllegalAccessException {
    final Boolean value = (Boolean)field.get(obj);
    return myToggleButton.isSelected() != value.booleanValue();
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.settings;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.PersistentStateComponent;
import com.intellij.openapi.components.SettingsCategory;
import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.ui.classFilter.ClassFilter;
import com.intellij.util.xmlb.annotations.XCollection;
import org.jetbrains.annotations.NotNull;

import java.util.Arrays;

@State(name = "TraceSettings", storages = @Storage("debugger.xml"), category = SettingsCategory.TOOLS)
public class TraceSettings implements PersistentStateComponent<TraceSettings> {
  private ClassFilter[] myClassFilters;
  private ClassFilter[] myClassExclusionFilters;

  @XCollection(propertyElementName = "class-filters")
  public final ClassFilter[] getClassFilters() {
    return myClassFilters != null ? myClassFilters : ClassFilter.EMPTY_ARRAY;
  }

  public final boolean setClassFilters(ClassFilter[] classFilters) {
    boolean changed = !filtersEqual(myClassFilters, classFilters);
    myClassFilters = classFilters;
    return changed;
  }

  protected static boolean filtersEqual(Object[] a, Object[] b) {
    if ((a == null || a.length == 0) && (b == null || b.length == 0)) {
      return true;
    }
    return Arrays.equals(a, b);
  }

  @XCollection(propertyElementName = "class-exclusion-filters")
  public ClassFilter[] getClassExclusionFilters() {
    return myClassExclusionFilters != null ? myClassExclusionFilters : ClassFilter.EMPTY_ARRAY;
  }

  public boolean setClassExclusionFilters(ClassFilter[] classExclusionFilters) {
    boolean changed = !filtersEqual(myClassExclusionFilters, classExclusionFilters);
    myClassExclusionFilters = classExclusionFilters;
    return changed;
  }

  public static TraceSettings getInstance() {
    return ApplicationManager.getApplication().getService(TraceSettings.class);
  }

  @Override
  public void loadState(@NotNull TraceSettings state) {
    myClassFilters = state.getClassFilters();
    myClassExclusionFilters = state.getClassExclusionFilters();
  }

  @Override
  public TraceSettings getState() {
    return this;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.settings;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.ui.tree.render.CompoundReferenceRenderer;
import com.intellij.debugger.ui.tree.render.NodeRenderer;
import com.intellij.ide.util.ElementsChooser;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.actionSystem.ActionToolbarPosition;
import com.intellij.openapi.actionSystem.ActionUpdateThread;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.options.ConfigurableUi;
import com.intellij.openapi.ui.Splitter;
import com.intellij.ui.AnActionButton;
import com.intellij.ui.AnActionButtonRunnable;
import com.intellij.ui.DocumentAdapter;
import com.intellij.ui.ToolbarDecorator;
import com.intellij.util.PlatformIcons;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public final class UserRenderersConfigurable extends JPanel implements ConfigurableUi<NodeRendererSettings>, Disposable {
  private final JPanel myNameFieldPanel;
  private final JTextField myNameField;
  private final ElementsChooser<NodeRenderer> myRendererChooser;
  private NodeRenderer myCurrentRenderer = null;
  private final CompoundRendererConfigurable myRendererDataConfigurable = new CompoundRendererConfigurable(this);

  public UserRenderersConfigurable() {
    super(new BorderLayout(4, 0));

    myRendererChooser = new ElementsChooser<>(true);
    setupRenderersList();

    ToolbarDecorator decorator = ToolbarDecorator.createDecorator((JTable)myRendererChooser.getComponent());
    decorator.setToolbarPosition(ActionToolbarPosition.TOP);
    decorator.setAddAction(new AddAction());
    decorator.setRemoveAction(new RemoveAction());
    decorator.setMoveUpAction(new MoveAction(true));
    decorator.setMoveDownAction(new MoveAction(false));
    decorator.addExtraAction(new CopyAction());

    myNameField = new JTextField();
    myNameFieldPanel = new JPanel(new BorderLayout());
    myNameFieldPanel.add(new JLabel(JavaDebuggerBundle.message("label.user.renderers.configurable.renderer.name")), BorderLayout.WEST);
    myNameFieldPanel.add(myNameField, BorderLayout.CENTER);
    myNameFieldPanel.setVisible(false);

    final JPanel center = new JPanel(new BorderLayout(0, 4));
    center.add(myNameFieldPanel, BorderLayout.NORTH);
    center.add(myRendererDataConfigurable, BorderLayout.CENTER);

    myNameField.getDocument().addDocumentListener(new DocumentAdapter() {
      @Override
      protected void textChanged(@NotNull DocumentEvent e) {
        if (myCurrentRenderer != null) {
          myCurrentRenderer.setName(myNameField.getText());
          myRendererChooser.refresh(myCurrentRenderer);
        }
      }
    });

    Splitter splitter = new Splitter(false);
    splitter.setProportion(0.3f);
    splitter.setFirstComponent(decorator.createPanel());
    splitter.setSecondComponent(center);
    add(splitter, BorderLayout.CENTER);
  }

  @Override
  public void dispose() {
  }

  @Override
  @NotNull
  public JComponent getComponent() {
    return this;
  }

  private void setupRenderersList() {
    myRendererChooser.getEmptyText().setText(JavaDebuggerBundle.message("text.user.renderers.configurable.no.renderers"));

    myRendererChooser.addElementsMarkListener((ElementsChooser.ElementsMarkListener<NodeRenderer>)NodeRenderer::setEnabled);
    myRendererChooser.addListSelectionListener(e -> {
      if (!e.getValueIsAdjusting()) {
        updateCurrentRenderer(myRendererChooser.getSelectedElements());
      }
    });
  }

  private void updateCurrentRenderer(List<NodeRenderer> selectedElements) {
    if (selectedElements.size() != 1) {
      // multi selection
      setCurrentRenderer(null);
    }
    else {
      setCurrentRenderer(selectedElements.get(0));
    }
  }

  private void setCurrentRenderer(NodeRenderer renderer) {
    if (myCurrentRenderer == renderer) {
      return;
    }
    if (myRendererDataConfigurable.isModified()) {
      myRendererDataConfigurable.apply();
    }
    myCurrentRenderer = renderer;
    if (renderer != null) {
      myNameFieldPanel.setVisible(true);
      myNameField.setText(renderer.getName());
    }
    else {
      myNameFieldPanel.setVisible(false);
      myNameField.setText("");
    }
    myRendererDataConfigurable.setRenderer(renderer);
  }

  @Override
  public void apply(@NotNull NodeRendererSettings settings) {
    myRendererDataConfigurable.apply();
    flushTo(settings.getCustomRenderers());

    settings.fireRenderersChanged();
  }

  private void flushTo(final RendererConfiguration rendererConfiguration) {
    final int count = myRendererChooser.getElementCount();
    final List<NodeRenderer> renderers = new ArrayList<>(count);
    for (int idx = 0; idx < count; idx++) {
      renderers.add(myRendererChooser.getElementAt(idx));
    }
    rendererConfiguration.setRenderers(renderers);
  }

  @Override
  public boolean isModified(@NotNull NodeRendererSettings settings) {
    if (myRendererDataConfigurable.isModified()) {
      return true;
    }
    final RendererConfiguration rendererConfiguration = settings.getCustomRenderers();
    if (myRendererChooser.getElementCount() != rendererConfiguration.getRendererCount()) {
      return true;
    }
    final RendererConfiguration uiConfiguration = new RendererConfiguration(settings);
    flushTo(uiConfiguration);
    return !uiConfiguration.equals(rendererConfiguration);
  }

  @Override
  public void reset(@NotNull NodeRendererSettings settings) {
    myRendererChooser.removeAllElements();
    final RendererConfiguration rendererConfiguration = settings.getCustomRenderers();
    final ArrayList<NodeRenderer> elementsToSelect = new ArrayList<>(1);
    rendererConfiguration.iterateRenderers(renderer -> {
      final NodeRenderer clonedRenderer = (NodeRenderer)renderer.clone();
      myRendererChooser.addElement(clonedRenderer, clonedRenderer.isEnabled());
      if (elementsToSelect.size() == 0) {
        elementsToSelect.add(clonedRenderer);
      }
      return true;
    });
    myRendererChooser.selectElements(elementsToSelect);
    updateCurrentRenderer(elementsToSelect);
    myRendererDataConfigurable.reset();
  }

  public void addRenderer(NodeRenderer renderer) {
    myRendererChooser.addElement(renderer, renderer.isEnabled());
    myRendererChooser.moveElement(renderer, 0);
  }

  private class AddAction implements AnActionButtonRunnable {
    @Override
    public void run(AnActionButton button) {
      NodeRenderer renderer = (NodeRenderer)NodeRendererSettings.getInstance().createRenderer(CompoundReferenceRenderer.UNIQUE_ID);
      renderer.setEnabled(true);
      addRenderer(renderer);
    }
  }

  private class RemoveAction implements AnActionButtonRunnable {
    @Override
    public void run(AnActionButton button) {
      myRendererChooser.getSelectedElements().forEach(myRendererChooser::removeElement);
    }
  }

  private class CopyAction extends AnActionButton {
    CopyAction() {
      super(JavaDebuggerBundle.messagePointer("button.copy"), JavaDebuggerBundle
        .messagePointer("user.renderers.configurable.button.description.copy"), PlatformIcons.COPY_ICON);
    }

    @Override
    public void actionPerformed(@NotNull AnActionEvent e) {
      final NodeRenderer selectedElement = myRendererChooser.getSelectedElement();
      if (selectedElement != null) {
        myRendererChooser.addElement((NodeRenderer)selectedElement.clone(), true);
      }
    }

    @Override
    public void updateButton(@NotNull AnActionEvent e) {
      super.updateButton(e);
      e.getPresentation().setEnabled(myRendererChooser.getSelectedElement() != null);
    }

    @Override
    public @NotNull ActionUpdateThread getActionUpdateThread() {
      return ActionUpdateThread.EDT;
    }
  }

  private class MoveAction implements AnActionButtonRunnable {
    private final boolean myMoveUp;

    MoveAction(boolean up) {
      myMoveUp = up;
    }

    @Override
    public void run(AnActionButton button) {
      final int selectedRow = myRendererChooser.getSelectedElementRow();
      if (selectedRow < 0) {
        return;
      }
      int newRow = selectedRow + (myMoveUp ? -1 : 1);
      if (newRow < 0) {
        newRow = myRendererChooser.getElementCount() - 1;
      }
      else if (newRow >= myRendererChooser.getElementCount()) {
        newRow = 0;
      }
      myRendererChooser.moveElement(myRendererChooser.getElementAt(selectedRow), newRow);
    }
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.settings;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.PersistentStateComponent;
import com.intellij.openapi.components.SettingsCategory;
import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.util.xmlb.XmlSerializerUtil;
import org.jetbrains.annotations.NotNull;

@State(name = "ViewsSettings", storages = @Storage("debugger.xml"), category = SettingsCategory.TOOLS)
public final class ViewsGeneralSettings implements PersistentStateComponent<ViewsGeneralSettings> {
  public boolean HIDE_NULL_ARRAY_ELEMENTS = true;
  public boolean AUTOSCROLL_TO_NEW_LOCALS = true;
  public boolean USE_DFA_ASSIST = true;
  public boolean USE_DFA_ASSIST_GRAY_OUT = true;
  public boolean POPULATE_THROWABLE_STACKTRACE = true;

  public static ViewsGeneralSettings getInstance() {
    return ApplicationManager.getApplication().getService(ViewsGeneralSettings.class);
  }

  @Override
  public void loadState(@NotNull ViewsGeneralSettings state) {
    XmlSerializerUtil.copyBean(state, this);
  }

  @Override
  public ViewsGeneralSettings getState() {
    return this;
  }

  public boolean equals(Object object) {
    return object instanceof ViewsGeneralSettings generalSettings && 
           HIDE_NULL_ARRAY_ELEMENTS == generalSettings.HIDE_NULL_ARRAY_ELEMENTS &&
           AUTOSCROLL_TO_NEW_LOCALS == generalSettings.AUTOSCROLL_TO_NEW_LOCALS &&
           POPULATE_THROWABLE_STACKTRACE == generalSettings.POPULATE_THROWABLE_STACKTRACE &&
           USE_DFA_ASSIST == generalSettings.USE_DFA_ASSIST &&
           USE_DFA_ASSIST_GRAY_OUT == generalSettings.USE_DFA_ASSIST_GRAY_OUT;
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui;

import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.JavaStackFrame;
import com.intellij.debugger.engine.events.DebuggerCommandImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.DebuggerSession;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.settings.DebuggerSettings;
import com.intellij.ide.util.ModuleRendererFactory;
import com.intellij.openapi.fileEditor.FileEditor;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.project.DumbService;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.ComboBox;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.*;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.ui.EditorNotificationPanel;
import com.intellij.ui.EditorNotificationProvider;
import com.intellij.util.TextWithIcon;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.xdebugger.XDebugSession;
import com.intellij.xdebugger.XSourcePosition;
import com.intellij.xdebugger.frame.XStackFrame;
import com.intellij.xdebugger.impl.ui.DebuggerUIUtil;
import com.sun.jdi.Location;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.function.Function;
import java.util.stream.Collectors;

public final class AlternativeSourceNotificationProvider implements EditorNotificationProvider {

  private static final Key<Boolean> FILE_PROCESSED_KEY = Key.create("AlternativeSourceCheckDone");

  @Override
  public @Nullable Function<? super @NotNull FileEditor, ? extends @Nullable JComponent> collectNotificationData(@NotNull Project project,
                                                                                                                 @NotNull VirtualFile file) {
    if (!DebuggerSettings.getInstance().SHOW_ALTERNATIVE_SOURCE) {
      return null;
    }

    if (DumbService.getInstance(project).isDumb()) {
      return null;
    }

    DebuggerSession javaSession = DebuggerManagerEx.getInstanceEx(project).getContext().getDebuggerSession();
    XDebugSession session = javaSession != null ? javaSession.getXDebugSession() : null;

    if (session == null) {
      setFileProcessed(file, false);
      return null;
    }

    XSourcePosition position = session.getCurrentPosition();
    if (position == null || !file.equals(position.getFile())) {
      setFileProcessed(file, false);
      return null;
    }

    final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);
    if (!(psiFile instanceof PsiJavaFile)) {
      return null;
    }

    PsiClass[] classes = ((PsiJavaFile)psiFile).getClasses();
    if (classes.length == 0) {
      return null;
    }

    PsiClass baseClass = classes[0];
    String name = baseClass.getQualifiedName();
    if (name == null) {
      return null;
    }

    PsiClass[] altClasses = JavaPsiFacade.getInstance(project).findClasses(name, javaSession.getSearchScope());
    if (altClasses.length == 0) {
      altClasses = JavaPsiFacade.getInstance(project).findClasses(name, GlobalSearchScope.allScope(project));
    }
    setFileProcessed(file, true);
    if (altClasses.length <= 1) {
      return null;
    }
    ArrayList<PsiClass> alts = Arrays.stream(altClasses)
      .distinct()
      .filter(cls -> !(cls.equals(baseClass) || cls.getNavigationElement().equals(baseClass)))
      .collect(Collectors.toCollection(()->new ArrayList<>()));
    alts.add(0, baseClass);

    ComboBoxClassElement[] elems = ContainerUtil.map2Array(alts,
                                                           ComboBoxClassElement.class,
                                                           psiClass -> new ComboBoxClassElement((PsiClass)psiClass.getNavigationElement()));

    String locationDeclName = null;
    XStackFrame frame = session.getCurrentStackFrame();
    if (frame instanceof JavaStackFrame) {
      Location location = ((JavaStackFrame)frame).getDescriptor().getLocation();
      if (location != null) {
        locationDeclName = location.declaringType().name();
      }
    }

    String finalLocationDeclName = locationDeclName;
    return fileEditor -> new AlternativeSourceNotificationPanel(fileEditor,
                                                                project,
                                                                JavaDebuggerBundle.message("editor.notification.alternative.source", name),
                                                                file,
                                                                elems,
                                                                finalLocationDeclName
    );
  }

  private static class ComboBoxClassElement {
    private final PsiClass myClass;
    private String myText;

    ComboBoxClassElement(PsiClass aClass) {
      myClass = aClass;
    }

    @Override
    public String toString() {
      if (myText == null) {
        ModuleRendererFactory factory = ModuleRendererFactory.findInstance(myClass);
        TextWithIcon moduleTextWithIcon = factory.getModuleTextWithIcon(myClass);
        myText = moduleTextWithIcon == null ? "" : moduleTextWithIcon.getText();
      }
      return myText;
    }
  }

  public static boolean isFileProcessed(VirtualFile file) {
    return FILE_PROCESSED_KEY.get(file) != null;
  }

  public static void setFileProcessed(VirtualFile file, boolean value) {
    FILE_PROCESSED_KEY.set(file, value ? Boolean.TRUE : null);
  }

  private static class AlternativeSourceNotificationPanel extends EditorNotificationPanel {

    AlternativeSourceNotificationPanel(@NotNull FileEditor fileEditor,
                                       @NotNull Project project,
                                       @NotNull @Nls String text,
                                       @NotNull VirtualFile file,
                                       ComboBoxClassElement[] alternatives,
                                       @Nullable String locationDeclName) {
      super(fileEditor, EditorNotificationPanel.Status.Info);

      setText(text);

      final ComboBox<ComboBoxClassElement> switcher = new ComboBox<>(alternatives);
      switcher.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent e) {
          final DebuggerContextImpl context = DebuggerManagerEx.getInstanceEx(project).getContext();
          final DebuggerSession session = context.getDebuggerSession();
          final PsiClass item = ((ComboBoxClassElement)switcher.getSelectedItem()).myClass;
          final VirtualFile vFile = item.getContainingFile().getVirtualFile();
          if (session != null && vFile != null) {
            session.getProcess().getManagerThread().schedule(new DebuggerCommandImpl() {
              @Override
              protected void action() {
                if (!StringUtil.isEmpty(locationDeclName)) {
                  DebuggerUtilsEx.setAlternativeSourceUrl(locationDeclName, vFile.getUrl(), project);
                }
                DebuggerUIUtil.invokeLater(() -> {
                  FileEditorManager.getInstance(project).closeFile(file);
                  session.refresh(true);
                });
              }
            });
          }
          else {
            FileEditorManager.getInstance(project).closeFile(file);
            item.navigate(true);
          }
        }
      });
      myLinksPanel.add(switcher);
      createActionLabel(JavaDebuggerBundle.message("action.hide.text"), () -> {
        DebuggerSettings.getInstance().SHOW_ALTERNATIVE_SOURCE = false;
        setFileProcessed(file, false);
        FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);
        FileEditor editor = fileEditorManager.getSelectedEditor(file);
        if (editor != null) {
          fileEditorManager.removeTopComponent(editor, this);
        }
      });
    }
  }
}
<?xml version="1.0" encoding="UTF-8"?>
<form xmlns="http://www.intellij.com/uidesigner/form/" version="1" bind-to-class="com.intellij.debugger.ui.breakpoints.AddFieldBreakpointDialog">
  <grid id="dbe86" binding="myPanel" row-count="6" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="6">
    <margin top="0" left="0" bottom="0" right="0"/>
    <constraints>
      <xy x="74" y="134" width="245" height="152"/>
      <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
        <preferred-size width="200" height="-1"/>
      </grid>
    </constraints>
    <properties/>
    <border type="none"/>
    <children>
      <component id="9636d" class="com.intellij.openapi.ui.TextFieldWithBrowseButton" binding="myClassChooser">
        <constraints>
          <xy x="0" y="26" width="245" height="22"/>
          <grid row="1" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
            <preferred-size width="150" height="-1"/>
          </grid>
        </constraints>
        <properties/>
      </component>
      <component id="c2ef3" class="com.intellij.openapi.ui.TextFieldWithBrowseButton" binding="myFieldChooser">
        <constraints>
          <xy x="0" y="80" width="245" height="22"/>
          <grid row="3" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
            <preferred-size width="150" height="-1"/>
          </grid>
        </constraints>
        <properties/>
      </component>
      <xy id="3cfba" hgap="-1" vgap="-1">
        <margin top="0" left="0" bottom="0" right="0"/>
        <constraints>
          <xy x="0" y="151" width="245" height="1"/>
          <grid row="5" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="2" fill="1">
            <minimum-size width="-1" height="1"/>
            <maximum-size width="-1" height="1"/>
          </grid>
        </constraints>
        <properties/>
        <border type="bevel-raised"/>
        <children/>
      </xy>
      <vspacer id="339be">
        <constraints>
          <xy x="117" y="108" width="11" height="24"/>
          <grid row="4" column="0" row-span="1" col-span="1" vsize-policy="6" hsize-policy="1" anchor="0" fill="2"/>
        </constraints>
      </vspacer>
      <component id="e8c64" class="javax.swing.JLabel">
        <constraints>
          <xy x="0" y="56" width="69" height="16"/>
          <grid row="2" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="0" anchor="8" fill="0"/>
        </constraints>
        <properties>
          <text resource-bundle="messages/JavaDebuggerBundle" key="label.add.field.breakpoint.dialog.field.name"/>
        </properties>
      </component>
      <component id="c159b" class="javax.swing.JLabel">
        <constraints>
          <xy x="0" y="2" width="181" height="16"/>
          <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="0" anchor="8" fill="0"/>
        </constraints>
        <properties>
          <text resource-bundle="messages/JavaDebuggerBundle" key="label.add.field.breakpoint.dialog.fq.name"/>
        </properties>
      </component>
    </children>
  </grid>
</form>
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

/*
 * @author Eugene Zhuravlev
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.codeInsight.generation.PsiFieldMember;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.ide.util.MemberChooser;
import com.intellij.ide.util.TreeClassChooser;
import com.intellij.ide.util.TreeClassChooserFactory;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.openapi.ui.TextFieldWithBrowseButton;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.*;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.ui.DocumentAdapter;
import com.intellij.util.containers.ContainerUtil;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.List;

public abstract class AddFieldBreakpointDialog extends DialogWrapper {
  private final Project myProject;
  private JPanel myPanel;
  private TextFieldWithBrowseButton myFieldChooser;
  private TextFieldWithBrowseButton myClassChooser;

  public AddFieldBreakpointDialog(Project project) {
    super(project, true);
    myProject = project;
    setTitle(JavaDebuggerBundle.message("add.field.breakpoint.dialog.title"));
    init();
  }

  @Override
  protected JComponent createCenterPanel() {
    myClassChooser.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {
      @Override
      public void textChanged(@NotNull DocumentEvent event) {
        updateUI();
      }
    });

    myClassChooser.addActionListener(new ActionListener() {
      @Override
      public void actionPerformed(ActionEvent e) {
        PsiClass currentClass = getSelectedClass();
        TreeClassChooser chooser = TreeClassChooserFactory.getInstance(myProject).createAllProjectScopeChooser(
          JavaDebuggerBundle.message("add.field.breakpoint.dialog.classchooser.title"));
        if (currentClass != null) {
          PsiFile containingFile = currentClass.getContainingFile();
          if (containingFile != null) {
            PsiDirectory containingDirectory = containingFile.getContainingDirectory();
            if (containingDirectory != null) {
              chooser.selectDirectory(containingDirectory);
            }
          }
        }
        chooser.showDialog();
        PsiClass selectedClass = chooser.getSelected();
        if (selectedClass != null) {
          myClassChooser.setText(selectedClass.getQualifiedName());
        }
      }
    });

    myFieldChooser.addActionListener(new ActionListener() {
      @Override
      public void actionPerformed(ActionEvent e) {
        PsiClass selectedClass = getSelectedClass();
        if (selectedClass != null) {
          PsiField[] fields = selectedClass.getFields();
          MemberChooser<PsiFieldMember> chooser =
            new MemberChooser<>(ContainerUtil.map2Array(fields, PsiFieldMember.class, PsiFieldMember::new), false, false, myProject);
          chooser.setTitle(JavaDebuggerBundle.message("add.field.breakpoint.dialog.field.chooser.title", fields.length));
          chooser.setCopyJavadocVisible(false);
          chooser.show();
          List<PsiFieldMember> selectedElements = chooser.getSelectedElements();
          if (selectedElements != null && selectedElements.size() == 1) {
            PsiField field = selectedElements.get(0).getElement();
            myFieldChooser.setText(field.getName());
          }
        }
      }
    });
    myFieldChooser.setEnabled(false);
    return myPanel;
  }

  private void updateUI() {
    PsiClass selectedClass = getSelectedClass();
    myFieldChooser.setEnabled(selectedClass != null);
  }

  private PsiClass getSelectedClass() {
    final PsiManager psiManager = PsiManager.getInstance(myProject);
    String classQName = myClassChooser.getText();
    if (StringUtil.isEmpty(classQName)) {
      return null;
    }
    return JavaPsiFacade.getInstance(psiManager.getProject()).findClass(classQName, GlobalSearchScope.allScope(myProject));
  }

  @Override
  public JComponent getPreferredFocusedComponent() {
    return myClassChooser.getTextField();
  }

  public String getClassName() {
    return myClassChooser.getText();
  }

  @Override
  protected String getDimensionServiceKey() {
    return "#com.intellij.debugger.ui.breakpoints.BreakpointsConfigurationDialogFactory.BreakpointsConfigurationDialog.AddFieldBreakpointDialog";
  }

  public String getFieldName() {
    return myFieldChooser.getText();
  }

  protected abstract boolean validateData();

  @Override
  protected void doOKAction() {
    if (validateData()) {
      super.doOKAction();
    }
  }
}
/*
 * Copyright 2004-2006 Alexey Efimov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.openapi.ui.Messages;

import javax.swing.*;

/**
 * @author Eugene Zhuravlev
 */
public class AddWildcardBreakpointDialog extends DialogWrapper {
  private JPanel myPanel;
  private JTextField myClassPatternField;
  private JTextField myMethodNameField;

  public AddWildcardBreakpointDialog(Project project) {
    super(project, true);
    setTitle(JavaDebuggerBundle.message("add.method.breakpoint"));
    init();
  }

  @Override
  protected void doOKAction() {
    if (getClassPattern().length() == 0) {
      Messages.showErrorDialog(myPanel, JavaDebuggerBundle.message("class.pattern.not.specified"));
      return;
    }
    if (getMethodName().length() == 0) {
      Messages.showErrorDialog(myPanel, JavaDebuggerBundle.message("method.name.not.specified"));
      return;
    }
    super.doOKAction();
  }

  @Override
  public JComponent getPreferredFocusedComponent() {
    return myClassPatternField;
  }

  public String getClassPattern() {
    return myClassPatternField.getText().trim();
  }

  public String getMethodName() {
    return myMethodNameField.getText().trim();
  }

  @Override
  protected JComponent createCenterPanel() {
    return myPanel;
  }
}
<?xml version="1.0" encoding="UTF-8"?>
<form xmlns="http://www.intellij.com/uidesigner/form/" version="1" bind-to-class="com.intellij.debugger.ui.breakpoints.AddWildcardBreakpointDialog">
  <grid id="9b829" binding="myPanel" row-count="5" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
    <margin top="0" left="0" bottom="0" right="0"/>
    <constraints>
      <xy x="120" y="73" width="414" height="149"/>
      <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="3" indent="0"/>
    </constraints>
    <properties/>
    <border type="none"/>
    <children>
      <component id="ee438" class="javax.swing.JTextField" binding="myClassPatternField">
        <constraints>
          <xy x="2" y="27" width="410" height="22"/>
          <grid row="1" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="6" anchor="8" fill="1" indent="0">
            <preferred-size width="300" height="-1"/>
          </grid>
        </constraints>
        <properties/>
      </component>
      <component id="4c818" class="javax.swing.JLabel">
        <constraints>
          <xy x="2" y="56" width="84" height="16"/>
          <grid row="2" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="0" anchor="8" fill="0" indent="0"/>
        </constraints>
        <properties>
          <labelFor value="2d944"/>
          <nextFocusableComponent value=""/>
          <text resource-bundle="messages/JavaDebuggerBundle" key="label.add.wildcard.breakpoint.dialog.method.name"/>
        </properties>
      </component>
      <component id="2d944" class="javax.swing.JTextField" binding="myMethodNameField">
        <constraints>
          <xy x="2" y="79" width="410" height="22"/>
          <grid row="3" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="6" anchor="8" fill="1" indent="0">
            <preferred-size width="150" height="-1"/>
          </grid>
        </constraints>
        <properties/>
      </component>
      <vspacer id="2b528">
        <constraints>
          <xy x="201" y="101" width="11" height="46"/>
          <grid row="4" column="0" row-span="1" col-span="1" vsize-policy="6" hsize-policy="1" anchor="0" fill="2" indent="0"/>
        </constraints>
      </vspacer>
      <component id="7fca9" class="javax.swing.JLabel">
        <constraints>
          <xy x="2" y="4" width="82" height="16"/>
          <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="0" anchor="8" fill="0" indent="0"/>
        </constraints>
        <properties>
          <labelFor value="ee438"/>
          <text resource-bundle="messages/JavaDebuggerBundle" key="label.add.wildcard.breakpoint.dialog.class.pattern"/>
        </properties>
      </component>
    </children>
  </grid>
</form>
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Class AnyExceptionBreakpoint
 * @author Jeka
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcess;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerManagerThreadImpl;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.Key;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.sun.jdi.ReferenceType;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.java.debugger.breakpoints.properties.JavaExceptionBreakpointProperties;

public class AnyExceptionBreakpoint extends ExceptionBreakpoint {
  public static final @NonNls Key<AnyExceptionBreakpoint> ANY_EXCEPTION_BREAKPOINT = BreakpointCategory.lookup("breakpoint_any");

  protected AnyExceptionBreakpoint(Project project, XBreakpoint<JavaExceptionBreakpointProperties> xBreakpoint) {
    super(project, null, null, xBreakpoint);
    //setEnabled(false);
  }

  @Override
  public Key<AnyExceptionBreakpoint> getCategory() {
    return ANY_EXCEPTION_BREAKPOINT;
  }

  @Override
  public String getDisplayName() {
    return JavaDebuggerBundle.message("breakpoint.any.exception.display.name");
  }

  @Override
  public void createRequest(DebugProcessImpl debugProcess) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    if (!shouldCreateRequest(debugProcess)) {
      return;
    }
    super.processClassPrepare(debugProcess, null);
  }

  @Override
  public void processClassPrepare(DebugProcess debugProcess, ReferenceType refType) {
    // should be emty - does not make sense for this breakpoint
  }

  @Override
  public void readExternal(Element parentNode) throws InvalidDataException {
    try {
      super.readExternal(parentNode);
    }
    catch (InvalidDataException e) {
      if (!getReadNoClassName().equals(e.getMessage())) throw e;
    }
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

/*
 * Class Breakpoint
 * @author Jeka
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.*;
import com.intellij.debugger.actions.ThreadDumpAction;
import com.intellij.debugger.engine.*;
import com.intellij.debugger.engine.evaluation.*;
import com.intellij.debugger.engine.evaluation.expression.EvaluatorBuilderImpl;
import com.intellij.debugger.engine.evaluation.expression.ExpressionEvaluator;
import com.intellij.debugger.engine.evaluation.expression.UnsupportedExpressionException;
import com.intellij.debugger.engine.events.SuspendContextCommandImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.jdi.StackFrameProxyImpl;
import com.intellij.debugger.jdi.ThreadReferenceProxyImpl;
import com.intellij.debugger.jdi.VirtualMachineProxyImpl;
import com.intellij.debugger.memory.utils.StackFrameItem;
import com.intellij.debugger.requests.ClassPrepareRequestor;
import com.intellij.debugger.requests.Requestor;
import com.intellij.debugger.settings.DebuggerSettings;
import com.intellij.debugger.ui.impl.watch.CompilingEvaluatorImpl;
import com.intellij.debugger.ui.overhead.OverheadProducer;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.project.IndexNotReadyException;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.JDOMExternalizerUtil;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.NlsContexts;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiCodeFragment;
import com.intellij.psi.PsiElement;
import com.intellij.ui.AppUIUtil;
import com.intellij.ui.SimpleColoredComponent;
import com.intellij.ui.classFilter.ClassFilter;
import com.intellij.util.ObjectUtils;
import com.intellij.util.ThreeState;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.xdebugger.XExpression;
import com.intellij.xdebugger.breakpoints.SuspendPolicy;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.XLineBreakpoint;
import com.intellij.xdebugger.impl.XDebugSessionImpl;
import com.intellij.xdebugger.impl.XDebuggerHistoryManager;
import com.intellij.xdebugger.impl.XDebuggerUtilImpl;
import com.intellij.xdebugger.impl.breakpoints.XBreakpointBase;
import com.intellij.xdebugger.impl.breakpoints.XExpressionImpl;
import com.intellij.xdebugger.impl.breakpoints.ui.XBreakpointActionsPanel;
import com.sun.jdi.*;
import com.sun.jdi.event.LocatableEvent;
import com.sun.jdi.request.EventRequest;
import one.util.streamex.StreamEx;
import org.jdom.Element;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties;

import javax.swing.*;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Stream;

public abstract class Breakpoint<P extends JavaBreakpointProperties> implements FilteredRequestor, ClassPrepareRequestor, OverheadProducer {
  public static final Key<Breakpoint<?>> DATA_KEY = Key.create("JavaBreakpoint");
  private static final Key<Long> HIT_COUNTER = Key.create("HIT_COUNTER");

  final XBreakpoint<P> myXBreakpoint;
  @NotNull
  protected final Project myProject;

  @NonNls private static final String LOG_MESSAGE_OPTION_NAME = "LOG_MESSAGE";
  protected boolean myCachedVerifiedState = false;

  protected Breakpoint(@NotNull Project project, XBreakpoint<P> xBreakpoint) {
    myProject = project;
    myXBreakpoint = xBreakpoint;
  }

  @NotNull
  public Project getProject() {
    return myProject;
  }

  @NotNull
  protected P getProperties() {
    return myXBreakpoint.getProperties();
  }

  public final XBreakpoint<P> getXBreakpoint() {
    return myXBreakpoint;
  }

  @Nullable
  public abstract PsiClass getPsiClass();

  /**
   * Request for creating all needed JPDA requests in the specified VM
   *
   * @param debugProcess the requesting process
   */
  public abstract void createRequest(DebugProcessImpl debugProcess);

  static boolean shouldCreateRequest(Requestor requestor, XBreakpoint xBreakpoint, DebugProcessImpl debugProcess, boolean forPreparedClass) {
    return ReadAction.compute(() -> {
      JavaDebugProcess process = debugProcess.getXdebugProcess();
      return process != null
             && debugProcess.isAttached()
             && (xBreakpoint == null || ((XDebugSessionImpl)process.getSession()).isBreakpointActive(xBreakpoint))
             && (forPreparedClass || debugProcess.getRequestsManager().findRequests(requestor).isEmpty());
    });
  }

  protected final boolean shouldCreateRequest(DebugProcessImpl debugProcess, boolean forPreparedClass) {
    return shouldCreateRequest(this, getXBreakpoint(), debugProcess, forPreparedClass);
  }

  protected final boolean shouldCreateRequest(DebugProcessImpl debugProcess) {
    return shouldCreateRequest(debugProcess, false);
  }

  /**
   * Request for creating all needed JPDA requests in the specified VM
   *
   * @param debuggerProcess the requesting process
   */
  @Override
  public abstract void processClassPrepare(DebugProcess debuggerProcess, final ReferenceType referenceType);

  @Override
  public void customizeRenderer(SimpleColoredComponent renderer) {
    if (myXBreakpoint != null) {
      renderer.setIcon(myXBreakpoint.getType().getEnabledIcon());
    }
    else {
      renderer.setIcon(AllIcons.Debugger.Db_set_breakpoint);
    }
    renderer.append(getDisplayName());
  }

  @Override
  public boolean isObsolete() {
    return myXBreakpoint instanceof XBreakpointBase && ((XBreakpointBase<?, ?, ?>)myXBreakpoint).isDisposed();
  }

  public abstract @NlsContexts.Label String getDisplayName();

  public String getShortName() {
    return getDisplayName();
  }

  @Nullable
  public String getClassName() {
    return null;
  }

  public void markVerified(boolean isVerified) {
    myCachedVerifiedState = isVerified;
  }

  public boolean isRemoveAfterHit() {
    return myXBreakpoint instanceof XLineBreakpoint && ((XLineBreakpoint<?>)myXBreakpoint).isTemporary();
  }

  public void setRemoveAfterHit(boolean value) {
    if (myXBreakpoint instanceof XLineBreakpoint) {
      ((XLineBreakpoint<?>)myXBreakpoint).setTemporary(value);
    }
  }

  @Nullable
  public String getShortClassName() {
    final String className = getClassName();
    if (className == null) {
      return null;
    }

    final int dotIndex = className.lastIndexOf('.');
    return dotIndex >= 0 && dotIndex + 1 < className.length() ? className.substring(dotIndex + 1) : className;
  }

  @Nullable
  public String getPackageName() {
    return null;
  }

  public abstract Icon getIcon();

  public abstract void reload();

  /**
   * returns UI representation
   */
  public abstract @Nls String getEventMessage(LocatableEvent event);

  protected String getStackTrace(SuspendContextImpl suspendContext) {
    StringBuilder builder = new StringBuilder(JavaDebuggerBundle.message("status.line.breakpoint.reached.full.trace"));
    try {
      List<StackFrameItem> asyncStack = null;
      for (StackFrameProxyImpl frameProxy : suspendContext.getThread().forceFrames()) {
        Location location = frameProxy.location();
        builder.append("\n\t").append(ThreadDumpAction.renderLocation(location));
        if (Registry.is("debugger.log.async.stacks")) {
          if (asyncStack != null) {
            StreamEx.of(asyncStack).prepend((StackFrameItem)null).forEach(s -> {
              builder.append("\n\t");
              if (s == null) {
                builder.append(" - ").append(StackFrameItem.getAsyncStacktraceMessage());
              }
              else {
                builder.append(ThreadDumpAction.renderLocation(s.location()));
              }
            });
            break;
          }
          asyncStack = AsyncStacksUtils.getAgentRelatedStack(frameProxy, suspendContext);
        }
      }
    }
    catch (EvaluateException e) {
      builder.append("Stacktrace not available: ").append(e.getMessage());
    }
    return builder.toString();
  }

  public abstract boolean isValid();

  public abstract Key<? extends Breakpoint> getCategory();

  /**
   * Associates breakpoint with class.
   * Create requests for loaded class and registers callback for loading classes
   *
   * @param debugProcess the requesting process
   */
  protected void createOrWaitPrepare(DebugProcessImpl debugProcess, String classToBeLoaded) {
    debugProcess.getRequestsManager().callbackOnPrepareClasses(this, classToBeLoaded);
    VirtualMachineProxyImpl virtualMachineProxy = debugProcess.getVirtualMachineProxy();
    if (virtualMachineProxy.canBeModified()) {
      processClassesPrepare(debugProcess, virtualMachineProxy.classesByName(classToBeLoaded).stream());
    }
  }

  protected void createOrWaitPrepare(final DebugProcessImpl debugProcess, @NotNull final SourcePosition classPosition) {
    debugProcess.getRequestsManager().callbackOnPrepareClasses(this, classPosition);
    if (debugProcess.getVirtualMachineProxy().canBeModified() && !isObsolete()) {
      processClassesPrepare(debugProcess, debugProcess.getPositionManager().getAllClasses(classPosition).stream().distinct());
    }
  }

  private void processClassesPrepare(DebugProcessImpl debugProcess, Stream<ReferenceType> classes) {
    classes.filter(ReferenceType::isPrepared).forEach(refType -> processClassPrepare(debugProcess, refType));
  }

  protected ObjectReference getThisObject(SuspendContextImpl context, LocatableEvent event) throws EvaluateException {
    ThreadReferenceProxyImpl thread = context.getThread();
    if (thread != null) {
      StackFrameProxyImpl stackFrameProxy = context.getFrameProxy();
      if (stackFrameProxy != null) {
        return stackFrameProxy.thisObject();
      }
    }
    return null;
  }

  @Override
  public boolean processLocatableEvent(@NotNull SuspendContextCommandImpl action, LocatableEvent event) throws EventProcessingException {
    SuspendContextImpl context = action.getSuspendContext();
    if (!isValid()) {
      context.getDebugProcess().getRequestsManager().deleteRequest(this);
      return false;
    }

    String title = JavaDebuggerBundle.message("title.error.evaluating.breakpoint.condition");

    try {
      StackFrameProxyImpl frameProxy = context.getFrameProxy();
      if (frameProxy == null) {
        // might be if the thread has been collected
        return false;
      }

      EvaluationContextImpl evaluationContext = new EvaluationContextImpl(context, frameProxy, () -> getThisObject(context, event));

      if (!evaluateCondition(evaluationContext, event)) {
        return false;
      }

      title = JavaDebuggerBundle.message("title.error.evaluating.breakpoint.action");
      runAction(evaluationContext, event);
    }
    catch (final EvaluateException ex) {
      if (ApplicationManager.getApplication().isUnitTestMode()) {
        System.out.println(ex.getMessage());
        return false;
      }

      throw new EventProcessingException(title, ex.getMessage(), ex);
    }

    return true;
  }

  private void runAction(EvaluationContextImpl context, LocatableEvent event) {
    DebugProcessImpl debugProcess = context.getDebugProcess();
    if (getProperties().isTRACING_START() && Registry.is("debugger.call.tracing")) {
      CallTracer.get(debugProcess).start(context.getSuspendContext().getThread());
    }
    if (getProperties().isTRACING_END() && Registry.is("debugger.call.tracing")) {
      CallTracer.get(debugProcess).stop(event.thread());
    }
    if (isLogEnabled() || isLogExpressionEnabled() || isLogStack()) {
      StringBuilder buf = new StringBuilder();
      if (myXBreakpoint.isLogMessage()) {
        buf.append(getEventMessage(event)).append("\n");
      }

      if (isLogStack()) {
        buf.append(getStackTrace(context.getSuspendContext())).append("\n");
      }

      if (isLogExpressionEnabled()) {
        if (!debugProcess.isAttached()) {
          return;
        }

        TextWithImports logMessage = getLogMessage();
        try {
          SourcePosition position = ContextUtil.getSourcePosition(context);
          PsiElement element = ContextUtil.getContextElement(context, position);
          ExpressionEvaluator evaluator = DebuggerInvocationUtil.commitAndRunReadAction(myProject,
            () -> EvaluatorCache.cacheOrGet("LogMessageEvaluator", event.request(), element, logMessage, () ->
              createExpressionEvaluator(myProject, element, position, logMessage, this::createLogMessageCodeFragment)));
          Value eval = evaluator.evaluate(context);
          buf.append(eval instanceof VoidValue ? "void" : DebuggerUtils.getValueAsString(context, eval));
        }
        catch (EvaluateException e) {
          buf.append(JavaDebuggerBundle.message("error.unable.to.evaluate.expression"))
            .append(" \"").append(logMessage).append("\"")
            .append(" : ").append(e.getMessage());
        }
        buf.append("\n");
      }
      if (buf.length() > 0) {
        debugProcess.printToConsole(buf.toString());
      }
    }
    if (isRemoveAfterHit()) {
      handleTemporaryBreakpointHit(debugProcess);
    }
  }

  /**
   * @return true if the ID was added or false otherwise
   */
  private boolean hasObjectID(long id) {
    return ContainerUtil.exists(getInstanceFilters(), instanceFilter -> instanceFilter.getId() == id);
  }

  public boolean evaluateCondition(final EvaluationContextImpl context, LocatableEvent event) throws EvaluateException {
    DebugProcessImpl debugProcess = context.getDebugProcess();
    if (isCountFilterEnabled() && !isConditionEnabled()) {
      debugProcess.getVirtualMachineProxy().suspend();
      debugProcess.getRequestsManager().deleteRequest(this);
      createRequest(debugProcess);
      debugProcess.getVirtualMachineProxy().resume();
    }

    StackFrameProxyImpl frame = context.getFrameProxy();
    if (getProperties().isCALLER_FILTERS_ENABLED() && frame != null) {
      ThreadReferenceProxyImpl threadProxy = frame.threadProxy();
      StackFrameProxyImpl parentFrame = threadProxy.frameCount() > 1 ? threadProxy.frame(1) : null;
      String key = parentFrame != null ? DebuggerUtilsEx.methodKey(parentFrame.location().method()) : null;
      if (!typeMatchesClassFilters(key, getProperties().getCallerFilters(), getProperties().getCallerExclusionFilters())) {
        return false;
      }
    }

    if (isInstanceFiltersEnabled()) {
      Value value = context.computeThisObject();
      if (value != null) {  // non-static
        ObjectReference reference = (ObjectReference)value;
        if (!hasObjectID(reference.uniqueID())) {
          return false;
        }
      }
    }

    if (isClassFiltersEnabled() &&
        !typeMatchesClassFilters(calculateEventClass(context, event), getClassFilters(), getClassExclusionFilters())) {
      return false;
    }

    if (isConditionEnabled()) {
      TextWithImports condition = getCondition();
      if (condition.isEmpty()) {
        return true;
      }

      if (frame != null) {
        Location location = frame.location();
        if (location != null) {
          ThreeState result = debugProcess.getPositionManager().evaluateCondition(context, frame, location, condition.getText());
          if (result != ThreeState.UNSURE) {
            return result == ThreeState.YES;
          }
        }
      }

      try {
        SourcePosition contextSourcePosition = ContextUtil.getSourcePosition(context);
        ExpressionEvaluator evaluator = DebuggerInvocationUtil.commitAndRunReadAction(myProject, () -> {
          // IMPORTANT: calculate context psi element basing on the location where the exception
          // has been hit, not on the location where it was set. (For line breakpoints these locations are the same, however,
          // for method, exception and field breakpoints these locations differ)
          PsiElement contextElement = ContextUtil.getContextElement(contextSourcePosition);
          PsiElement contextPsiElement = contextElement != null ? contextElement : getEvaluationElement(); // as a last resort
          return EvaluatorCache.cacheOrGet("ConditionEvaluator", event.request(), contextPsiElement, condition,
                                           () -> createExpressionEvaluator(myProject,
                                                                           contextPsiElement,
                                                                           contextSourcePosition,
                                                                           condition,
                                                                           this::createConditionCodeFragment));
        });
        if (!DebuggerUtilsEx.evaluateBoolean(evaluator, context)) {
          return false;
        }
      }
      catch (EvaluateException ex) {
        if (ex.getCause() instanceof VMDisconnectedException) {
          return false;
        }
        throw EvaluateExceptionUtil.createEvaluateException(
          JavaDebuggerBundle.message("error.failed.evaluating.breakpoint.condition", condition, ex.getMessage())
        );
      }
    }
    if (isCountFilterEnabled() && isConditionEnabled()) {
      long hitCount = ObjectUtils.notNull((Long)event.request().getProperty(HIT_COUNTER), 0L) + 1;
      event.request().putProperty(HIT_COUNTER, hitCount);
      return hitCount % getCountFilter() == 0;
    }
    return true;
  }

  private static final class EvaluatorCache {
    private final PsiElement myContext;
    private final TextWithImports myTextWithImports;
    private final ExpressionEvaluator myEvaluator;

    private EvaluatorCache(PsiElement context, TextWithImports textWithImports, ExpressionEvaluator evaluator) {
      myContext = context;
      myTextWithImports = textWithImports;
      myEvaluator = evaluator;
    }

    @Nullable
    static ExpressionEvaluator cacheOrGet(String propertyName,
                                          EventRequest request,
                                          PsiElement context,
                                          TextWithImports text,
                                          EvaluatingComputable<? extends ExpressionEvaluator> supplier) throws EvaluateException {
      EvaluatorCache cache = (EvaluatorCache)request.getProperty(propertyName);
      if (cache != null && Objects.equals(cache.myContext, context) && Objects.equals(cache.myTextWithImports, text)) {
        return cache.myEvaluator;
      }
      ExpressionEvaluator evaluator = supplier.compute();
      request.putProperty(propertyName, new EvaluatorCache(context, text, evaluator));
      return evaluator;
    }
  }

  private static ExpressionEvaluator createExpressionEvaluator(Project project,
                                                               PsiElement contextPsiElement,
                                                               SourcePosition contextSourcePosition,
                                                               TextWithImports text,
                                                               Function<? super PsiElement, ? extends PsiCodeFragment> fragmentFactory)
    throws EvaluateException {
    try {
      return EvaluatorBuilderImpl.build(text, contextPsiElement, contextSourcePosition, project);
    }
    catch (UnsupportedExpressionException ex) {
      ExpressionEvaluator eval = CompilingEvaluatorImpl.create(project, contextPsiElement, fragmentFactory);
      if (eval != null) {
        return eval;
      }
      throw ex;
    }
    catch (IndexNotReadyException ex) {
      throw new EvaluateException(JavaDebuggerBundle.message("evaluation.error.during.indexing"), ex);
    }
  }

  private PsiCodeFragment createConditionCodeFragment(PsiElement context) {
    return createCodeFragment(myProject, getCondition(), context);
  }

  private PsiCodeFragment createLogMessageCodeFragment(PsiElement context) {
    return createCodeFragment(myProject, getLogMessage(), context);
  }

  private static PsiCodeFragment createCodeFragment(Project project, TextWithImports text, PsiElement context) {
    return DebuggerUtilsEx.findAppropriateCodeFragmentFactory(text, context).createCodeFragment(text, context, project);
  }

  protected String calculateEventClass(EvaluationContextImpl context, LocatableEvent event) throws EvaluateException {
    String className = null;
    final ObjectReference thisObject = (ObjectReference)context.computeThisObject();
    if (thisObject != null) {
      className = thisObject.referenceType().name();
    }
    else {
      final StackFrameProxyImpl frame = context.getFrameProxy();
      if (frame != null) {
        className = frame.location().declaringType().name();
      }
    }
    return className;
  }

  protected static boolean typeMatchesClassFilters(@Nullable String typeName, ClassFilter[] includeFilters, ClassFilter[] excludeFilters) {
    if (typeName == null) {
      return true;
    }
    boolean matches = false, hasEnabled = false;
    for (ClassFilter classFilter : includeFilters) {
      if (classFilter.isEnabled()) {
        hasEnabled = true;
        if (classFilter.matches(typeName)) {
          matches = true;
          break;
        }
      }
    }
    if (hasEnabled && !matches) {
      return false;
    }
    return !ContainerUtil.exists(excludeFilters, classFilter -> classFilter.isEnabled() && classFilter.matches(typeName));
  }

  private void handleTemporaryBreakpointHit(final DebugProcessImpl debugProcess) {
    // need to delete the request immediately, see IDEA-133978
    debugProcess.getRequestsManager().deleteRequest(this);

    debugProcess.addDebugProcessListener(new DebugProcessListener() {
      @Override
      public void resumed(SuspendContext suspendContext) {
        removeBreakpoint();
      }

      @Override
      public void processDetached(@NotNull DebugProcess process, boolean closedByUser) {
        removeBreakpoint();
      }

      private void removeBreakpoint() {
        AppUIUtil.invokeOnEdt(() -> DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().removeBreakpoint(Breakpoint.this));
        debugProcess.removeDebugProcessListener(this);
      }
    });
  }

  public void updateUI() {
  }

  public void readExternal(Element parentNode) throws InvalidDataException {
    FilteredRequestorImpl requestor = new FilteredRequestorImpl(myProject);
    requestor.readTo(parentNode, this);
    try {
      setEnabled(Boolean.parseBoolean(JDOMExternalizerUtil.readField(parentNode, "ENABLED")));
    }
    catch (Exception ignored) {
    }
    try {
      setLogEnabled(Boolean.parseBoolean(JDOMExternalizerUtil.readField(parentNode, "LOG_ENABLED")));
    }
    catch (Exception ignored) {
    }
    try {
      String logMessage = JDOMExternalizerUtil.readField(parentNode, LOG_MESSAGE_OPTION_NAME);
      if (logMessage != null && !logMessage.isEmpty()) {
        XExpressionImpl expression = XExpressionImpl.fromText(logMessage);
        XDebuggerHistoryManager.getInstance(myProject).addRecentExpression(XBreakpointActionsPanel.LOG_EXPRESSION_HISTORY_ID, expression);
        myXBreakpoint.setLogExpressionObject(expression);
        ((XBreakpointBase<?, ?, ?>)myXBreakpoint).setLogExpressionEnabled(Boolean.parseBoolean(JDOMExternalizerUtil.readField(parentNode, "LOG_EXPRESSION_ENABLED")));
      }
    }
    catch (Exception ignored) {
    }
    try {
      setRemoveAfterHit(Boolean.parseBoolean(JDOMExternalizerUtil.readField(parentNode, "REMOVE_AFTER_HIT")));
    }
    catch (Exception ignored) {
    }
  }

  @Nullable
  public abstract PsiElement getEvaluationElement();

  protected TextWithImports getLogMessage() {
    return TextWithImportsImpl.fromXExpression(myXBreakpoint.getLogExpressionObject());
  }

  protected TextWithImports getCondition() {
    return TextWithImportsImpl.fromXExpression(myXBreakpoint.getConditionExpression());
  }

  @Override
  public boolean isEnabled() {
    return myXBreakpoint.isEnabled();
  }

  @Override
  public void setEnabled(boolean enabled) {
    myXBreakpoint.setEnabled(enabled);
  }

  protected boolean isLogEnabled() {
    return myXBreakpoint.isLogMessage();
  }

  public void setLogEnabled(boolean logEnabled) {
    myXBreakpoint.setLogMessage(logEnabled);
  }

  protected boolean isLogStack() {
    return myXBreakpoint.isLogStack();
  }

  protected boolean isLogExpressionEnabled() {
    if (XDebuggerUtilImpl.isEmptyExpression(myXBreakpoint.getLogExpressionObject())) {
      return false;
    }
    return !getLogMessage().isEmpty();
  }

  @Override
  public boolean isCountFilterEnabled() {
    return getProperties().isCOUNT_FILTER_ENABLED() && getCountFilter() > 0;
  }

  public void setCountFilterEnabled(boolean enabled) {
    if (getProperties().setCOUNT_FILTER_ENABLED(enabled)) {
      fireBreakpointChanged();
    }
  }

  @Override
  public int getCountFilter() {
    return getProperties().getCOUNT_FILTER();
  }

  public void setCountFilter(int filter) {
    if (getProperties().setCOUNT_FILTER(filter)) {
      fireBreakpointChanged();
    }
  }

  @Override
  public boolean isClassFiltersEnabled() {
    return getProperties().isCLASS_FILTERS_ENABLED();
  }

  public void setClassFiltersEnabled(boolean enabled) {
    if (getProperties().setCLASS_FILTERS_ENABLED(enabled)) {
      fireBreakpointChanged();
    }
  }

  @Override
  public ClassFilter[] getClassFilters() {
    return getProperties().getClassFilters();
  }

  public void setClassFilters(ClassFilter[] filters) {
    if (getProperties().setClassFilters(filters)) {
      fireBreakpointChanged();
    }
  }

  @Override
  public ClassFilter[] getClassExclusionFilters() {
    return getProperties().getClassExclusionFilters();
  }

  public void setClassExclusionFilters(ClassFilter[] filters) {
    if (getProperties().setClassExclusionFilters(filters)) {
      fireBreakpointChanged();
    }
  }

  @Override
  public boolean isInstanceFiltersEnabled() {
    return getProperties().isINSTANCE_FILTERS_ENABLED();
  }

  public void setInstanceFiltersEnabled(boolean enabled) {
    if (getProperties().setINSTANCE_FILTERS_ENABLED(enabled)) {
      fireBreakpointChanged();
    }
  }

  @Override
  public InstanceFilter[] getInstanceFilters() {
    return getProperties().getInstanceFilters();
  }

  public void setInstanceFilters(InstanceFilter[] filters) {
    if (getProperties().setInstanceFilters(filters)) {
      fireBreakpointChanged();
    }
  }

  private static String getSuspendPolicy(XBreakpoint<?> breakpoint) {
    return switch (breakpoint.getSuspendPolicy()) {
      case ALL -> DebuggerSettings.SUSPEND_ALL;
      case THREAD -> DebuggerSettings.SUSPEND_THREAD;
      case NONE -> DebuggerSettings.SUSPEND_NONE;
    };
  }

  static SuspendPolicy transformSuspendPolicy(String policy) {
    if (DebuggerSettings.SUSPEND_ALL.equals(policy)) {
      return SuspendPolicy.ALL;
    }
    else if (DebuggerSettings.SUSPEND_THREAD.equals(policy)) {
      return SuspendPolicy.THREAD;
    }
    else if (DebuggerSettings.SUSPEND_NONE.equals(policy)) {
      return SuspendPolicy.NONE;
    }
    else {
      throw new IllegalArgumentException("unknown suspend policy");
    }
  }

  protected boolean isSuspend() {
    return myXBreakpoint.getSuspendPolicy() != SuspendPolicy.NONE;
  }

  @Override
  public String getSuspendPolicy() {
    return getSuspendPolicy(myXBreakpoint);
  }

  public void setSuspendPolicy(String policy) {
    myXBreakpoint.setSuspendPolicy(transformSuspendPolicy(policy));
  }

  @Override
  public boolean isConditionEnabled() {
    XExpression condition = myXBreakpoint.getConditionExpression();
    if (XDebuggerUtilImpl.isEmptyExpression(condition)) {
      return false;
    }
    return !getCondition().isEmpty();
  }

  public void setCondition(@Nullable TextWithImports condition) {
    myXBreakpoint.setConditionExpression(TextWithImportsImpl.toXExpression(condition));
  }

  public void addInstanceFilter(long l) {
    getProperties().addInstanceFilter(l);
  }

  protected void fireBreakpointChanged() {
    ((XBreakpointBase<?, ?, ?>)myXBreakpoint).fireBreakpointChanged();
  }
}
/*
 * Copyright 2000-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.openapi.util.Key;
import org.jetbrains.annotations.NotNull;

import java.util.HashMap;
import java.util.Map;

/**
 * @author Eugene Zhuravlev
 */
public final class BreakpointCategory {
  private static final Map<String, Key> ourMap = new HashMap<>();

  private BreakpointCategory() {
  }

  @NotNull
  public static <T extends Breakpoint> Key<T> lookup(String name) {
    Key<T> key = ourMap.get(name);
    if (key == null) {
      key = Key.create(name);
      ourMap.put(name, key);
    }
    return key;
  }
}
/*
 * Copyright 2000-2012 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.settings.DebuggerSettings;
import org.jetbrains.annotations.NotNull;

/**
 * @author Eugene Zhuravlev
 */
public final class BreakpointDefaults {
  private String mySuspendPolicy = DebuggerSettings.SUSPEND_ALL;
  private boolean myIsConditionEnabled = true;

  public BreakpointDefaults() {
  }

  public BreakpointDefaults(String suspendPolicy, boolean conditionEnabled) {
    setSuspendPolicy(suspendPolicy);
    this.myIsConditionEnabled = conditionEnabled;
  }

  @NotNull
  public String getSuspendPolicy() {
    return mySuspendPolicy;
  }

  public void setSuspendPolicy(String suspendPolicy) {
    if (DebuggerSettings.SUSPEND_THREAD.equals(suspendPolicy) || DebuggerSettings.SUSPEND_ALL.equals(suspendPolicy)) {
      mySuspendPolicy = suspendPolicy;
    }
  }

  public boolean isConditionEnabled() {
    return myIsConditionEnabled;
  }

  public void setConditionEnabled(boolean isConditionEnabled) {
    myIsConditionEnabled = isConditionEnabled;
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints

import com.intellij.debugger.InstanceFilter
import com.intellij.debugger.JavaDebuggerBundle
import com.intellij.debugger.engine.JavaDebugProcess
import com.intellij.debugger.engine.JavaStackFrame
import com.intellij.openapi.actionSystem.ActionUpdateThread
import com.intellij.openapi.actionSystem.AnAction
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.util.Key
import com.intellij.openapi.util.NlsActions.ActionText
import com.intellij.openapi.util.text.StringUtil
import com.intellij.ui.classFilter.ClassFilter
import com.intellij.util.ArrayUtil
import com.intellij.xdebugger.XDebugSession
import com.intellij.xdebugger.breakpoints.XBreakpoint
import com.intellij.xdebugger.impl.breakpoints.XBreakpointBase
import org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties

internal abstract class BreakpointIntentionAction(protected val myBreakpoint: XBreakpoint<*>, @ActionText text: String) : AnAction(text) {

  override fun getActionUpdateThread(): ActionUpdateThread {
    return ActionUpdateThread.EDT
  }

  internal class AddCallerNotFilter(breakpoint: XBreakpoint<*>, private val myCaller: String) :
    BreakpointIntentionAction(breakpoint, JavaDebuggerBundle.message(
      "action.do.not.stop.if.called.from.text", StringUtil.getShortName(StringUtil.substringBefore(myCaller, "(") ?: myCaller))) {

    override fun update(e: AnActionEvent) {
      with(myBreakpoint.properties as JavaBreakpointProperties<*>) {
        e.presentation.setEnabled(!isCALLER_FILTERS_ENABLED || !callerExclusionFilters.contains(ClassFilter(myCaller)))
      }
    }

    override fun actionPerformed(e: AnActionEvent) {
      with(myBreakpoint.properties as JavaBreakpointProperties<*>) {
        isCALLER_FILTERS_ENABLED = true
        val callerFilter = ClassFilter(myCaller)
        callerFilters = ArrayUtil.remove(callerFilters, callerFilter)
        callerExclusionFilters = appendIfNeeded(callerExclusionFilters, callerFilter)
      }
      (myBreakpoint as XBreakpointBase<*, *, *>).fireBreakpointChanged()
    }
  }

  internal class AddCallerFilter(breakpoint: XBreakpoint<*>, private val myCaller: String) :
    BreakpointIntentionAction(breakpoint,
                              JavaDebuggerBundle.message("action.stop.only.if.called.from.text", StringUtil.getShortName(StringUtil.substringBefore(myCaller, "(") ?: myCaller))) {

    override fun update(e: AnActionEvent) {
      with(myBreakpoint.properties as JavaBreakpointProperties<*>) {
        e.presentation.setEnabled(!isCALLER_FILTERS_ENABLED || !callerFilters.contains(ClassFilter(myCaller)))
      }
    }

    override fun actionPerformed(e: AnActionEvent) {
      with(myBreakpoint.properties as JavaBreakpointProperties<*>) {
        isCALLER_FILTERS_ENABLED = true
        val callerFilter = ClassFilter(myCaller)
        callerFilters = appendIfNeeded(callerFilters, callerFilter)
        callerExclusionFilters = ArrayUtil.remove(callerExclusionFilters, callerFilter)
      }
      (myBreakpoint as XBreakpointBase<*, *, *>).fireBreakpointChanged()
    }
  }

  internal class AddInstanceFilter(breakpoint: XBreakpoint<*>, private val myInstance: Long) :
    BreakpointIntentionAction(breakpoint, JavaDebuggerBundle.message("action.stop.only.in.current.object.text")) {

    override fun update(e: AnActionEvent) {
      with(myBreakpoint.properties as JavaBreakpointProperties<*>) {
        e.presentation.setEnabled(!isINSTANCE_FILTERS_ENABLED || !instanceFilters.contains(InstanceFilter.create(myInstance)))
      }
    }

    override fun actionPerformed(e: AnActionEvent) {
      with(myBreakpoint.properties as JavaBreakpointProperties<*>) {
        isINSTANCE_FILTERS_ENABLED = true
        instanceFilters = appendIfNeeded(instanceFilters, InstanceFilter.create(myInstance))
      }
      (myBreakpoint as XBreakpointBase<*, *, *>).fireBreakpointChanged()
    }
  }

  internal class AddClassFilter(breakpoint: XBreakpoint<*>, private val myClass: String) :
    BreakpointIntentionAction(breakpoint, JavaDebuggerBundle.message("action.stop.only.in.class.text", StringUtil.getShortName(myClass))) {

    override fun update(e: AnActionEvent) {
      with(myBreakpoint.properties as JavaBreakpointProperties<*>) {
        e.presentation.setEnabled(!isCLASS_FILTERS_ENABLED || !classFilters.contains(ClassFilter(myClass)))
      }
    }

    override fun actionPerformed(e: AnActionEvent) {
      with(myBreakpoint.properties as JavaBreakpointProperties<*>) {
        isCLASS_FILTERS_ENABLED = true
        val classFilter = ClassFilter(myClass)
        classFilters = appendIfNeeded(classFilters, classFilter)
        classExclusionFilters = ArrayUtil.remove(classExclusionFilters, classFilter)
      }
      (myBreakpoint as XBreakpointBase<*, *, *>).fireBreakpointChanged()
    }
  }

  internal class AddClassNotFilter(breakpoint: XBreakpoint<*>, private val myClass: String) :
    BreakpointIntentionAction(breakpoint, JavaDebuggerBundle.message("action.do.not.stop.in.class.text", StringUtil.getShortName(myClass))) {

    override fun update(e: AnActionEvent) {
      with(myBreakpoint.properties as JavaBreakpointProperties<*>) {
        e.presentation.setEnabled(!isCLASS_FILTERS_ENABLED || !classExclusionFilters.contains(ClassFilter(myClass)))
      }
    }

    override fun actionPerformed(e: AnActionEvent) {
      with(myBreakpoint.properties as JavaBreakpointProperties<*>) {
        isCLASS_FILTERS_ENABLED = true
        val classFilter = ClassFilter(myClass)
        classExclusionFilters = appendIfNeeded(classExclusionFilters, classFilter)
        classFilters = ArrayUtil.remove(classFilters, classFilter)
      }
      (myBreakpoint as XBreakpointBase<*, *, *>).fireBreakpointChanged()
    }
  }

  companion object {
    @JvmField
    val CALLER_KEY = Key.create<String>("CALLER_KEY")

    @JvmField
    val THIS_TYPE_KEY = Key.create<String>("THIS_TYPE_KEY")

    @JvmField
    val THIS_ID_KEY = Key.create<Long>("THIS_ID_KEY")

    @JvmStatic
    fun getIntentions(breakpoint: XBreakpoint<*>, currentSession: XDebugSession?): List<AnAction> {
      val process = currentSession?.debugProcess
      if (process is JavaDebugProcess) {
        val res = ArrayList<AnAction>()

        val currentStackFrame = currentSession.currentStackFrame
        if (currentStackFrame is JavaStackFrame) {
          val frameDescriptor = currentStackFrame.descriptor

          frameDescriptor.getUserData(THIS_TYPE_KEY)?.let {
            res.add(AddClassFilter(breakpoint, it))
            res.add(AddClassNotFilter(breakpoint, it))
          }

          frameDescriptor.getUserData(THIS_ID_KEY)?.let {
            res.add(AddInstanceFilter(breakpoint, it))
          }

          frameDescriptor.getUserData(CALLER_KEY)?.let {
            res.add(AddCallerFilter(breakpoint, it))
            res.add(AddCallerNotFilter(breakpoint, it))
          }
        }

        return res
      }
      return emptyList()
    }

    private fun <T> appendIfNeeded(array: Array<T>, element: T): Array<T> {
      return if (array.contains(element)) {
        array
      }
      else {
        ArrayUtil.append(array, element)
      }
    }
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

/*
 * Class BreakpointManager
 * @author Jeka
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.DebuggerInvocationUtil;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.BreakpointStepMethodFilter;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.requests.RequestManagerImpl;
import com.intellij.debugger.impl.*;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.application.WriteAction;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.editor.markup.GutterIconRenderer;
import com.intellij.openapi.editor.markup.RangeHighlighter;
import com.intellij.openapi.fileEditor.FileDocumentManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.startup.StartupManager;
import com.intellij.openapi.ui.MessageType;
import com.intellij.openapi.util.Comparing;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.JDOMUtil;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vfs.VirtualFileManager;
import com.intellij.psi.PsiField;
import com.intellij.util.concurrency.AppExecutorUtil;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.messages.MessageBusConnection;
import com.intellij.xdebugger.XDebuggerManager;
import com.intellij.xdebugger.XDebuggerUtil;
import com.intellij.xdebugger.XSourcePosition;
import com.intellij.xdebugger.breakpoints.*;
import com.intellij.xdebugger.impl.DebuggerSupport;
import com.intellij.xdebugger.impl.XDebuggerManagerImpl;
import com.intellij.xdebugger.impl.XDebuggerSupport;
import com.intellij.xdebugger.impl.breakpoints.XBreakpointBase;
import com.intellij.xdebugger.impl.breakpoints.XBreakpointManagerImpl;
import com.intellij.xdebugger.impl.breakpoints.XDependentBreakpointManager;
import com.intellij.xdebugger.impl.breakpoints.XLineBreakpointImpl;
import com.jetbrains.jdi.EventRequestManagerImpl;
import com.sun.jdi.InternalException;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.VMDisconnectedException;
import com.sun.jdi.request.EventRequest;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.InvalidRequestStateException;
import one.util.streamex.StreamEx;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaExceptionBreakpointProperties;
import org.jetbrains.java.debugger.breakpoints.properties.JavaLineBreakpointProperties;
import org.jetbrains.java.debugger.breakpoints.properties.JavaMethodBreakpointProperties;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.stream.Stream;

public class BreakpointManager {
  private static final Logger LOG = Logger.getInstance(BreakpointManager.class);

  @NonNls private static final String MASTER_BREAKPOINT_TAG_NAME = "master_breakpoint";
  @NonNls private static final String SLAVE_BREAKPOINT_TAG_NAME = "slave_breakpoint";
  @NonNls private static final String DEFAULT_SUSPEND_POLICY_ATTRIBUTE_NAME = "default_suspend_policy";
  @NonNls private static final String DEFAULT_CONDITION_STATE_ATTRIBUTE_NAME = "default_condition_enabled";

  @NonNls private static final String RULES_GROUP_NAME = "breakpoint_rules";
  private static final String CONVERTED_PARAM = "converted";

  private final Project myProject;
  private final Map<String, String> myUIProperties = new LinkedHashMap<>();

  public BreakpointManager(@NotNull Project project, @NotNull DebuggerManagerImpl debuggerManager) {
    myProject = project;
    debuggerManager.getContextManager().addListener(new DebuggerContextListener() {
      private DebuggerSession myPreviousSession;

      @Override
      public void changeEvent(@NotNull DebuggerContextImpl newContext, DebuggerSession.Event event) {
        if (event == DebuggerSession.Event.ATTACHED) {
          for (XBreakpoint breakpoint : getXBreakpointManager().getAllBreakpoints()) {
            if (checkAndNotifyPossiblySlowBreakpoint(breakpoint)) break;
          }
        }
        if (newContext.getDebuggerSession() != myPreviousSession || event == DebuggerSession.Event.DETACHED) {
          updateBreakpointsUI();
          myPreviousSession = newContext.getDebuggerSession();
        }
      }
    });
  }

  private static boolean checkAndNotifyPossiblySlowBreakpoint(XBreakpoint breakpoint) {
    XBreakpointProperties properties = breakpoint.getProperties();
    if (breakpoint.isEnabled() && properties instanceof JavaMethodBreakpointProperties javaProperties && !javaProperties.EMULATED) {
      XDebuggerManagerImpl.getNotificationGroup()
        .createNotification(JavaDebuggerBundle.message("method.breakpoints.slowness.warning"), MessageType.WARNING)
        .notify(((XBreakpointBase<?, ?, ?>)breakpoint).getProject());
      return true;
    }
    return false;
  }

  public void addListeners(@NotNull MessageBusConnection busConnection) {
    busConnection.subscribe(XBreakpointListener.TOPIC, new XBreakpointListener<>() {
      @Override
      public void breakpointAdded(@NotNull XBreakpoint<?> xBreakpoint) {
        Breakpoint<?> breakpoint = getJavaBreakpoint(xBreakpoint);
        if (breakpoint != null) {
          addBreakpoint(breakpoint);
          JavaBreakpointsUsageCollector.reportNewBreakpoint(breakpoint, xBreakpoint.getType());
        }
      }

      @Override
      public void breakpointChanged(@NotNull XBreakpoint xBreakpoint) {
        Breakpoint<?> breakpoint = getJavaBreakpoint(xBreakpoint);
        if (breakpoint != null) {
          fireBreakpointChanged(breakpoint);
        }
      }
    });
  }

  private XBreakpointManager getXBreakpointManager() {
    return XDebuggerManager.getInstance(myProject).getBreakpointManager();
  }

  public void editBreakpoint(final Breakpoint breakpoint, final Editor editor) {
    DebuggerInvocationUtil.swingInvokeLater(myProject, () -> {
      XBreakpoint xBreakpoint = breakpoint.myXBreakpoint;
      if (xBreakpoint instanceof XLineBreakpointImpl) {
        RangeHighlighter highlighter = ((XLineBreakpointImpl<?>)xBreakpoint).getHighlighter();
        if (highlighter != null) {
          GutterIconRenderer renderer = highlighter.getGutterIconRenderer();
          if (renderer != null) {
            DebuggerSupport.getDebuggerSupport(XDebuggerSupport.class).getEditBreakpointAction().editBreakpoint(
              myProject, editor, breakpoint.myXBreakpoint, renderer
            );
          }
        }
      }
    });
  }

  public void setBreakpointDefaults(Key<? extends Breakpoint> category, BreakpointDefaults defaults) {
    Class<? extends XBreakpointType> typeCls = null;
    if (LineBreakpoint.CATEGORY.toString().equals(category.toString())) {
      typeCls = JavaLineBreakpointType.class;
    }
    else if (MethodBreakpoint.CATEGORY.toString().equals(category.toString())) {
      typeCls = JavaMethodBreakpointType.class;
    }
    else if (FieldBreakpoint.CATEGORY.toString().equals(category.toString())) {
      typeCls = JavaFieldBreakpointType.class;
    }
    else if (ExceptionBreakpoint.CATEGORY.toString().equals(category.toString())) {
      typeCls = JavaExceptionBreakpointType.class;
    }
    else if (CollectionBreakpoint.CATEGORY.toString().equals(category.toString())) {
      typeCls = JavaCollectionBreakpointType.class;
    }
    if (typeCls != null) {
      XBreakpointType type = XDebuggerUtil.getInstance().findBreakpointType(typeCls);
      ((XBreakpointManagerImpl)getXBreakpointManager()).getBreakpointDefaults(type).setSuspendPolicy(Breakpoint.transformSuspendPolicy(defaults.getSuspendPolicy()));
    }
  }

  @Nullable
  public RunToCursorBreakpoint addRunToCursorBreakpoint(@NotNull XSourcePosition position, final boolean ignoreBreakpoints) {
    return RunToCursorBreakpoint.create(myProject, position, ignoreBreakpoints);
  }

  @Nullable
  public StepIntoBreakpoint addStepIntoBreakpoint(@NotNull BreakpointStepMethodFilter filter) {
    return StepIntoBreakpoint.create(myProject, filter);
  }

  @Nullable
  public LineBreakpoint<?> addLineBreakpoint(Document document, int lineIndex, Consumer<JavaLineBreakpointProperties> setupAction) {
    ApplicationManager.getApplication().assertIsDispatchThread();
    if (!LineBreakpoint.canAddLineBreakpoint(myProject, document, lineIndex)) {
      return null;
    }
    var xLineBreakpoint = addXLineBreakpoint(JavaLineBreakpointType.class, document, lineIndex,
                                             p -> setupAction.accept(((JavaLineBreakpointProperties)p)));
    var breakpoint = getJavaBreakpoint(xLineBreakpoint);
    if (breakpoint instanceof LineBreakpoint<?> lineBreakpoint) {
      addBreakpoint(breakpoint);
      return lineBreakpoint;
    }
    return null;
  }

  @Nullable
  public LineBreakpoint<?> addLineBreakpoint(Document document, int lineIndex) {
    return addLineBreakpoint(document, lineIndex, p -> {});
  }

  @Nullable
  public FieldBreakpoint addFieldBreakpoint(@NotNull Document document, int offset) {
    PsiField field = FieldBreakpoint.findField(myProject, document, offset);
    if (field == null) {
      return null;
    }

    int line = document.getLineNumber(offset);

    if (document.getLineNumber(field.getNameIdentifier().getTextOffset()) < line) {
      return null;
    }

    return addFieldBreakpoint(document, line, field.getName());
  }

  @Nullable
  public FieldBreakpoint addFieldBreakpoint(Document document, int lineIndex, String fieldName) {
    ApplicationManager.getApplication().assertIsDispatchThread();
    XLineBreakpoint xBreakpoint = addXLineBreakpoint(JavaFieldBreakpointType.class, document, lineIndex);
    Breakpoint javaBreakpoint = getJavaBreakpoint(xBreakpoint);
    if (javaBreakpoint instanceof FieldBreakpoint fieldBreakpoint) {
      fieldBreakpoint.setFieldName(fieldName);
      addBreakpoint(javaBreakpoint);
      return fieldBreakpoint;
    }
    return null;
  }

  @Nullable
  public ExceptionBreakpoint addExceptionBreakpoint(@NotNull final String exceptionClassName, final String packageName) {
    ApplicationManager.getApplication().assertIsDispatchThread();
    final JavaExceptionBreakpointType type = XDebuggerUtil.getInstance().findBreakpointType(JavaExceptionBreakpointType.class);
    return WriteAction.compute(() -> {
      XBreakpoint<JavaExceptionBreakpointProperties> xBreakpoint = XDebuggerManager.getInstance(myProject).getBreakpointManager()
        .addBreakpoint(type, new JavaExceptionBreakpointProperties(exceptionClassName, packageName));
      if (getJavaBreakpoint(xBreakpoint) instanceof ExceptionBreakpoint exceptionBreakpoint) {
        exceptionBreakpoint.setQualifiedName(exceptionClassName);
        exceptionBreakpoint.setPackageName(packageName);
        addBreakpoint(exceptionBreakpoint);
        LOG.debug("ExceptionBreakpoint Added");
        return exceptionBreakpoint;
      }
      return null;
    });
  }

  @Nullable
  public MethodBreakpoint addMethodBreakpoint(Document document, int lineIndex) {
    ApplicationManager.getApplication().assertIsDispatchThread();

    XLineBreakpoint xBreakpoint = addXLineBreakpoint(JavaMethodBreakpointType.class, document, lineIndex);
    if (getJavaBreakpoint(xBreakpoint) instanceof MethodBreakpoint methodBreakpoint) {
      addBreakpoint(methodBreakpoint);
      return methodBreakpoint;
    }
    return null;
  }

  private <B extends XBreakpoint<?>> XLineBreakpoint addXLineBreakpoint(Class<? extends XBreakpointType<B, ?>> typeCls, Document document, final int lineIndex, Consumer<XBreakpointProperties> propertiesSetup) {
    final XBreakpointType<B, ?> type = XDebuggerUtil.getInstance().findBreakpointType(typeCls);
    final VirtualFile file = FileDocumentManager.getInstance().getFile(document);
    return WriteAction.compute(() -> {
      var properties = ((XLineBreakpointType<?>)type).createBreakpointProperties(file, lineIndex);
      propertiesSetup.accept(properties);
      return XDebuggerManager.getInstance(myProject).getBreakpointManager()
        .addLineBreakpoint((XLineBreakpointType)type, file.getUrl(), lineIndex, properties);
    });
  }

  private <B extends XBreakpoint<?>> XLineBreakpoint addXLineBreakpoint(Class<? extends XBreakpointType<B, ?>> typeCls, Document document, final int lineIndex) {
    return addXLineBreakpoint(typeCls, document, lineIndex, p -> {});
  }

  /**
   * @param category breakpoint category, null if the category does not matter
   */
  @Nullable
  public <T extends BreakpointWithHighlighter> T findBreakpoint(final Document document, final int offset, @Nullable final Key<T> category) {
    for (final Breakpoint breakpoint : getBreakpoints()) {
      if (breakpoint instanceof BreakpointWithHighlighter && ((BreakpointWithHighlighter<?>)breakpoint).isAt(document, offset)) {
        if (category == null || category.equals(breakpoint.getCategory())) {
          // noinspection unchecked
          return (T)breakpoint;
        }
      }
    }
    return null;
  }

  private final Map<String, Element> myOriginalBreakpointsNodes = new LinkedHashMap<>();

  public void readExternal(@NotNull final Element parentNode) {
    myOriginalBreakpointsNodes.clear();
    // save old breakpoints
    for (Element element : parentNode.getChildren()) {
      myOriginalBreakpointsNodes.put(element.getName(), JDOMUtil.internElement(element));
    }
    if (!myProject.isDefault()) {
      StartupManager.getInstance(myProject).runWhenProjectIsInitialized(() -> doRead(parentNode));
    }
  }

  private void doRead(@NotNull final Element parentNode) {
    ApplicationManager.getApplication().runReadAction(() -> {
      final Map<String, Breakpoint> nameToBreakpointMap = new HashMap<>();
      try {
        final List groups = parentNode.getChildren();
        for (final Object group1 : groups) {
          final Element group = (Element)group1;
          if (group.getName().equals(RULES_GROUP_NAME)) {
            continue;
          }
          // skip already converted
          if (group.getAttribute(CONVERTED_PARAM) != null) {
            continue;
          }
          final String categoryName = group.getName();
          final Key<Breakpoint> breakpointCategory = BreakpointCategory.lookup(categoryName);
          final String defaultPolicy = group.getAttributeValue(DEFAULT_SUSPEND_POLICY_ATTRIBUTE_NAME);
          final boolean conditionEnabled = Boolean.parseBoolean(group.getAttributeValue(DEFAULT_CONDITION_STATE_ATTRIBUTE_NAME, "true"));
          setBreakpointDefaults(breakpointCategory, new BreakpointDefaults(defaultPolicy, conditionEnabled));
          Element anyExceptionBreakpointGroup;
          if (!AnyExceptionBreakpoint.ANY_EXCEPTION_BREAKPOINT.equals(breakpointCategory)) {
            // for compatibility with previous format
            anyExceptionBreakpointGroup = group.getChild(AnyExceptionBreakpoint.ANY_EXCEPTION_BREAKPOINT.toString());
            //final BreakpointFactory factory = BreakpointFactory.getInstance(breakpointCategory);
            //if (factory != null) {
              for (Element breakpointNode : group.getChildren("breakpoint")) {
                //Breakpoint breakpoint = factory.createBreakpoint(myProject, breakpointNode);
                Breakpoint breakpoint = createBreakpoint(categoryName, breakpointNode);
                breakpoint.readExternal(breakpointNode);
                nameToBreakpointMap.put(breakpoint.getDisplayName(), breakpoint);
              }
            //}
          }
          else {
            anyExceptionBreakpointGroup = group;
          }

          if (anyExceptionBreakpointGroup != null) {
            final Element breakpointElement = group.getChild("breakpoint");
            if (breakpointElement != null) {
              XBreakpointManager manager = XDebuggerManager.getInstance(myProject).getBreakpointManager();
              JavaExceptionBreakpointType type = XDebuggerUtil.getInstance().findBreakpointType(JavaExceptionBreakpointType.class);
              for (XBreakpoint<JavaExceptionBreakpointProperties> defaultBreakpoint : manager.getDefaultBreakpoints(type)) {
                Breakpoint breakpoint = getJavaBreakpoint(defaultBreakpoint);
                if (breakpoint != null) {
                  breakpoint.readExternal(breakpointElement);
                  addBreakpoint(breakpoint);
                }
              }
            }
          }
        }
      }
      catch (InvalidDataException ignored) {
      }

      final Element rulesGroup = parentNode.getChild(RULES_GROUP_NAME);
      if (rulesGroup != null) {
        final List<Element> rules = rulesGroup.getChildren("rule");
        for (Element rule : rules) {
          // skip already converted
          if (rule.getAttribute(CONVERTED_PARAM) != null) {
            continue;
          }
          final Element master = rule.getChild(MASTER_BREAKPOINT_TAG_NAME);
          if (master == null) {
            continue;
          }
          final Element slave = rule.getChild(SLAVE_BREAKPOINT_TAG_NAME);
          if (slave == null) {
            continue;
          }
          final Breakpoint masterBreakpoint = nameToBreakpointMap.get(master.getAttributeValue("name"));
          if (masterBreakpoint == null) {
            continue;
          }
          final Breakpoint slaveBreakpoint = nameToBreakpointMap.get(slave.getAttributeValue("name"));
          if (slaveBreakpoint == null) {
            continue;
          }

          boolean leaveEnabled = Boolean.parseBoolean(rule.getAttributeValue("leaveEnabled"));
          XDependentBreakpointManager dependentBreakpointManager = ((XBreakpointManagerImpl)getXBreakpointManager()).getDependentBreakpointManager();
          dependentBreakpointManager.setMasterBreakpoint(slaveBreakpoint.myXBreakpoint, masterBreakpoint.myXBreakpoint, leaveEnabled);
          //addBreakpointRule(new EnableBreakpointRule(BreakpointManager.this, masterBreakpoint, slaveBreakpoint, leaveEnabled));
        }
      }

      updateBreakpointsUI();
    });

    myUIProperties.clear();
    final Element props = parentNode.getChild("ui_properties");
    if (props != null) {
      final List children = props.getChildren("property");
      for (Object child : children) {
        Element property = (Element)child;
        final String name = property.getAttributeValue("name");
        final String value = property.getAttributeValue("value");
        if (name != null && value != null) {
          myUIProperties.put(name, value);
        }
      }
    }
  }

  private Breakpoint createBreakpoint(String category, Element breakpointNode) throws InvalidDataException {
    XBreakpoint xBreakpoint = null;
    if (category.equals(LineBreakpoint.CATEGORY.toString())) {
      xBreakpoint = createXLineBreakpoint(JavaLineBreakpointType.class, breakpointNode);
    }
    else if (category.equals(MethodBreakpoint.CATEGORY.toString())) {
      if (breakpointNode.getAttribute("url") != null) {
        xBreakpoint = createXLineBreakpoint(JavaMethodBreakpointType.class, breakpointNode);
      }
      else {
        xBreakpoint = createXBreakpoint(JavaWildcardMethodBreakpointType.class);
      }
    }
    else if (category.equals(FieldBreakpoint.CATEGORY.toString())) {
      xBreakpoint = createXLineBreakpoint(JavaFieldBreakpointType.class, breakpointNode);
    }
    else if (category.equals(ExceptionBreakpoint.CATEGORY.toString())) {
      xBreakpoint = createXBreakpoint(JavaExceptionBreakpointType.class);
    }
    else if (category.equals(CollectionBreakpoint.CATEGORY.toString())) {
      xBreakpoint = createXBreakpoint(JavaCollectionBreakpointType.class);
    }
    if (xBreakpoint == null) {
      throw new IllegalStateException("Unknown breakpoint category " + category);
    }
    return getJavaBreakpoint(xBreakpoint);
  }

  private <B extends XBreakpoint<?>> XBreakpoint createXBreakpoint(Class<? extends XBreakpointType<B, ?>> typeCls) {
    final XBreakpointType<B, ?> type = XDebuggerUtil.getInstance().findBreakpointType(typeCls);
    return WriteAction.compute(() -> XDebuggerManager.getInstance(myProject).getBreakpointManager().addBreakpoint((XBreakpointType)type, type.createProperties()));
  }

  private <B extends XBreakpoint<?>> XLineBreakpoint createXLineBreakpoint(Class<? extends XBreakpointType<B, ?>> typeCls,
                                                                           Element breakpointNode) throws InvalidDataException {
    final String url = breakpointNode.getAttributeValue("url");
    VirtualFile vFile = VirtualFileManager.getInstance().findFileByUrl(url);
    if (vFile == null) {
      throw new InvalidDataException(JavaDebuggerBundle.message("error.breakpoint.file.not.found", url));
    }
    final Document doc = FileDocumentManager.getInstance().getDocument(vFile);
    if (doc == null) {
      throw new InvalidDataException(JavaDebuggerBundle.message("error.cannot.load.breakpoint.file", url));
    }

    final int line;
    try {
      line = Integer.parseInt(breakpointNode.getAttributeValue("line"));
    }
    catch (Exception e) {
      throw new InvalidDataException("Line number is invalid for breakpoint");
    }
    return addXLineBreakpoint(typeCls, doc, line);
  }

  public static void addBreakpoint(@NotNull Breakpoint breakpoint) {
    assert breakpoint.myXBreakpoint.getUserData(Breakpoint.DATA_KEY) == breakpoint;
    breakpoint.updateUI();
    checkAndNotifyPossiblySlowBreakpoint(breakpoint.myXBreakpoint);
  }

  public void removeBreakpoint(@Nullable final Breakpoint breakpoint) {
    if (breakpoint == null) {
      return;
    }
    WriteAction.run(() -> getXBreakpointManager().removeBreakpoint(breakpoint.myXBreakpoint));
  }

  public void writeExternal(@NotNull final Element parentNode) {
    // restore old breakpoints
    for (Element group : myOriginalBreakpointsNodes.values()) {
      Element clone = group.clone();
      if (clone.getAttribute(CONVERTED_PARAM) == null) {
        clone.setAttribute(CONVERTED_PARAM, "true");
      }
      parentNode.addContent(clone);
    }
  }

  @NotNull
  public List<Breakpoint> getBreakpoints() {
    return ReadAction.compute(() ->
      ContainerUtil.mapNotNull(getXBreakpointManager().getAllBreakpoints(), BreakpointManager::getJavaBreakpoint));
  }

  @Nullable
  public static Breakpoint<?> getJavaBreakpoint(@Nullable final XBreakpoint<?> xBreakpoint) {
    if (xBreakpoint == null) {
      return null;
    }
    Breakpoint<?> breakpoint = xBreakpoint.getUserData(Breakpoint.DATA_KEY);
    if (breakpoint == null && xBreakpoint.getType() instanceof JavaBreakpointType) {
      Project project = ((XBreakpointBase<?, ?, ?>)xBreakpoint).getProject();
      try {
        breakpoint = ((JavaBreakpointType)xBreakpoint.getType()).createJavaBreakpoint(project, xBreakpoint);
      }
      catch (Throwable e) {
        DebuggerUtilsImpl.logError(e);
        return null;
      }
      xBreakpoint.putUserData(Breakpoint.DATA_KEY, breakpoint);
    }
    return breakpoint;
  }

  //interaction with RequestManagerImpl
  public void disableBreakpoints(@NotNull final DebugProcessImpl debugProcess) {
    final List<Breakpoint> breakpoints = getBreakpoints();
    if (!breakpoints.isEmpty()) {
      final RequestManagerImpl requestManager = debugProcess.getRequestsManager();
      for (Breakpoint breakpoint : breakpoints) {
        breakpoint.markVerified(requestManager.isVerified(breakpoint));
        requestManager.deleteRequest(breakpoint);
      }
      updateBreakpointsUI();
    }
  }

  public void enableBreakpoints(final DebugProcessImpl debugProcess) {
    final List<Breakpoint> breakpoints = getBreakpoints();
    if (!breakpoints.isEmpty()) {
      for (Breakpoint breakpoint : breakpoints) {
        breakpoint.markVerified(false); // clean cached state
        breakpoint.createRequest(debugProcess);
      }
      updateBreakpointsUI();
    }
  }

  public void applyThreadFilter(@NotNull final DebugProcessImpl debugProcess, @Nullable ThreadReference newFilterThread) {
    final RequestManagerImpl requestManager = debugProcess.getRequestsManager();
    final ThreadReference oldFilterThread = requestManager.getFilterThread();
    if (Comparing.equal(newFilterThread, oldFilterThread)) {
      // the filter already added
      return;
    }
    requestManager.setFilterThread(newFilterThread);

    if (!DebuggerSession.filterBreakpointsDuringSteppingUsingDebuggerEngine()) {
      return;
    }

    EventRequestManager eventRequestManager = requestManager.getVMRequestManager();
    if (DebuggerUtilsAsync.isAsyncEnabled() && eventRequestManager instanceof EventRequestManagerImpl) {
      Stream<EventRequestManagerImpl.ThreadVisibleEventRequestImpl> requests =
        StreamEx.<EventRequest>of(eventRequestManager.breakpointRequests())
          .append(eventRequestManager.methodEntryRequests())
          .append(eventRequestManager.methodExitRequests())
          .select(EventRequestManagerImpl.ThreadVisibleEventRequestImpl.class);
      try {
        Stream<CompletableFuture> futures = requests
          .map(r -> newFilterThread != null ? r.addThreadFilterAsync(newFilterThread) : r.removeThreadFilterAsync(oldFilterThread));
        CompletableFuture.allOf(futures.toArray(CompletableFuture[]::new)).join();
      }
      catch (Exception e) {
        Throwable cause = DebuggerUtilsAsync.unwrap(e);
        if (cause instanceof VMDisconnectedException) {
          throw (VMDisconnectedException)cause;
        }
        LOG.error(new Exception(e));
      }
    }
    else if (newFilterThread == null || oldFilterThread != null) {
      final List<Breakpoint> breakpoints = getBreakpoints();
      for (Breakpoint breakpoint : breakpoints) {
        if (LineBreakpoint.CATEGORY.equals(breakpoint.getCategory()) || MethodBreakpoint.CATEGORY.equals(breakpoint.getCategory())) {
          requestManager.deleteRequest(breakpoint);
          breakpoint.createRequest(debugProcess);
        }
      }
    }
    else {
      // important! need to add filter to _existing_ requests, otherwise Requestor->Request mapping will be lost
      // and debugger trees will not be restored to original state
      if (eventRequestManager != null) {
        applyFilter(eventRequestManager.breakpointRequests(), request -> request.addThreadFilter(newFilterThread));
        applyFilter(eventRequestManager.methodEntryRequests(), request -> request.addThreadFilter(newFilterThread));
        applyFilter(eventRequestManager.methodExitRequests(), request -> request.addThreadFilter(newFilterThread));
      }
    }
  }

  private static <T extends EventRequest> void applyFilter(@NotNull List<T> requests, Consumer<? super T> setter) {
    for (T request : requests) {
      try {
        // skip synthetic
        if (RequestManagerImpl.findRequestor(request) instanceof SyntheticLineBreakpoint) {
          continue;
        }
        boolean wasEnabled = request.isEnabled();
        if (wasEnabled) {
          request.disable();
        }
        setter.accept(request);
        if (wasEnabled) {
          request.enable();
        }
      }
      catch (InternalException | InvalidRequestStateException e) {
        LOG.info(e);
      }
    }
  }

  public void updateBreakpointsUI() {
    ReadAction.nonBlocking(this::getBreakpoints)
      .coalesceBy(this)
      .submit(AppExecutorUtil.getAppExecutorService())
      .onSuccess(b -> b.forEach(Breakpoint::updateUI));
  }

  public void reloadBreakpoints() {
    ReadAction.run(() -> DebuggerUtilsImpl.forEachSafe(getBreakpoints(), Breakpoint::reload));
  }

  public void fireBreakpointChanged(Breakpoint breakpoint) {
    breakpoint.reload();
    breakpoint.updateUI();
  }

  @Nullable
  public Breakpoint findMasterBreakpoint(@NotNull Breakpoint dependentBreakpoint) {
    XDependentBreakpointManager dependentBreakpointManager = ((XBreakpointManagerImpl)getXBreakpointManager()).getDependentBreakpointManager();
    return getJavaBreakpoint(dependentBreakpointManager.getMasterBreakpoint(dependentBreakpoint.myXBreakpoint));
  }

  public String getProperty(String name) {
    return myUIProperties.get(name);
  }

  public String setProperty(String name, String value) {
    return myUIProperties.put(name, value);
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.*;
import com.intellij.debugger.engine.*;
import com.intellij.debugger.engine.events.DebuggerCommandImpl;
import com.intellij.debugger.engine.requests.RequestManagerImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.fileEditor.FileDocumentManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiDocumentManager;
import com.intellij.psi.PsiFile;
import com.intellij.psi.jsp.JspFile;
import com.intellij.ui.classFilter.ClassFilter;
import com.intellij.xdebugger.XSourcePosition;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.XLineBreakpoint;
import com.intellij.xml.CommonXmlStrings;
import com.sun.jdi.Location;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.request.BreakpointRequest;
import org.jdom.Element;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties;

import javax.swing.*;

public abstract class BreakpointWithHighlighter<P extends JavaBreakpointProperties> extends Breakpoint<P> {
  private static final Logger LOG = Logger.getInstance(BreakpointWithHighlighter.class);

  @Nullable
  private SourcePosition mySourcePosition;

  private boolean myVisible = true;
  private volatile Icon myIcon = getSetIcon(false);
  @Nullable
  private String myClassName;
  @Nullable
  private String myPackageName;
  @Nullable
  private String myInvalidMessage;

  protected abstract void createRequestForPreparedClass(final DebugProcessImpl debugProcess, final ReferenceType classType);

  protected abstract Icon getDisabledIcon(boolean isMuted);

  protected Icon getInvalidIcon(boolean isMuted) {
    return AllIcons.Debugger.Db_invalid_breakpoint;
  }

  protected Icon getSetIcon(boolean isMuted) {
    return null;
  }

  protected abstract Icon getVerifiedIcon(boolean isMuted);

  protected abstract Icon getVerifiedWarningsIcon(boolean isMuted);

  @Override
  public Icon getIcon() {
    return myIcon;
  }

  @Nullable
  @Override
  public @NlsSafe String getClassName() {
    return myClassName;
  }

  @Override
  @Nullable
  public String getShortClassName() {
    final SourcePosition pos = getSourcePosition();
    if (pos != null) {
      if (pos.getFile() instanceof JspFile) {
        return getClassName();
      }
    }
    return super.getShortClassName();
  }

  @Nullable
  @Override
  public String getPackageName() {
    return myPackageName;
  }

  @Nullable
  public BreakpointWithHighlighter init() {
    if (!isValid()) {
      return null;
    }

    if (!ApplicationManager.getApplication().isUnitTestMode()) {
      updateUI();
    }

    return this;
  }

  private void updateCaches(@Nullable DebugProcessImpl debugProcess) {
    myIcon = calcIcon(debugProcess);
    if (isVisible() && isValid() && debugProcess != null && myXBreakpoint instanceof XLineBreakpoint) {
      JavaDebugProcess process = debugProcess.getXdebugProcess();
      if (process != null) {
        process.getSession().updateBreakpointPresentation(((XLineBreakpoint)myXBreakpoint), myIcon, myInvalidMessage);
      }
    }
    if (debugProcess != null && debugProcess.getVirtualMachineProxy().canBeModified() && !isObsolete()) {
      myClassName = JVMNameUtil.getSourcePositionClassDisplayName(debugProcess, getSourcePosition());
      myPackageName = JVMNameUtil.getSourcePositionPackageDisplayName(debugProcess, getSourcePosition());
    }
  }

  private Icon calcIcon(@Nullable DebugProcessImpl debugProcess) {
    final boolean muted = debugProcess != null && isMuted(debugProcess);
    if (!isEnabled()) {
      return getDisabledIcon(muted);
    }

    myInvalidMessage = "";

    if (!isValid()) {
      return getInvalidIcon(muted);
    }

    if (debugProcess == null) {
      return getSetIcon(muted);
    }

    final RequestManagerImpl requestsManager = debugProcess.getRequestsManager();

    final boolean isVerified = myCachedVerifiedState || requestsManager.isVerified(this);

    final String warning = requestsManager.getWarning(this);
    if (warning != null) {
      myInvalidMessage = warning;
      if (!isVerified) {
        return getInvalidIcon(muted);
      }
      return getVerifiedWarningsIcon(muted);
    }

    if (isVerified) {
      return getVerifiedIcon(muted);
    }

    return getValidatingIcon(muted);
  }

  protected Icon getValidatingIcon(boolean muted) {
    if (myXBreakpoint != null) {
      Icon icon = myXBreakpoint.getType().getPendingIcon();
      if (icon != null) {
        return icon;
      }
    }
    return getSetIcon(muted);
  }

  protected BreakpointWithHighlighter(@NotNull Project project, XBreakpoint xBreakpoint) {
    //for persistency
    super(project, xBreakpoint);
    ApplicationManager.getApplication().runReadAction(this::reload);
  }

  @Override
  public boolean isValid() {
    return isPositionValid(myXBreakpoint.getSourcePosition());
  }

  protected static boolean isPositionValid(@Nullable final XSourcePosition sourcePosition) {
    return ReadAction.compute(() -> sourcePosition != null && sourcePosition.getFile().isValid()).booleanValue();
  }

  @Nullable
  public SourcePosition getSourcePosition() {
    return mySourcePosition;
  }

  @NotNull
  @Nls
  public String getDescription() {
    final StringBuilder buf = new StringBuilder();
    buf.append(getDisplayName());

    if (isCountFilterEnabled()) {
      buf.append("&nbsp;<br>&nbsp;");
      buf.append(JavaDebuggerBundle.message("breakpoint.property.name.pass.count")).append(": ");
      buf.append(getCountFilter());
    }
    if (isClassFiltersEnabled()) {
      buf.append("&nbsp;<br>&nbsp;");
      buf.append(JavaDebuggerBundle.message("breakpoint.property.name.class.filters")).append(": ");
      ClassFilter[] classFilters = getClassFilters();
      for (ClassFilter classFilter : classFilters) {
        buf.append(classFilter.getPattern()).append(" ");
      }
    }
    if (isInstanceFiltersEnabled()) {
      buf.append("&nbsp;<br>&nbsp;");
      buf.append(JavaDebuggerBundle.message("breakpoint.property.name.instance.filters"));
      InstanceFilter[] instanceFilters = getInstanceFilters();
      for (InstanceFilter instanceFilter : instanceFilters) {
        buf.append(instanceFilter.getId()).append(" ");
      }
    }
    //noinspection HardCodedStringLiteral
    return buf.toString();
  }

  @Override
  public void reload() {
    ApplicationManager.getApplication().assertReadAccessAllowed();
    mySourcePosition = DebuggerUtilsEx.toSourcePosition(myXBreakpoint.getSourcePosition(), myProject);
  }

  @Nullable
  static BreakpointRequest createLocationBreakpointRequest(@NotNull FilteredRequestor requestor,
                                                           @Nullable Location location,
                                                           @NotNull DebugProcessImpl debugProcess) {
    if (location != null) {
      RequestManagerImpl requestsManager = debugProcess.getRequestsManager();
      BreakpointRequest request = requestsManager.createBreakpointRequest(requestor, location);
      requestsManager.enableRequest(request);
      return request;
    }
    return null;
  }

  @Override
  public void createRequest(@NotNull DebugProcessImpl debugProcess) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    // check is this breakpoint is enabled, vm reference is valid and there're no requests created yet
    if (!shouldCreateRequest(debugProcess)) {
      return;
    }

    if (!isValid()) {
      return;
    }

    SourcePosition position = getSourcePosition();
    if (position != null) {
      createOrWaitPrepare(debugProcess, position);
    }
    else {
      XSourcePosition xPosition = myXBreakpoint.getSourcePosition();
      LOG.error("Unable to create request for breakpoint with null position: " + this + " at " + xPosition +
                ", file valid = " + (xPosition != null && xPosition.getFile().isValid()));
    }
    updateUI();
  }

  protected boolean isMuted(@NotNull final DebugProcessImpl debugProcess) {
    return debugProcess.areBreakpointsMuted();
  }

  @Override
  public void processClassPrepare(DebugProcess debugProcess, ReferenceType classType) {
    DebugProcessImpl process = (DebugProcessImpl)debugProcess;
    if (shouldCreateRequest(process, true)) {
      createRequestForPreparedClass(process, classType);
      updateUI();
    }
  }

  /**
   * updates the state of breakpoint and all the related UI widgets etc
   */
  @Override
  public final void updateUI() {
    if (!isVisible() || ApplicationManager.getApplication().isUnitTestMode()) {
      return;
    }
    DebuggerInvocationUtil.swingInvokeLater(myProject, () -> {
      if (!isValid()) {
        return;
      }

      DebuggerContextImpl context = DebuggerManagerEx.getInstanceEx(myProject).getContext();
      DebugProcessImpl debugProcess = context.getDebugProcess();
      if (debugProcess == null || !debugProcess.isAttached()) {
        updateCaches(null);
      }
      else {
        debugProcess.getManagerThread().invoke(new DebuggerCommandImpl() {
          @Override
          protected void action() {
            if (!myProject.isDisposed()) {
              updateCaches(debugProcess);
            }
          }
        });
      }
    });
  }

  public boolean isAt(@NotNull Document document, int offset) {
    final VirtualFile file = FileDocumentManager.getInstance().getFile(document);
    int line = document.getLineNumber(offset);
    XSourcePosition position = myXBreakpoint.getSourcePosition();
    return position != null && position.getLine() == line && position.getFile().equals(file);
  }

  @Override
  public PsiClass getPsiClass() {
    final SourcePosition sourcePosition = getSourcePosition();
    return getPsiClassAt(sourcePosition);
  }

  protected static PsiClass getPsiClassAt(@Nullable final SourcePosition sourcePosition) {
    return ReadAction.compute(() -> JVMNameUtil.getClassAt(sourcePosition));
  }

  @Override
  public abstract Key<? extends BreakpointWithHighlighter> getCategory();

  protected boolean isVisible() {
    return myVisible;
  }

  public void setVisible(boolean visible) {
    myVisible = visible;
  }

  @Nullable
  public Document getDocument() {
    PsiFile file = DebuggerUtilsEx.getPsiFile(myXBreakpoint.getSourcePosition(), myProject);
    if (file != null) {
      return PsiDocumentManager.getInstance(myProject).getDocument(file);
    }
    return null;
  }

  public int getLineIndex() {
    XSourcePosition sourcePosition = myXBreakpoint.getSourcePosition();
    return sourcePosition != null ? sourcePosition.getLine() : -1;
  }

  protected String getFileName() {
    XSourcePosition sourcePosition = myXBreakpoint.getSourcePosition();
    return sourcePosition != null ? sourcePosition.getFile().getName() : "";
  }

  @Override
  public void readExternal(@NotNull Element breakpointNode) throws InvalidDataException {
    super.readExternal(breakpointNode);
    //final String url = breakpointNode.getAttributeValue("url");

    final String className = breakpointNode.getAttributeValue("class");
    if (className != null) {
      myClassName = className;
    }

    final String packageName = breakpointNode.getAttributeValue("package");
    if (packageName != null) {
      myPackageName = packageName;
    }
  }

  public String toString() {
    return ReadAction.compute(() -> CommonXmlStrings.HTML_START + CommonXmlStrings.BODY_START
                                    + getDescription()
                                    + CommonXmlStrings.BODY_END + CommonXmlStrings.HTML_END);
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.ui.PatternFilterEditor;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.project.Project;
import com.intellij.ui.classFilter.ClassFilterEditor;

public class CallerFiltersField extends ClassFiltersField {
  public CallerFiltersField(Project project, Disposable parent) {
    super(project, parent);
  }

  @Override
  protected EditClassFiltersDialog createEditDialog(Project project) {
    EditClassFiltersDialog dialog = new EditClassFiltersDialog(project) {
      @Override
      protected ClassFilterEditor createClassFilterEditor(Project project) {
        return new PatternFilterEditor(project);
      }
    };
    dialog.setTitle(JavaDebuggerBundle.message("caller.filters.dialog.title"));
    return dialog;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.*;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.impl.*;
import com.intellij.debugger.jdi.JvmtiError;
import com.intellij.debugger.jdi.StackFrameProxyImpl;
import com.intellij.debugger.jdi.ThreadReferenceProxyImpl;
import com.intellij.debugger.settings.TraceSettings;
import com.intellij.debugger.ui.overhead.OverheadProducer;
import com.intellij.debugger.ui.overhead.OverheadTimings;
import com.intellij.openapi.actionSystem.ActionUpdateThread;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.DumbAwareToggleAction;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.ui.SimpleColoredComponent;
import com.intellij.ui.classFilter.ClassFilter;
import com.sun.jdi.*;
import com.sun.jdi.event.Event;
import com.sun.jdi.event.MethodEntryEvent;
import com.sun.jdi.request.EventRequest;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.MethodEntryRequest;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class CallTracer implements OverheadProducer {
  private static final Logger LOG = Logger.getInstance(CallTracer.class);
  public static final Key<CallTracer> CALL_TRACER_KEY = Key.create("CALL_TRACER");

  private final EventRequestManager myRequestManager;
  private final DebugProcessImpl myDebugProcess;
  private final Map<ThreadReference, ThreadRequest> myThreadRequests = new ConcurrentHashMap<>();

  public CallTracer(DebugProcessImpl debugProcess) {
    myDebugProcess = debugProcess;
    myRequestManager = debugProcess.getRequestsManager().getVMRequestManager();
  }

  public void start(@Nullable ThreadReferenceProxyImpl thread) {
    try {
      if (thread != null) {
        start(thread.getThreadReference(), thread.frameCount());
      }
    }
    catch (EvaluateException e) {
      LOG.error(e);
    }
  }

  private void start(@NotNull ThreadReference thread, int startIndent) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    myThreadRequests.computeIfAbsent(thread, t -> new ThreadRequest(t, startIndent));
  }

  public void stop(@NotNull ThreadReference thread) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    ThreadRequest request = myThreadRequests.remove(thread);
    if (request != null) {
      request.stop();
    }
  }

  public void stopAll() {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    List<ThreadRequest> requests = new ArrayList<>(myThreadRequests.values());
    myThreadRequests.clear();
    requests.forEach(ThreadRequest::stop);
  }

  private void accept(Event event) {
    OverheadTimings.add(myDebugProcess, this, 1, null);
    if (event instanceof MethodEntryEvent methodEntryEvent) {
      try {
        ThreadReference thread = methodEntryEvent.thread();
        ThreadRequest request = myThreadRequests.get(thread);
        if (request != null) {
          for (SuspendContextImpl context : myDebugProcess.getSuspendManager().getEventContexts()) {
            ThreadReferenceProxyImpl contextThread = context.getThread();
            if (context.isEvaluating() && contextThread != null && contextThread.getThreadReference().equals(thread)) {
              return; // evaluating - skip
            }
          }
          int indent = thread.frameCount() - request.myStartIndent;
          String indentString = indent < 0 ? "-" : StringUtil.repeat(" ", indent);
          Method method = methodEntryEvent.method();
          StringBuilder res = new StringBuilder("\n");
          res.append(indentString).append(method.declaringType().name()).append('.').append(method.name()).append('(');
          if (Registry.is("debugger.call.tracing.arguments")) {
            try {
              boolean first = true;
              for (Value value : DebuggerUtilsEx.getArgumentValues(thread.frame(0))) {
                if (!first) {
                  res.append(", ");
                }
                first = false;
                if (value == null) {
                  res.append("null");
                }
                else if (value instanceof StringReference stringReference) {
                  res.append(stringReference.value());
                }
                else if (value instanceof ObjectReference objectReference) {
                  res.append(StringUtil.getShortName(objectReference.referenceType().name())).append("@")
                    .append(objectReference.uniqueID());
                }
                else {
                  res.append(value);
                }
              }
            }
            catch (InternalException e) {
              if (e.errorCode() != JvmtiError.INVALID_SLOT) { // ignore
                throw e;
              }
            }
            catch (InvalidStackFrameException ignored) {
            }
          }
          else {
            boolean first = true;
            for (String typeName : method.argumentTypeNames()) {
              if (!first) {
                res.append(", ");
              }
              first = false;
              res.append(StringUtil.getShortName(typeName));
            }
          }
          res.append(')').append(" thread ").append(thread.uniqueID());
          myDebugProcess.printToConsole(res.toString());
        }
      }
      catch (Exception e) {
        DebuggerUtilsImpl.logError(e);
      }
    }
  }

  @Override
  public boolean isEnabled() {
    return !myThreadRequests.isEmpty();
  }

  @Override
  public void setEnabled(boolean state) {
    myDebugProcess.getManagerThread().schedule(PrioritizedTask.Priority.HIGH, () -> {
      DebuggerContextImpl debuggerContext = myDebugProcess.getDebuggerContext();
      ThreadReferenceProxyImpl threadProxy = debuggerContext.getThreadProxy();
      if (state) {
        StackFrameProxyImpl frame = debuggerContext.getFrameProxy();
        if (frame != null && threadProxy != null) {
          start(threadProxy.getThreadReference(), frame.getIndexFromBottom());
        }
      }
      else {
        if (threadProxy != null) {
          stop(threadProxy.getThreadReference());
        }
        else {
          stopAll();
        }
      }
    });
  }

  @Override
  public void customizeRenderer(SimpleColoredComponent renderer) {
    renderer.append(JavaDebuggerBundle.message("call.tracer"));
  }

  @NotNull
  public static CallTracer get(DebugProcessImpl debugProcess) {
    CallTracer tracer = debugProcess.getUserData(CALL_TRACER_KEY);
    if (tracer == null) {
      tracer = new CallTracer(debugProcess);
      debugProcess.putUserData(CALL_TRACER_KEY, tracer);
    }
    return tracer;
  }

  private final class ThreadRequest {
    private final List<MethodEntryRequest> myEntryRequests = new ArrayList<>(1);
    private final int myStartIndent;

    private ThreadRequest(ThreadReference thread, int startIndent) {
      myStartIndent = startIndent;
      TraceSettings traceSettings = TraceSettings.getInstance();
      ClassFilter[] classFilters = traceSettings.getClassFilters();
      ClassFilter[] exclusionFilters = traceSettings.getClassExclusionFilters();
      if (DebuggerUtilsEx.getEnabledNumber(classFilters) == 0) {
        addEntryRequest(null, exclusionFilters, thread);
      }
      else {
        for (ClassFilter filter : classFilters) {
          if (filter.isEnabled()) {
            addEntryRequest(filter, exclusionFilters, thread);
          }
        }
      }
    }

    private void addEntryRequest(ClassFilter filter, ClassFilter[] exclusionFilters, ThreadReference thread) {
      MethodEntryRequest request = myRequestManager.createMethodEntryRequest();
      request.setSuspendPolicy(EventRequest.SUSPEND_EVENT_THREAD); // to be able to detect frameCount inside the event handler
      request.addThreadFilter(thread);
      myDebugProcess.getRequestsManager()
        .addClassFilters(request, filter != null ? new ClassFilter[]{filter} : ClassFilter.EMPTY_ARRAY, exclusionFilters);
      myEntryRequests.add(request);
      DebugProcessEvents.enableRequestWithHandler(request, CallTracer.this::accept);
    }

    void stop() {
      myEntryRequests.forEach(r -> DebuggerUtilsAsync.deleteEventRequest(myRequestManager, r));
    }
  }

  public static class CallTracerToggleAction extends DumbAwareToggleAction {
    @Override
    public void update(@NotNull AnActionEvent e) {
      e.getPresentation().setEnabledAndVisible(Registry.is("debugger.call.tracing"));
      super.update(e);
    }

    @Override
    public @NotNull ActionUpdateThread getActionUpdateThread() {
      return ActionUpdateThread.BGT;
    }

    @Override
    public boolean isSelected(@NotNull AnActionEvent e) {
      DebugProcessImpl process = JavaDebugProcess.getCurrentDebugProcess(e);
      if (process != null) {
        CallTracer tracer = process.getUserData(CALL_TRACER_KEY);
        if (tracer != null) {
          return tracer.isEnabled();
        }
      }
      return false;
    }

    @Override
    public void setSelected(@NotNull AnActionEvent e, boolean state) {
      DebugProcessImpl process = JavaDebugProcess.getCurrentDebugProcess(e);
      if (process != null) {
        get(process).setEnabled(state);
      }
    }
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.settings.TraceSettings;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.ui.IdeBorderFactory;
import com.intellij.ui.components.JBCheckBox;
import com.intellij.xdebugger.breakpoints.XLineBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import com.intellij.xdebugger.impl.breakpoints.XBreakpointBase;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.java.debugger.breakpoints.properties.JavaLineBreakpointProperties;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class CallTracingPropertiesPanel extends XBreakpointCustomPropertiesPanel<XLineBreakpoint<JavaLineBreakpointProperties>> {
  private final Project myProject;
  private JBCheckBox myStartTracing;
  private JBCheckBox myEndTracing;

  public CallTracingPropertiesPanel(Project project) {
    myProject = project;
  }

  @NotNull
  @Override
  public JComponent getComponent() {
    myStartTracing = new JBCheckBox(JavaDebuggerBundle.message("checkbox.start.tracing"));
    myEndTracing = new JBCheckBox(JavaDebuggerBundle.message("checkbox.stop.tracing"));
    JButton filters = new JButton(JavaDebuggerBundle.message("checkbox.tracking.filters"));
    //DialogUtil.registerMnemonic(myStartTracing);
    //DialogUtil.registerMnemonic(myEndTracing);

    JPanel _panel = new JPanel(new FlowLayout(FlowLayout.LEFT, 6, 0));
    _panel.add(myStartTracing);
    _panel.add(myEndTracing);
    _panel.add(filters);
    _panel.setBorder(IdeBorderFactory.createTitledBorder(JavaDebuggerBundle.message("checkbox.tracing")));

    ActionListener listener = new ActionListener() {
      @Override
      public void actionPerformed(ActionEvent e) {
        JCheckBox toUncheck = null;
        if (myStartTracing.isSelected() && myEndTracing.isSelected()) {
          Object source = e.getSource();
          if (myStartTracing.equals(source)) {
            toUncheck = myEndTracing;
          }
          else if (myEndTracing.equals(source)) {
            toUncheck = myStartTracing;
          }
          if (toUncheck != null) {
            toUncheck.setSelected(false);
          }
        }
      }
    };
    myStartTracing.addActionListener(listener);
    myEndTracing.addActionListener(listener);

    filters.addActionListener(e -> {
      EditClassFiltersDialog dialog = new EditClassFiltersDialog(myProject);
      TraceSettings traceSettings = TraceSettings.getInstance();
      dialog.setFilters(traceSettings.getClassFilters(), traceSettings.getClassExclusionFilters());
      dialog.setTitle(JavaDebuggerBundle.message("tracing.class.filters"));
      dialog.show();
      if (dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {
        traceSettings.setClassFilters(dialog.getFilters());
        traceSettings.setClassExclusionFilters(dialog.getExclusionFilters());
      }
    });

    return _panel;
  }

  @Override
  public void loadFrom(@NotNull XLineBreakpoint<JavaLineBreakpointProperties> breakpoint) {
    myStartTracing.setSelected(breakpoint.getProperties().isTRACING_START());
    myEndTracing.setSelected(breakpoint.getProperties().isTRACING_END());
  }

  @Override
  public void saveTo(@NotNull XLineBreakpoint<JavaLineBreakpointProperties> breakpoint) {
    boolean changed = breakpoint.getProperties().setTRACING_START(myStartTracing.isSelected());
    changed = breakpoint.getProperties().setTRACING_END(myEndTracing.isSelected()) || changed;
    if (changed) {
      ((XBreakpointBase<?, ?, ?>)breakpoint).fireBreakpointChanged();
    }
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.openapi.Disposable;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.openapi.ui.TextFieldWithBrowseButton;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.ui.classFilter.ClassFilter;
import one.util.streamex.StreamEx;

import java.util.ArrayList;
import java.util.Arrays;

public class ClassFiltersField extends TextFieldWithBrowseButton {
  private ClassFilter[] myClassFilters = ClassFilter.EMPTY_ARRAY;
  private ClassFilter[] myClassExclusionFilters = ClassFilter.EMPTY_ARRAY;

  public ClassFiltersField(Project project, Disposable parent) {
    super(null, parent);
    addActionListener(e -> {
                        reloadFilters();
                        EditClassFiltersDialog dialog = createEditDialog(project);
                        dialog.setFilters(myClassFilters, myClassExclusionFilters);
                        dialog.show();
                        if (dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {
                          myClassFilters = dialog.getFilters();
                          myClassExclusionFilters = dialog.getExclusionFilters();
                          updateEditor();
                        }
                      }
    );
  }

  protected EditClassFiltersDialog createEditDialog(Project project) {
    return new EditClassFiltersDialog(project);
  }

  public void setClassFilters(ClassFilter[] includeFilters, ClassFilter[] excludeFilters) {
    myClassFilters = includeFilters;
    myClassExclusionFilters = excludeFilters;
    updateEditor();
  }

  public ClassFilter[] getClassFilters() {
    reloadFilters();
    return myClassFilters;
  }

  public ClassFilter[] getClassExclusionFilters() {
    reloadFilters();
    return myClassExclusionFilters;
  }

  private void reloadFilters() {
    String filtersText = getText();

    ArrayList<ClassFilter> classFilters = new ArrayList<>();
    ArrayList<ClassFilter> exclusionFilters = new ArrayList<>();
    int startFilter = -1;
    for (int i = 0; i <= filtersText.length(); i++) {
      if (i < filtersText.length() && !Character.isWhitespace(filtersText.charAt(i))) {
        if (startFilter == -1) {
          startFilter = i;
        }
      }
      else {
        if (startFilter >= 0) {
          if (filtersText.charAt(startFilter) == '-') {
            exclusionFilters.add(new ClassFilter(filtersText.substring(startFilter + 1, i)));
          }
          else {
            classFilters.add(new ClassFilter(filtersText.substring(startFilter, i)));
          }
          startFilter = -1;
        }
      }
    }
    Arrays.stream(myClassFilters).filter(f -> !f.isEnabled()).forEach(classFilters::add);
    Arrays.stream(myClassExclusionFilters).filter(f -> !f.isEnabled()).forEach(classFilters::add);

    myClassFilters = classFilters.toArray(ClassFilter.EMPTY_ARRAY);
    myClassExclusionFilters = exclusionFilters.toArray(ClassFilter.EMPTY_ARRAY);
  }

  private void updateEditor() {
    setText(getFiltersPresentation());
  }

  private @NlsSafe String getFiltersPresentation() {
    return StreamEx.of(myClassExclusionFilters).filter(ClassFilter::isEnabled).map(f -> "-" + f.getPattern())
      .prepend(StreamEx.of(myClassFilters).filter(ClassFilter::isEnabled).map(ClassFilter::getPattern))
      .joining(" ");
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.breakpoints;


import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.CollectionBreakpointUtils;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.SuspendContextImpl;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.events.SuspendContextCommandImpl;
import com.intellij.debugger.engine.requests.RequestManagerImpl;
import com.intellij.debugger.impl.DebuggerUtilsImpl;
import com.intellij.debugger.impl.PositionUtil;
import com.intellij.debugger.jdi.StackFrameProxyImpl;
import com.intellij.debugger.jdi.ThreadReferenceProxyImpl;
import com.intellij.debugger.jdi.VirtualMachineProxyImpl;
import com.intellij.debugger.settings.DebuggerSettings;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Key;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiField;
import com.intellij.psi.PsiModifier;
import com.intellij.ui.LayeredIcon;
import com.intellij.util.SlowOperations;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.sun.jdi.*;
import com.sun.jdi.event.LocatableEvent;
import com.sun.jdi.event.ModificationWatchpointEvent;
import com.sun.jdi.request.ClassPrepareRequest;
import com.sun.jdi.request.MethodEntryRequest;
import com.sun.jdi.request.MethodExitRequest;
import com.sun.jdi.request.ModificationWatchpointRequest;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaCollectionBreakpointProperties;

import javax.swing.*;
import java.util.*;
import java.util.stream.Collectors;

@ApiStatus.Experimental
public class CollectionBreakpoint extends BreakpointWithHighlighter<JavaCollectionBreakpointProperties> {
  @NonNls public static final Key<CollectionBreakpoint> CATEGORY = BreakpointCategory.lookup("collection_breakpoints");

  private static final String GET_INTERNAL_CLS_NAME_METHOD_NAME = "getInternalClsName";
  private static final String GET_INTERNAL_CLS_NAME_METHOD_DESC = "(Ljava/lang/String;)Ljava/lang/String;";
  private static final String EMULATE_FIELD_WATCHPOINT_METHOD_NAME = "emulateFieldWatchpoint";
  private static final String EMULATE_FIELD_WATCHPOINT_METHOD_DESC = "([Ljava/lang/String;)V";
  private static final String PUT_FIELD_TO_CAPTURE_METHOD_NAME = "putFieldToCapture";
  private static final String PUT_FIELD_TO_CAPTURE_METHOD_DESC = "(Ljava/lang/String;Ljava/lang/String;)V";
  private static final String CAPTURE_FIELD_MODIFICATION_METHOD_NAME = "captureFieldModification";
  private static final String CAPTURE_FIELD_MODIFICATION_METHOD_DESC =
    "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;Z)V";
  private static final String CAPTURE_COLLECTION_MODIFICATION_DEFAULT_METHOD_NAME = "captureCollectionModification";
  private static final String CAPTURE_COLLECTION_MODIFICATION_DEFAULT_METHOD_DESC =
    "(Lcom/intellij/rt/debugger/agent/CollectionBreakpointInstrumentor$Multiset;Ljava/lang/Object;)V";
  private static final String CAPTURE_COLLECTION_MODIFICATION_SPECIAL_METHOD_NAME = "captureCollectionModification";
  private static final String CAPTURE_COLLECTION_MODIFICATION_SPECIAL_METHOD_DESC = "(ZZLjava/lang/Object;Ljava/lang/Object;Z)V";

  private static final long MAX_INSTANCES_NUMBER = 1000000;
  private final Set<String> myUnprocessedClasses = new HashSet<>();
  private final Set<String> myClassesNames = new HashSet<>();
  private volatile boolean myClsPrepared = false;
  private volatile boolean myIsStatic = false;
  private volatile boolean myIsPrivate = false;
  private volatile boolean myIsFinal = false;

  private volatile boolean myAllMethodsEntryRequestIsEnabled = false;
  private String myClsTypeDesc = null;


  protected CollectionBreakpoint(Project project, XBreakpoint breakpoint) {
    super(project, breakpoint);
    initProperties();
  }

  @Override
  public void reload() {
    super.reload();
    initProperties();
  }

  private void initProperties() {
    PsiField field = PositionUtil.getPsiElementAt(myProject, PsiField.class, getSourcePosition());
    if (field != null) {
      getProperties().myFieldName = field.getName();
      PsiClass psiClass = field.getContainingClass();
      if (psiClass != null) {
        getProperties().myClassName = psiClass.getQualifiedName();
      }
      myIsPrivate = SlowOperations.allowSlowOperations(() -> field.hasModifierProperty(PsiModifier.PRIVATE));
      myIsFinal = SlowOperations.allowSlowOperations(() -> field.hasModifierProperty(PsiModifier.FINAL));
      myIsStatic = SlowOperations.allowSlowOperations(() -> field.hasModifierProperty(PsiModifier.STATIC));
    }
    myClsPrepared = false;
    myAllMethodsEntryRequestIsEnabled = false;
  }

  @Override
  public void createRequestForPreparedClass(DebugProcessImpl debugProcess, ReferenceType refType) {
    if (myClsPrepared) {
      return;
    }
    setVariables(debugProcess);
    myClsTypeDesc = refType.signature();
    createRequestForClass(debugProcess, refType);
    if (!myIsFinal && !myIsPrivate) {
      createRequestForSubclasses(debugProcess, refType);
    }
    myClsPrepared = true;
  }

  @Override
  protected Icon getDisabledIcon(boolean isMuted) {
    if (DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().findMasterBreakpoint(this) != null && isMuted) {
      return AllIcons.Debugger.Db_muted_dep_field_breakpoint;
    }
    return null;
  }

  @Override
  public String getEventMessage(LocatableEvent event) {
    return "";
  }

  @Override
  protected Icon getVerifiedIcon(boolean isMuted) {
    return isSuspend() ? AllIcons.Debugger.Db_verified_field_breakpoint : AllIcons.Debugger.Db_verified_no_suspend_field_breakpoint;
  }

  @Override
  protected Icon getVerifiedWarningsIcon(boolean isMuted) {
    return new LayeredIcon(isMuted ? AllIcons.Debugger.Db_muted_field_breakpoint : AllIcons.Debugger.Db_field_breakpoint,
                           AllIcons.General.WarningDecorator);
  }

  @Override
  public boolean processLocatableEvent(@NotNull SuspendContextCommandImpl action, LocatableEvent event) throws EventProcessingException {
    SuspendContextImpl context = action.getSuspendContext();
    if (context == null) {
      return false;
    }

    final @NotNull DebugProcessImpl debugProcess = context.getDebugProcess();

    debugProcess.getRequestsManager().deleteRequest(this); // delete method entry request
    myAllMethodsEntryRequestIsEnabled = false;

    Location location = event.location();
    if (location == null) {
      emulateFieldWatchpoint(debugProcess, context);
      return false;
    }

    Method method = location.method();
    String type = location.declaringType().name();

    MethodEntryPlace place = MethodEntryPlace.DEFAULT;
    if (method.isStaticInitializer() && myClassesNames.contains(type)) {
      place = MethodEntryPlace.STATIC_BLOCK;
    }
    else if (method.isConstructor() && myClassesNames.contains(type)) {
      place = MethodEntryPlace.CONSTRUCTOR;
    }

    if (myIsStatic) {
      processClassesInJVM(context, event, place);
    }
    else {
      processInstancesInJVM(context, event, place);
    }

    emulateFieldWatchpoint(debugProcess, context);

    return false;
  }

  @Override
  public @Nullable PsiElement getEvaluationElement() {
    return getPsiClass();
  }

  @Override
  protected @Nullable ObjectReference getThisObject(SuspendContextImpl context, LocatableEvent event) {
    try {
      return super.getThisObject(context, event);
    }
    catch (EvaluateException e) {
      return null;
    }
  }

  private void setVariables(DebugProcessImpl debugProcess) {
    CollectionBreakpointUtils.setCollectionHistorySavingEnabled(debugProcess, shouldSaveCollectionHistory());
  }

  private boolean shouldSaveCollectionHistory() {
    return getProperties().SHOULD_SAVE_COLLECTION_HISTORY;
  }

  private void createRequestForClass(DebugProcessImpl debugProcess, ReferenceType refType) {
    String clsName = refType.name();
    myClassesNames.add(clsName);
    myUnprocessedClasses.add(clsName);
    if (!myAllMethodsEntryRequestIsEnabled) {
      createAllMethodsEntryRequest(debugProcess);
    }
  }

  private void processConstructorEntry(SuspendContextImpl context, LocatableEvent event) {
    if (!tryPopFrame(context)) {
      Location location = event.location();
      ReferenceType declaringType = location.declaringType();
      ObjectReference thisObj = getThisObject(context, event);
      setTemporaryFieldWatchpoint(context, declaringType, thisObj, context.getThread());
    }
  }

  private void setTemporaryFieldWatchpoint(@NotNull SuspendContextImpl context,
                                           @NotNull ReferenceType declaringType,
                                           @Nullable ObjectReference thisObj,
                                           @Nullable ThreadReferenceProxyImpl thread) {
    MyRequestor requestor = new MyRequestor(getProject());
    addFieldWatchpoint(requestor, context, declaringType, thisObj);
    createMethodExitRequest(requestor, context, declaringType, thisObj, thread);
  }

  private List<ReferenceType> getTrackedClassesInJVM(SuspendContextImpl context) {
    DebugProcessImpl debugProcess = context.getDebugProcess();
    VirtualMachineProxyImpl virtualMachineProxy = debugProcess.getVirtualMachineProxy();

    return myClassesNames
      .stream()
      .map(name -> virtualMachineProxy.classesByName(name))
      .flatMap(list -> list.stream())
      .filter(cls -> cls.isPrepared())
      .collect(Collectors.toList());
  }

  private List<ObjectReference> getTrackedInstancesInJVM(SuspendContextImpl context) {
    return getTrackedClassesInJVM(context)
      .stream()
      .map(cls -> cls.instances(MAX_INSTANCES_NUMBER))
      .flatMap(list -> list.stream())
      .collect(Collectors.toList());
  }

  private void processInstancesInJVM(SuspendContextImpl context, LocatableEvent event, MethodEntryPlace place) {
    List<ObjectReference> instances = getTrackedInstancesInJVM(context);
    if (instances.isEmpty()) {
      return;
    }

    if (instances.size() == 1 && MethodEntryPlace.CONSTRUCTOR.equals(place)) {
      processConstructorEntry(context, event);
    }
    else {
      processAllInstances(context, instances);
    }
  }

  private void processClassesInJVM(SuspendContextImpl context, LocatableEvent event, MethodEntryPlace place) {
    List<ReferenceType> classes = getTrackedClassesInJVM(context);
    if (classes.isEmpty()) {
      return;
    }

    if (classes.size() == 1 && MethodEntryPlace.STATIC_BLOCK.equals(place)) {
      ReferenceType declaringType = event.location().declaringType();
      ThreadReferenceProxyImpl thread = context.getThread();
      setTemporaryFieldWatchpoint(context, declaringType, null, thread);
    }
    else {
      processAllClasses(context, classes);
    }
  }

  private void processAllClasses(SuspendContextImpl context, List<ReferenceType> classes) {
    String fieldName = getFieldName();
    for (ReferenceType cls : classes) {
      Field field = cls.fieldByName(fieldName);
      if (cls.isInitialized()) {
        captureClsField(cls, field, context.getDebugProcess(), context);
      }
    }

    VirtualMachineProxyImpl vm = context.getDebugProcess().getVirtualMachineProxy();

    for (ThreadReferenceProxyImpl thread : vm.allThreads()) {
      try {
        if (thread.isSuspended()) {
          processMethodEntryInAllFrames(thread, context, classes);
        }
      }
      catch (EvaluateException e) {
        DebuggerUtilsImpl.logError(e);
      }
    }
  }

  private void processMethodEntryInAllFrames(ThreadReferenceProxyImpl thread,
                                             SuspendContextImpl context,
                                             List<ReferenceType> classes) throws EvaluateException {
    Set<ReferenceType> classesCopy = new HashSet<>(classes);
    List<StackFrameProxyImpl> frames = thread.frames();
    for (StackFrameProxyImpl frame : frames) {
      Method method = frame.location().method();
      ReferenceType declaringType = method.declaringType();
      boolean shouldCapture = !myIsFinal || method.isStaticInitializer();
      if (shouldCapture && classesCopy.contains(declaringType)) {
        ObjectReference thisObject = frame.thisObject();
        setTemporaryFieldWatchpoint(context, declaringType, thisObject, thread);
        classesCopy.remove(declaringType);
      }
    }
  }

  private void processAllInstances(SuspendContextImpl context, List<ObjectReference> instances) {
    String fieldName = getFieldName();
    for (ObjectReference instance : instances) {
      Field field = instance.referenceType().fieldByName(fieldName);
      captureInstanceField(instance, field, context.getDebugProcess(), context);
    }

    VirtualMachineProxyImpl vm = context.getDebugProcess().getVirtualMachineProxy();

    for (ThreadReferenceProxyImpl thread : vm.allThreads()) {
      try {
        if (thread.isSuspended()) {
          processNonStaticMethodEntryInAllFrames(thread, context, instances);
        }
      }
      catch (EvaluateException e) {
        DebuggerUtilsImpl.logError(e);
      }
    }
  }

  private void processNonStaticMethodEntryInAllFrames(ThreadReferenceProxyImpl thread,
                                                      SuspendContextImpl context,
                                                      List<ObjectReference> instances) throws EvaluateException {
    Set<ObjectReference> instancesCopy = new HashSet<>(instances);
    List<StackFrameProxyImpl> frames = thread.frames();
    for (StackFrameProxyImpl frame : frames) {
      Method method = frame.location().method();
      ObjectReference thisObject = frame.thisObject();
      boolean shouldCapture = !myIsFinal || method.isConstructor();
      if (shouldCapture && !method.isStatic() && instancesCopy.contains(thisObject)) {
        setTemporaryFieldWatchpoint(context, method.declaringType(), thisObject, thread);
        instancesCopy.remove(thisObject);
      }
    }
  }

  private void captureClsField(ReferenceType cls,
                               Field field,
                               DebugProcessImpl debugProcess,
                               SuspendContextImpl context) {
    Value value = cls.getValue(field);
    if (value != null) {
      captureFieldModification(value, null, false, debugProcess, context);
    }
  }

  private void captureInstanceField(ObjectReference instance,
                                    Field field,
                                    DebugProcessImpl debugProcess,
                                    SuspendContextImpl context) {
    Value value = instance.getValue(field);
    if (value != null) {
      captureFieldModification(value, instance, false, debugProcess, context);
    }
  }

  private void addFieldWatchpoint(MyRequestor requestor,
                                  SuspendContextImpl context,
                                  ReferenceType declaringType,
                                  @Nullable ObjectReference thisObj) {
    DebugProcessImpl debugProcess = context.getDebugProcess();
    Field field = declaringType.fieldByName(getFieldName());

    ModificationWatchpointRequest request =
      debugProcess.getRequestsManager().createModificationWatchpointRequest(requestor, field);

    request.addClassFilter(declaringType);

    if (thisObj != null) {
      request.addInstanceFilter(thisObj);
    }

    request.enable();
  }

  private void createRequestForSubclasses(DebugProcessImpl debugProcess, ReferenceType baseType) {
    final VirtualMachineProxyImpl virtualMachineProxy = debugProcess.getVirtualMachineProxy();

    // create a request for classes that are already loaded
    virtualMachineProxy.allClasses()
      .stream()
      .filter(type -> DebuggerUtilsImpl.instanceOf(type, baseType) && !type.name().equals(baseType.name()))
      .forEach(derivedType -> createRequestForClass(debugProcess, derivedType));

    // wait for the subclasses
    RequestManagerImpl requestManager = debugProcess.getRequestsManager();
    ClassPrepareRequest request = requestManager.createClassPrepareRequest((debuggerProcess, derivedType) -> {
      createRequestForClass(debugProcess, derivedType);
    }, null);
    if (request != null) {
      requestManager.registerRequest(this, request);
      request.addClassFilter(baseType);
      request.enable();
    }
  }

  @Override
  public Key<CollectionBreakpoint> getCategory() {
    return CATEGORY;
  }

  @Override
  public @Nullable String getClassName() {
    return getProperties().myClassName;
  }

  @Override
  public synchronized @NotNull Project getProject() {
    return super.getProject();
  }

  @Override
  public String getDisplayName() {
    return "";
  }

  public synchronized String getFieldName() {
    return getProperties().myFieldName;
  }

  private void createAllMethodsEntryRequest(DebugProcessImpl debugProcess) {
    RequestManagerImpl requestManager = debugProcess.getRequestsManager();
    MethodEntryRequest request = requestManager.createMethodEntryRequest(this);
    request.enable();
  }

  private void captureFieldModification(Value valueToBe,
                                        Value obj,
                                        boolean shouldSaveStack,
                                        DebugProcessImpl debugProcess,
                                        SuspendContextImpl context) {
    StackFrameProxyImpl frameProxy = context.getFrameProxy();
    if (frameProxy == null) {
      return;
    }

    Value internalClsName = getInternalClsName(debugProcess, context);
    if (internalClsName == null) {
      return;
    }

    Value fieldName = frameProxy.getVirtualMachine().mirrorOf(getFieldName());
    Value shouldSave = frameProxy.getVirtualMachine().mirrorOf(shouldSaveStack);

    ArrayList<Value> args = new ArrayList<>();
    args.add(valueToBe);
    args.add(obj);
    args.add(internalClsName);
    args.add(fieldName);
    args.add(shouldSave);

    CollectionBreakpointUtils.invokeInstrumentorMethod(debugProcess, context,
                                                       CAPTURE_FIELD_MODIFICATION_METHOD_NAME,
                                                       CAPTURE_FIELD_MODIFICATION_METHOD_DESC,
                                                       args);
  }

  private Value getInternalClsName(DebugProcessImpl debugProcess, SuspendContextImpl context) {
    String clsTypeDesc = myClsTypeDesc;
    StackFrameProxyImpl frameProxy = context.getFrameProxy();

    if (clsTypeDesc == null || frameProxy == null) {
      return null;
    }

    Value clsTypeDescRef = frameProxy.getVirtualMachine().mirrorOf(clsTypeDesc);

    return CollectionBreakpointUtils.invokeInstrumentorMethod(debugProcess, context,
                                                              GET_INTERNAL_CLS_NAME_METHOD_NAME,
                                                              GET_INTERNAL_CLS_NAME_METHOD_DESC,
                                                              Collections.singletonList(clsTypeDescRef));
  }

  private void emulateFieldWatchpoint(DebugProcessImpl debugProcess, SuspendContextImpl context) {
    try {
      putFieldToCapture(debugProcess, context);
      transformClassesToEmulateFieldWatchpoint(debugProcess, context);
      if (suspendOnBreakpointHit()) {
        setLineBreakpoints(context);
      }
    }
    catch (EvaluateException e) {
      DebuggerUtilsImpl.logError(e);
    }
  }

  private void putFieldToCapture(DebugProcessImpl debugProcess, SuspendContextImpl context) {
    StackFrameProxyImpl frameProxy = context.getFrameProxy();
    if (frameProxy == null) {
      return;
    }

    String clsTypeDesc = myClsTypeDesc;
    if (clsTypeDesc == null) {
      return;
    }

    Value clsTypeDescRef = frameProxy.getVirtualMachine().mirrorOf(clsTypeDesc);
    Value fieldName = frameProxy.getVirtualMachine().mirrorOf(getFieldName());

    CollectionBreakpointUtils.invokeInstrumentorMethod(debugProcess, context, PUT_FIELD_TO_CAPTURE_METHOD_NAME,
                                                       PUT_FIELD_TO_CAPTURE_METHOD_DESC, List.of(clsTypeDescRef, fieldName));
  }

  private void transformClassesToEmulateFieldWatchpoint(DebugProcessImpl debugProcess,
                                                        SuspendContextImpl context) throws EvaluateException {
    StackFrameProxyImpl frameProxy = context.getFrameProxy();
    if (frameProxy == null) {
      return;
    }

    List<Value> args = ContainerUtil.map(myUnprocessedClasses, clsName -> frameProxy.getVirtualMachine().mirrorOf(clsName));
    myUnprocessedClasses.clear();
    CollectionBreakpointUtils.invokeInstrumentorMethod(debugProcess, context, EMULATE_FIELD_WATCHPOINT_METHOD_NAME,
                                                       EMULATE_FIELD_WATCHPOINT_METHOD_DESC, args);
  }

  private void setLineBreakpoints(SuspendContextImpl context) {
    DebugProcessImpl debugProcess = context.getDebugProcess();
    EvaluationContextImpl evalContext = new EvaluationContextImpl(context, context.getFrameProxy());
    evalContext = evalContext.withAutoLoadClasses(false);
    ClassType instrumentorCls = CollectionBreakpointUtils.getInstrumentorClass(debugProcess, evalContext);
    List<Location> locations = findLocationsInInstrumentorMethods(instrumentorCls);
    for (Location location : locations) {
      SourcePosition position = locationToPosition(context.getDebugProcess(), location);
      MyLineBreakpoint breakpoint = new MyLineBreakpoint(location, position);
      breakpoint.createBreakpointRequest(context);
    }
  }

  private boolean suspendOnBreakpointHit() {
    return !DebuggerSettings.SUSPEND_NONE.equals(getSuspendPolicy());
  }

  private static void createMethodExitRequest(FilteredRequestor requestor,
                                              SuspendContextImpl context,
                                              @NotNull ReferenceType declaringType,
                                              @Nullable ObjectReference thisObj,
                                              @Nullable ThreadReferenceProxyImpl thread) {
    DebugProcessImpl debugProcess = context.getDebugProcess();
    RequestManagerImpl requestManager = debugProcess.getRequestsManager();

    MethodExitRequest request = requestManager.createMethodExitRequest(requestor);

    request.addClassFilter(declaringType);

    if (thisObj != null) {
      request.addInstanceFilter(thisObj);
    }

    if (thread != null) {
      request.addThreadFilter(thread.getThreadReference());
    }

    request.enable();
  }

  private static boolean tryPopFrame(SuspendContextImpl suspendContext) {
    StackFrameProxyImpl frameProxy = suspendContext.getFrameProxy();
    if (frameProxy == null) {
      return false;
    }
    try {
      frameProxy.threadProxy().popFrames(frameProxy);
      return true;
    }
    catch (final EvaluateException e) {
      return false;
    }
  }

   /*

   private static void createEmulatedMethodExitRequest(FilteredRequestor requestor, SuspendContextImpl context, LocatableEvent event) {
    DebugProcessImpl debugProcess = context.getDebugProcess();
    Method method = event.location().method();

    List<Location> allLineLocations = DebuggerUtilsEx.allLineLocations(method);

    if (method.isNative() || (allLineLocations == null && !method.isBridge())) {
      createMethodExitRequest(requestor, context, event.location().declaringType(), null, null);
    }
    else if (allLineLocations != null && !allLineLocations.isEmpty()) {
      visitMethodBytecode(method, allLineLocations, debugProcess, requestor);
    }
  }

  private static void visitMethodBytecode(Method method,
                                          List<Location> allLineLocations,
                                          DebugProcessImpl debugProcess,
                                          FilteredRequestor requestor) {
    MethodBytecodeUtil.visit(method, new MethodVisitor(Opcodes.API_VERSION) {
      int myLastLine = 0;

      @Override
      public void visitLineNumber(int line, Label start) {
        myLastLine = line;
      }

      @Override
      public void visitInsn(int opcode) {
        switch (opcode) {
          case Opcodes.RETURN:
          case Opcodes.IRETURN:
          case Opcodes.FRETURN:
          case Opcodes.ARETURN:
          case Opcodes.LRETURN:
          case Opcodes.DRETURN:
            //case Opcodes.ATHROW:
            allLineLocations.stream()
              .filter(l -> l.lineNumber() == myLastLine)
              .findFirst().ifPresent(location -> {
                createLocationBreakpointRequest(requestor, location, debugProcess, false);
              });
        }
      }
    }, true);
  }

  private static void createLocationBreakpointRequest(@NotNull FilteredRequestor requestor,
                                                      @Nullable Location location,
                                                      @NotNull DebugProcessImpl debugProcess,
                                                      boolean methodEntry) {
    createLocationBreakpointRequest(requestor, location, debugProcess);
  }

  */

  private static Location findLocationInMethod(ClassType instrumentorCls, String methodName, String methodDesc, int lineNumber) {
    try {
      Method method =
        DebuggerUtils.findMethod(instrumentorCls, methodName, methodDesc);
      if (method != null) {
        List<Location> lines = method.allLineLocations();
        if (lines.size() >= lineNumber + 1) {
          return lines.get(lineNumber);
        }
      }
    }
    catch (AbsentInformationException e) {
      DebuggerUtilsImpl.logError(e);
    }
    return null;
  }

  private static Location findLocationInCaptureFieldModificationMethod(ClassType instrumentorCls) {
    return findLocationInMethod(instrumentorCls,
                                CAPTURE_FIELD_MODIFICATION_METHOD_NAME,
                                CAPTURE_FIELD_MODIFICATION_METHOD_DESC,
                                5);
  }

  private static Location findLocationInDefaultCaptureCollectionModificationMethod(ClassType instrumentorCls) {
    return findLocationInMethod(instrumentorCls,
                                CAPTURE_COLLECTION_MODIFICATION_DEFAULT_METHOD_NAME,
                                CAPTURE_COLLECTION_MODIFICATION_DEFAULT_METHOD_DESC,
                                5);
  }

  private static Location findLocationInSpecialCaptureCollectionModificationMethod(ClassType instrumentorCls) {
    return findLocationInMethod(instrumentorCls,
                                CAPTURE_COLLECTION_MODIFICATION_SPECIAL_METHOD_NAME,
                                CAPTURE_COLLECTION_MODIFICATION_SPECIAL_METHOD_DESC,
                                2);
  }

  @NotNull
  private static List<Location> findLocationsInInstrumentorMethods(ClassType instrumentorCls) {
    List<Location> locations = new ArrayList<>();
    Location location = findLocationInCaptureFieldModificationMethod(instrumentorCls);
    if (location != null) {
      locations.add(location);
    }
    location = findLocationInDefaultCaptureCollectionModificationMethod(instrumentorCls);
    if (location != null) {
      locations.add(location);
    }
    location = findLocationInSpecialCaptureCollectionModificationMethod(instrumentorCls);
    if (location != null) {
      locations.add(location);
    }
    return locations;
  }

  private static @Nullable SourcePosition locationToPosition(DebugProcessImpl debugProcess, @Nullable Location location) {
    return location == null ? null : debugProcess.getPositionManager().getSourcePosition(location);
  }

  private static boolean stackContainsAnyObsoleteMethod(SuspendContextImpl context,
                                                        ReferenceType declaringType,
                                                        ObjectReference thisObj) {
    ThreadReferenceProxyImpl thread = context.getThread();
    if (thread == null) {
      return false;
    }
    try {
      List<StackFrameProxyImpl> frames = thread.frames();
      if (frames.size() == 1) {
        return false;
      }
      for (StackFrameProxyImpl frame : frames.subList(1, frames.size())) {
        Method method = frame.location().method();
        if (method.isObsolete() && method.declaringType().equals(declaringType)) {
          return thisObj == null || thisObj.equals(frame.thisObject());
        }
      }
    }
    catch (EvaluateException e) {
      DebuggerUtilsImpl.logError(e);
    }
    return false;
  }

  private enum MethodEntryPlace {
    STATIC_BLOCK,
    CONSTRUCTOR,
    DEFAULT
  }

  private class MyRequestor extends FilteredRequestorImpl {

    private MyRequestor(@NotNull Project project) {
      super(project);
    }

    @Override
    public boolean processLocatableEvent(@NotNull SuspendContextCommandImpl action, LocatableEvent event) throws EventProcessingException {
      SuspendContextImpl context = action.getSuspendContext();
      if (context == null) {
        return false;
      }

      DebugProcessImpl debugProcess = context.getDebugProcess();
      ObjectReference thisObj = getThisObject(context, event);

      if (event instanceof ModificationWatchpointEvent) {
        Value valueToBe = ((ModificationWatchpointEvent)event).valueToBe();
        captureFieldModification(valueToBe, thisObj, true, debugProcess, context);
      }
      else {
        ReferenceType declaringType = event.location().declaringType();
        if (!stackContainsAnyObsoleteMethod(context, declaringType, thisObj)) {
          debugProcess.getRequestsManager().deleteRequest(this);
        }
      }
      return false;
    }
  }

  private class MyLineBreakpoint extends SyntheticLineBreakpoint {
    private final @Nullable SourcePosition myPosition;
    private final @Nullable Location myLocation;

    private MyLineBreakpoint(@Nullable Location location, @Nullable SourcePosition position) {
      super(CollectionBreakpoint.this.getProject());
      myLocation = location;
      myPosition = position;
      setSuspendPolicy(CollectionBreakpoint.this.getSuspendPolicy());
    }

    private void createBreakpointRequest(SuspendContextImpl suspendContext) {
      if (myLocation != null) {
        createLocationBreakpointRequest(this, myLocation, suspendContext.getDebugProcess());
      }
    }

    @Override
    public boolean processLocatableEvent(@NotNull SuspendContextCommandImpl action, LocatableEvent event) throws EventProcessingException {
      return processBreakpointHit(action);
    }

    private boolean processBreakpointHit(@NotNull SuspendContextCommandImpl action) {
      SuspendContextImpl context = action.getSuspendContext();
      if (context == null) {
        return false;
      }
      try {
        DebugProcessImpl debugProcess = context.getDebugProcess();
        DebugProcessImpl.ResumeCommand stepOutCommand = debugProcess.createStepOutCommand(context);
        debugProcess.getManagerThread().schedule(stepOutCommand);
      }
      catch (Exception e) {
        DebuggerUtilsImpl.logError(e);
        return false;
      }
      return true;
    }

    @Override
    public @Nullable SourcePosition getSourcePosition() {
      return myPosition;
    }

    @Override
    public int getLineIndex() {
      return myPosition == null ? -1 : myPosition.getLine();
    }

    @Override
    public String getEventMessage(LocatableEvent event) {
      return "";
    }

    @Override
    protected String getFileName() {
      return "";
    }
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.idea.ActionsBundle;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.project.Project;
import com.intellij.ui.components.AnActionLink;
import com.intellij.util.ui.JBUI;
import com.intellij.xdebugger.XDebugSession;
import com.intellij.xdebugger.XDebuggerManager;
import com.intellij.xdebugger.breakpoints.XLineBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import com.intellij.xdebugger.impl.breakpoints.XBreakpointBase;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaCollectionBreakpointProperties;

import javax.swing.*;
import java.awt.*;

@ApiStatus.Experimental
public class CollectionBreakpointPropertiesPanel
  extends XBreakpointCustomPropertiesPanel<XLineBreakpoint<JavaCollectionBreakpointProperties>> {
  private final static int PREFERRED_PANEL_HEIGHT = 40;
  private @Nullable String myClsName = null;
  private @Nullable String myFieldName = null;
  private JCheckBox mySaveCollectionHistoryCheckBox;

  @Override
  public @NotNull JComponent getComponent() {
    mySaveCollectionHistoryCheckBox =
      new JCheckBox(JavaDebuggerBundle.message("label.collection.breakpoint.properties.save.history"));
    AnActionLink button =
      new AnActionLink(ActionsBundle.message("action.Debugger.ShowCollectionHistory.text"), new MyShowCollectionHistoryAction());

    Box box = Box.createVerticalBox();

    JPanel panel = JBUI.Panels.simplePanel();
    panel.add(mySaveCollectionHistoryCheckBox, BorderLayout.NORTH);
    mySaveCollectionHistoryCheckBox.setPreferredSize(new Dimension(panel.getPreferredSize().width, PREFERRED_PANEL_HEIGHT));
    box.add(panel);

    panel = JBUI.Panels.simplePanel();
    panel.add(button);
    button.setPreferredSize(new Dimension(panel.getPreferredSize().width, PREFERRED_PANEL_HEIGHT));
    box.add(panel);

    panel = JBUI.Panels.simplePanel();
    panel.add(box);

    return panel;
  }

  @Override
  public void saveTo(@NotNull XLineBreakpoint<JavaCollectionBreakpointProperties> breakpoint) {
    boolean changed = breakpoint.getProperties().SHOULD_SAVE_COLLECTION_HISTORY != mySaveCollectionHistoryCheckBox.isSelected();
    breakpoint.getProperties().SHOULD_SAVE_COLLECTION_HISTORY = mySaveCollectionHistoryCheckBox.isSelected();
    if (changed) {
      ((XBreakpointBase<?, ?, ?>)breakpoint).fireBreakpointChanged();
    }
  }

  @Override
  public void loadFrom(@NotNull XLineBreakpoint<JavaCollectionBreakpointProperties> breakpoint) {
    JavaCollectionBreakpointProperties properties = breakpoint.getProperties();
    myClsName = properties.myClassName;
    myFieldName = properties.myFieldName;
    mySaveCollectionHistoryCheckBox.setSelected(properties.SHOULD_SAVE_COLLECTION_HISTORY);
  }

  private class MyShowCollectionHistoryAction extends AnAction {

    @Override
    public void actionPerformed(@NotNull AnActionEvent e) {
      String clsName = myClsName;
      String fieldName = myFieldName;
      if (clsName == null || fieldName == null) {
        return;
      }
      Project project = getEventProject(e);
      if (project == null) {
        return;
      }
      XDebugSession session = XDebuggerManager.getInstance(project).getCurrentSession();
      if (session == null) {
        return;
      }
      DebuggerUtilsEx.addCollectionHistoryTab(session, clsName, fieldName, null);
    }
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

/*
 * Class EditClassFiltersDialog
 * @author Jeka
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.ide.util.ClassFilter;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.ui.IdeBorderFactory;
import com.intellij.ui.classFilter.ClassFilterEditor;
import com.intellij.util.ui.JBUI;

import javax.swing.*;
import java.awt.*;

public class EditClassFiltersDialog extends DialogWrapper {
  private ClassFilterEditor myClassFilterEditor;
  private ClassFilterEditor myClassExclusionFilterEditor;
  private final Project myProject;
  private final ClassFilter myChooserFilter;

  public EditClassFiltersDialog(Project project) {
    this(project, null);
  }

  public EditClassFiltersDialog(Project project, ClassFilter filter) {
    super(project, true);
    myChooserFilter = filter;
    myProject = project;
    setTitle(JavaDebuggerBundle.message("class.filters.dialog.title"));
    init();
  }

  protected ClassFilterEditor createClassFilterEditor(Project project) {
    return new ClassFilterEditor(project, myChooserFilter, "reference.viewBreakpoints.classFilters.newPattern");
  }

  @Override
  protected JComponent createCenterPanel() {
    JPanel contentPanel = new JPanel(new BorderLayout());

    Box mainPanel = Box.createHorizontalBox();

    myClassFilterEditor = createClassFilterEditor(myProject);
    myClassFilterEditor.setPreferredSize(JBUI.size(400, 200));
    myClassFilterEditor.setBorder(IdeBorderFactory.createTitledBorder(
      JavaDebuggerBundle.message("class.filters.dialog.inclusion.filters.group"), false));
    mainPanel.add(myClassFilterEditor);

    myClassExclusionFilterEditor = createClassFilterEditor(myProject);
    myClassExclusionFilterEditor.setPreferredSize(JBUI.size(400, 200));
    myClassExclusionFilterEditor.setBorder(IdeBorderFactory.createTitledBorder(
      JavaDebuggerBundle.message("class.filters.dialog.exclusion.filters.group"), false));
    mainPanel.add(myClassExclusionFilterEditor);

    contentPanel.add(mainPanel, BorderLayout.CENTER);

    return contentPanel;
  }

  @Override
  public void dispose() {
    myClassFilterEditor.stopEditing();
    myClassExclusionFilterEditor.stopEditing();
    super.dispose();
  }

  public void setFilters(com.intellij.ui.classFilter.ClassFilter[] filters, com.intellij.ui.classFilter.ClassFilter[] inverseFilters) {
    myClassFilterEditor.setFilters(filters);
    myClassExclusionFilterEditor.setFilters(inverseFilters);
  }

  @Override
  protected String getDimensionServiceKey() {
    return "#com.intellij.debugger.ui.breakpoints.EditClassFiltersDialog";
  }

  public com.intellij.ui.classFilter.ClassFilter[] getFilters() {
    return myClassFilterEditor.getFilters();
  }

  public com.intellij.ui.classFilter.ClassFilter[] getExclusionFilters() {
    return myClassExclusionFilterEditor.getFilters();
  }

  @Override
  protected String getHelpId() {
    return "reference.viewBreakpoints.classFilters";
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.InstanceFilter;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.ui.InstanceFilterEditor;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.ui.classFilter.ClassFilter;
import com.intellij.util.ui.JBUI;

import javax.swing.*;
import java.util.Arrays;

public class EditInstanceFiltersDialog extends DialogWrapper {
  private InstanceFilterEditor myInstanceFilterEditor;
  private final Project myProject;

  public EditInstanceFiltersDialog(Project project) {
    super(project, true);
    myProject = project;
    setTitle(JavaDebuggerBundle.message("instance.filters.dialog.title"));
    init();
  }

  @Override
  protected JComponent createCenterPanel() {
    myInstanceFilterEditor = new InstanceFilterEditor(myProject);
    myInstanceFilterEditor.setPreferredSize(JBUI.size(400, 200));
    return myInstanceFilterEditor;
  }

  @Override
  public void dispose() {
    myInstanceFilterEditor.stopEditing();
    super.dispose();
  }

  public void setFilters(InstanceFilter[] filters) {
    ClassFilter[] cFilters = InstanceFilter.createClassFilters(filters);
    myInstanceFilterEditor.setFilters(cFilters);
  }

  @Override
  protected String getDimensionServiceKey() {
    return "#com.intellij.debugger.ui.breakpoints.EditInstanceFiltersDialog";
  }

  public InstanceFilter[] getFilters() {
    return Arrays.stream(myInstanceFilterEditor.getFilters()).map(InstanceFilter::create).toArray(InstanceFilter[]::new);
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

/*
 * Class ExceptionBreakpoint
 * @author Jeka
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.*;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.requests.RequestManagerImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.JDOMExternalizerUtil;
import com.intellij.openapi.util.Key;
import com.intellij.psi.CommonClassNames;
import com.intellij.psi.JavaPsiFacade;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiElement;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.ui.classFilter.ClassFilter;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.sun.jdi.AbsentInformationException;
import com.sun.jdi.Location;
import com.sun.jdi.ObjectReference;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.event.ExceptionEvent;
import com.sun.jdi.event.LocatableEvent;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.java.debugger.breakpoints.properties.JavaExceptionBreakpointProperties;

import javax.swing.*;

public class ExceptionBreakpoint extends Breakpoint<JavaExceptionBreakpointProperties> {
  private static final Logger LOG = Logger.getInstance(ExceptionBreakpoint.class);

  public static final @NonNls Key<ExceptionBreakpoint> CATEGORY = BreakpointCategory.lookup("exception_breakpoints");

  public ExceptionBreakpoint(Project project, XBreakpoint<JavaExceptionBreakpointProperties> xBreakpoint) {
    super(project, xBreakpoint);
  }

  @Override
  public Key<? extends ExceptionBreakpoint> getCategory() {
    return CATEGORY;
  }

  protected ExceptionBreakpoint(Project project, String qualifiedName, String packageName, XBreakpoint<JavaExceptionBreakpointProperties> xBreakpoint) {
    super(project, xBreakpoint);
    setQualifiedName(qualifiedName);
    if (packageName == null) {
      setPackageName(calcPackageName(qualifiedName));
    }
    else {
      setPackageName(packageName);
    }
  }

  private static String calcPackageName(String qualifiedName) {
    if (qualifiedName == null) {
      return null;
    }
    int dotIndex = qualifiedName.lastIndexOf('.');
    return dotIndex >= 0 ? qualifiedName.substring(0, dotIndex) : "";
  }

  @Override
  public String getClassName() {
    return getQualifiedName();
  }

  @Override
  public String getPackageName() {
    return getProperties().myPackageName;
  }

  @Override
  public PsiClass getPsiClass() {
    return ReadAction.compute(() -> getQualifiedName() != null ? DebuggerUtils.findClass(getQualifiedName(), myProject, GlobalSearchScope.allScope(myProject)) : null);
  }

  @Override
  public String getDisplayName() {
    return JavaDebuggerBundle.message("breakpoint.exception.breakpoint.display.name", getQualifiedName());
  }

  @Override
  public Icon getIcon() {
    return AllIcons.Debugger.Db_exception_breakpoint;
  }

  @Override
  public void reload() {
  }

  @Override
  public void createRequest(final DebugProcessImpl debugProcess) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    if (!shouldCreateRequest(debugProcess)) {
      return;
    }

    SourcePosition classPosition = ReadAction.compute(() -> {
      PsiClass psiClass = DebuggerUtils.findClass(getQualifiedName(), myProject, debugProcess.getSearchScope());
      return psiClass != null ? SourcePosition.createFromElement(psiClass) : null;
    });

    if (classPosition == null) {
      createOrWaitPrepare(debugProcess, getQualifiedName());
    }
    else {
      createOrWaitPrepare(debugProcess, classPosition);
    }
  }

  @Override
  public void processClassPrepare(DebugProcess process, ReferenceType refType) {
    DebugProcessImpl debugProcess = (DebugProcessImpl)process;
    if (shouldCreateRequest(debugProcess, true) && !debugProcess.getRequestsManager().checkReadOnly(this)) {
      // trying to create a request
      RequestManagerImpl manager = debugProcess.getRequestsManager();
      manager.enableRequest(manager.createExceptionRequest(this, refType, isNotifyCaught(), isNotifyUncaught()));

      if (LOG.isDebugEnabled()) {
        if (refType != null) {
          LOG.debug("Created exception request for reference type " + refType.name());
        }
        else {
          LOG.debug("Created exception request for reference type null");
        }
      }
    }
  }

  @Override
  protected String calculateEventClass(EvaluationContextImpl context, LocatableEvent event) throws EvaluateException {
    return event.location().declaringType().name();
  }

  @Override
  protected ObjectReference getThisObject(SuspendContextImpl context, LocatableEvent event) throws EvaluateException {
    if (event instanceof ExceptionEvent) {
      return ((ExceptionEvent)event).exception();
    }
    return super.getThisObject(context, event);
  }

  @Override
  public String getEventMessage(LocatableEvent event) {
    String exceptionName = (getQualifiedName() != null) ? getQualifiedName() : CommonClassNames.JAVA_LANG_THROWABLE;
    String threadName = null;
    if (event instanceof ExceptionEvent exceptionEvent) {
      try {
        exceptionName = exceptionEvent.exception().type().name();
        threadName = exceptionEvent.thread().name();
      }
      catch (Exception ignore) {
      }
    }
    Location location = event.location();
    String locationQName = DebuggerUtilsEx.getLocationMethodQName(location);
    String locationInfo;
    try {
      String file = location.sourceName();
      int line = DebuggerUtilsEx.getLineNumber(location, false);
      locationInfo = JavaDebuggerBundle.message("exception.breakpoint.console.message.location.info", file, line);
    }
    catch (AbsentInformationException e) {
      locationInfo = JavaDebuggerBundle.message("exception.breakpoint.console.message.location.info.absent");
    }
    if (threadName != null) {
      return JavaDebuggerBundle.message("exception.breakpoint.console.message.with.thread.info",
                                        exceptionName, threadName, locationQName, locationInfo
      );
    }
    else {
      return JavaDebuggerBundle.message("exception.breakpoint.console.message", exceptionName, locationQName, locationInfo);
    }
  }

  @Override
  public boolean evaluateCondition(EvaluationContextImpl context, LocatableEvent event) throws EvaluateException {
    if (getProperties().isCatchFiltersEnabled() && event instanceof ExceptionEvent) {
      Location location = ((ExceptionEvent)event).catchLocation();
      if (location != null && !typeMatchesClassFilters(location.declaringType().name(),
                                                       getProperties().getCatchClassFilters(),
                                                       getProperties().getCatchClassExclusionFilters())) {
        return false;
      }
    }
    return super.evaluateCondition(context, event);
  }

  @Override
  public boolean isValid() {
    return true;
  }

  //@SuppressWarnings({"HardCodedStringLiteral"}) public void writeExternal(Element parentNode) throws WriteExternalException {
  //  super.writeExternal(parentNode);
  //  if (getQualifiedName() != null) {
  //    parentNode.setAttribute("class_name", getQualifiedName());
  //  }
  //  if (getPackageName() != null) {
  //    parentNode.setAttribute("package_name", getPackageName());
  //  }
  //}

  @Override
  public PsiElement getEvaluationElement() {
    if (getClassName() == null) {
      return null;
    }
    return JavaPsiFacade.getInstance(myProject).findClass(getClassName(), GlobalSearchScope.allScope(myProject));
  }

  @Override
  public void readExternal(Element parentNode) throws InvalidDataException {
    super.readExternal(parentNode);

    String packageName = parentNode.getAttributeValue("package_name");
    setPackageName(packageName != null ? packageName : calcPackageName(packageName));

    try {
      getProperties().NOTIFY_CAUGHT = Boolean.parseBoolean(JDOMExternalizerUtil.readField(parentNode, "NOTIFY_CAUGHT"));
    }
    catch (Exception ignore) {
    }
    try {
      getProperties().NOTIFY_UNCAUGHT = Boolean.parseBoolean(JDOMExternalizerUtil.readField(parentNode, "NOTIFY_UNCAUGHT"));
    }
    catch (Exception ignore) {
    }

    String className = parentNode.getAttributeValue("class_name");
    setQualifiedName(className);
    if (className == null) {
      throw new InvalidDataException(getReadNoClassName());
    }
  }

  private boolean isNotifyCaught() {
    return getProperties().NOTIFY_CAUGHT;
  }

  private boolean isNotifyUncaught() {
    return getProperties().NOTIFY_UNCAUGHT;
  }

  private String getQualifiedName() {
    return getProperties().myQualifiedName;
  }

  void setQualifiedName(String qualifiedName) {
    getProperties().myQualifiedName = qualifiedName;
  }

  void setPackageName(String packageName) {
    getProperties().myPackageName = packageName;
  }

  public void setCatchFiltersEnabled(boolean enabled) {
    getProperties().setCatchFiltersEnabled(enabled);
  }

  public void setCatchClassFilters(ClassFilter[] filters) {
    getProperties().setCatchClassFilters(filters);
  }

  public void setCatchClassExclusionFilters(ClassFilter[] filters) {
    getProperties().setCatchClassExclusionFilters(filters);
  }

  protected static String getReadNoClassName() {
    return JavaDebuggerBundle.message("error.absent.exception.breakpoint.class.name");
  }
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Class ExceptionBreakpointPropertiesPanel
 * @author Jeka
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.ui.IdeBorderFactory;
import com.intellij.util.ui.DialogUtil;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import com.intellij.xdebugger.impl.breakpoints.XBreakpointBase;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.java.debugger.breakpoints.properties.JavaExceptionBreakpointProperties;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class ExceptionBreakpointPropertiesPanel extends XBreakpointCustomPropertiesPanel<XBreakpoint<JavaExceptionBreakpointProperties>> {
  private JCheckBox myNotifyCaughtCheckBox;
  private JCheckBox myNotifyUncaughtCheckBox;
  //private ExceptionBreakpoint myExceptionBreakpoint;

  //public ExceptionBreakpointPropertiesPanel(Project project, boolean compact) {
  //  super(project, ExceptionBreakpoint.CATEGORY, compact);
  //}

  //protected ClassFilter createClassConditionFilter() {
  //  return null;
  //}

  @NotNull
  @Override
  public JComponent getComponent() {
    myNotifyCaughtCheckBox = new JCheckBox(JavaDebuggerBundle.message("label.exception.breakpoint.properties.panel.caught.exception"));
    myNotifyUncaughtCheckBox = new JCheckBox(JavaDebuggerBundle.message("label.exception.breakpoint.properties.panel.uncaught.exception"));
    DialogUtil.registerMnemonic(myNotifyCaughtCheckBox);
    DialogUtil.registerMnemonic(myNotifyUncaughtCheckBox);


    Box notificationsBox = Box.createVerticalBox();
    JPanel _panel = new JPanel(new BorderLayout());
    _panel.add(myNotifyCaughtCheckBox, BorderLayout.NORTH);
    notificationsBox.add(_panel);
    _panel = new JPanel(new BorderLayout());
    _panel.add(myNotifyUncaughtCheckBox, BorderLayout.NORTH);
    notificationsBox.add(_panel);

    _panel = new JPanel(new BorderLayout());
    JPanel _panel0 = new JPanel(new BorderLayout());
    _panel0.add(notificationsBox, BorderLayout.CENTER);
    _panel0.add(Box.createHorizontalStrut(3), BorderLayout.WEST);
    _panel0.add(Box.createHorizontalStrut(3), BorderLayout.EAST);
    _panel.add(_panel0, BorderLayout.NORTH);
    _panel.setBorder(IdeBorderFactory.createTitledBorder(
      JavaDebuggerBundle.message("label.exception.breakpoint.properties.panel.group.notifications")));

    ActionListener listener = new ActionListener() {
      @Override
      public void actionPerformed(ActionEvent e) {
        if (!myNotifyCaughtCheckBox.isSelected() && !myNotifyUncaughtCheckBox.isSelected()) {
          Object source = e.getSource();
          JCheckBox toCheck = null;
          if (myNotifyCaughtCheckBox.equals(source)) {
            toCheck = myNotifyUncaughtCheckBox;
          }
          else if (myNotifyUncaughtCheckBox.equals(source)) {
            toCheck = myNotifyCaughtCheckBox;
          }
          if (toCheck != null) {
            toCheck.setSelected(true);
          }
        }
      }
    };
    myNotifyCaughtCheckBox.addActionListener(listener);
    myNotifyUncaughtCheckBox.addActionListener(listener);
    return _panel;
  }

  //protected void updateCheckboxes() {
  //  super.updateCheckboxes();
  //  myPassCountCheckbox.setEnabled(!(myExceptionBreakpoint instanceof AnyExceptionBreakpoint));
  //}

  @Override
  public void loadFrom(@NotNull XBreakpoint<JavaExceptionBreakpointProperties> breakpoint) {
    myNotifyCaughtCheckBox.setSelected(breakpoint.getProperties().NOTIFY_CAUGHT);
    myNotifyUncaughtCheckBox.setSelected(breakpoint.getProperties().NOTIFY_UNCAUGHT);
  }

  @Override
  public void saveTo(@NotNull XBreakpoint<JavaExceptionBreakpointProperties> breakpoint) {
    boolean changed = breakpoint.getProperties().NOTIFY_CAUGHT != myNotifyCaughtCheckBox.isSelected();
    breakpoint.getProperties().NOTIFY_CAUGHT = myNotifyCaughtCheckBox.isSelected();
    changed = breakpoint.getProperties().NOTIFY_UNCAUGHT != myNotifyUncaughtCheckBox.isSelected() || changed;
    breakpoint.getProperties().NOTIFY_UNCAUGHT = myNotifyUncaughtCheckBox.isSelected();
    if (changed) {
      ((XBreakpointBase<?, ?, ?>)breakpoint).fireBreakpointChanged();
    }
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

/*
 * Class FieldBreakpoint
 * @author Jeka
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.SuspendContextImpl;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.jdi.VirtualMachineProxy;
import com.intellij.debugger.engine.requests.RequestManagerImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.impl.PositionUtil;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.project.IndexNotReadyException;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.JDOMExternalizerUtil;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.psi.*;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.ui.LayeredIcon;
import com.intellij.util.SlowOperations;
import com.intellij.util.text.CharArrayUtil;
import com.intellij.xdebugger.XDebuggerUtil;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.sun.jdi.Field;
import com.sun.jdi.Location;
import com.sun.jdi.ObjectReference;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.event.AccessWatchpointEvent;
import com.sun.jdi.event.LocatableEvent;
import com.sun.jdi.event.ModificationWatchpointEvent;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.java.debugger.breakpoints.properties.JavaFieldBreakpointProperties;

import javax.swing.*;

public class FieldBreakpoint extends BreakpointWithHighlighter<JavaFieldBreakpointProperties> {
  private static final Logger LOG = Logger.getInstance(FieldBreakpoint.class);
  private boolean myIsStatic;

  @NonNls public static final Key<FieldBreakpoint> CATEGORY = BreakpointCategory.lookup("field_breakpoints");

  protected FieldBreakpoint(Project project, XBreakpoint breakpoint) {
    super(project, breakpoint);
  }

  private FieldBreakpoint(Project project, @NotNull String fieldName, XBreakpoint breakpoint) {
    super(project, breakpoint);
    setFieldName(fieldName);
  }

  public boolean isStatic() {
    return myIsStatic;
  }

  public @NlsSafe String getFieldName() {
    return getProperties().myFieldName;
  }

  @Override
  protected Icon getDisabledIcon(boolean isMuted) {
    if (DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().findMasterBreakpoint(this) != null && isMuted) {
      return AllIcons.Debugger.Db_muted_dep_field_breakpoint;
    }
    return null;
  }

  @Override
  protected Icon getVerifiedIcon(boolean isMuted) {
    return isSuspend() ? AllIcons.Debugger.Db_verified_field_breakpoint : AllIcons.Debugger.Db_verified_no_suspend_field_breakpoint;
  }

  @Override
  protected Icon getVerifiedWarningsIcon(boolean isMuted) {
    return new LayeredIcon(isMuted ? AllIcons.Debugger.Db_muted_field_breakpoint : AllIcons.Debugger.Db_field_breakpoint,
                           AllIcons.General.WarningDecorator);
  }

  @Override
  public Key<FieldBreakpoint> getCategory() {
    return CATEGORY;
  }

  public PsiField getPsiField() {
    final SourcePosition sourcePosition = getSourcePosition();
    try {
      PsiField field = ReadAction.compute(() -> {
        PsiClass psiClass = getPsiClassAt(sourcePosition);
        return psiClass != null ? psiClass.findFieldByName(getFieldName(), false) : null;
      });
      if (field != null) {
        return field;
      }
    }
    catch (IndexNotReadyException ignored) {
    }
    return PositionUtil.getPsiElementAt(myProject, PsiField.class, sourcePosition);
  }

  @Override
  public void reload() {
    super.reload();
    PsiField field = PositionUtil.getPsiElementAt(myProject, PsiField.class, getSourcePosition());
    if (field != null) {
      setFieldName(field.getName());
      PsiClass psiClass = field.getContainingClass();
      if (psiClass != null) {
        getProperties().myClassName = psiClass.getQualifiedName();
      }
      myIsStatic = SlowOperations.allowSlowOperations(() -> field.hasModifierProperty(PsiModifier.STATIC));
    }
    if (myIsStatic) {
      setInstanceFiltersEnabled(false);
    }
  }

  //@Override
  //public boolean moveTo(@NotNull SourcePosition position) {
  //  final PsiField field = PositionUtil.getPsiElementAt(getProject(), PsiField.class, position);
  //  return field != null && super.moveTo(SourcePosition.createFromElement(field));
  //}

  @Override
  protected ObjectReference getThisObject(SuspendContextImpl context, LocatableEvent event) throws EvaluateException {
    if (event instanceof ModificationWatchpointEvent) {
      ObjectReference reference = ((ModificationWatchpointEvent)event).object();
      if (reference != null) {  // non-static
        return reference;
      }
    }
    else if (event instanceof AccessWatchpointEvent) {
      ObjectReference reference = ((AccessWatchpointEvent)event).object();
      if (reference != null) { // non-static
        return reference;
      }
    }

    return super.getThisObject(context, event);
  }

  @Override
  public void createRequestForPreparedClass(DebugProcessImpl debugProcess,
                                            ReferenceType refType) {
    VirtualMachineProxy vm = debugProcess.getVirtualMachineProxy();
    try {
      RequestManagerImpl manager = debugProcess.getRequestsManager();
      Field field = refType.fieldByName(getFieldName());
      if (field == null) {
        manager.setInvalid(this, JavaDebuggerBundle.message("error.invalid.breakpoint.missing.field.in.class",
                                                            getFieldName(), refType.name()));
        return;
      }
      if (isWatchModification() && vm.canWatchFieldModification()) {
        manager.enableRequest(manager.createModificationWatchpointRequest(this, field));
        LOG.debug("Modification request added");
      }
      if (isWatchAccess() && vm.canWatchFieldAccess()) {
        manager.enableRequest(manager.createAccessWatchpointRequest(this, field));
        if (LOG.isDebugEnabled()) {
          LOG.debug("Access request added field = " + field.name() + "; refType = " + refType.name());
        }
      }
    }
    catch (Exception ex) {
      LOG.debug(ex);
    }
  }

  @Override
  public String getEventMessage(final LocatableEvent event) {
    final Location location = event.location();
    final String locationQName = DebuggerUtilsEx.getLocationMethodQName(location);
    String locationFileName = DebuggerUtilsEx.getSourceName(location, e -> getFileName());
    final int locationLine = location.lineNumber();

    if (event instanceof ModificationWatchpointEvent modificationEvent) {
      final ObjectReference object = modificationEvent.object();
      final Field field = modificationEvent.field();
      if (object != null) {
        return JavaDebuggerBundle.message(
          "status.field.watchpoint.reached.modification",
          field.declaringType().name(),
          field.name(),
          modificationEvent.valueCurrent(),
          modificationEvent.valueToBe(),
          locationQName,
          locationFileName,
          locationLine,
          object.uniqueID()
        );
      }
      return JavaDebuggerBundle.message(
        "status.static.field.watchpoint.reached.modification",
        field.declaringType().name(),
        field.name(),
        modificationEvent.valueCurrent(),
        modificationEvent.valueToBe(),
        locationQName,
        locationFileName,
        locationLine
      );
    }
    if (event instanceof AccessWatchpointEvent accessEvent) {
      final ObjectReference object = accessEvent.object();
      final Field field = accessEvent.field();
      if (object != null) {
        return JavaDebuggerBundle.message(
          "status.field.watchpoint.reached.access",
          field.declaringType().name(),
          field.name(),
          locationQName,
          locationFileName,
          locationLine,
          object.uniqueID()
        );
      }
      return JavaDebuggerBundle.message(
        "status.static.field.watchpoint.reached.access",
        field.declaringType().name(),
        field.name(),
        locationQName,
        locationFileName,
        locationLine
      );
    }
    return null;
  }

  @Override
  public String getDisplayName() {
    if (!isValid()) {
      return JavaDebuggerBundle.message("status.breakpoint.invalid");
    }
    final String className = getClassName();
    return className != null && !className.isEmpty() ? className + "." + getFieldName() : getFieldName();
  }

  public static FieldBreakpoint create(@NotNull Project project, String fieldName, XBreakpoint xBreakpoint) {
    FieldBreakpoint breakpoint = new FieldBreakpoint(project, fieldName, xBreakpoint);
    return (FieldBreakpoint)breakpoint.init();
  }

  //@Override
  //public boolean canMoveTo(final SourcePosition position) {
  //  return super.canMoveTo(position) && PositionUtil.getPsiElementAt(getProject(), PsiField.class, position) != null;
  //}

  @Override
  public boolean isValid() {
    return super.isValid() && getPsiField() != null;
  }

  @Override
  public boolean isAt(@NotNull Document document, int offset) {
    PsiField field = findField(myProject, document, offset);
    return field == getPsiField();
  }

  //protected static FieldBreakpoint create(@NotNull Project project, @NotNull Field field, ObjectReference object, XBreakpoint xBreakpoint) {
  //  String fieldName = field.name();
  //  int line = 0;
  //  Document document = null;
  //  try {
  //    List locations = field.declaringType().allLineLocations();
  //    if (!locations.isEmpty()) {
  //      Location location = (Location)locations.get(0);
  //      line = location.lineNumber();
  //      VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(location.sourcePath());
  //      if (file != null) {
  //        PsiFile psiFile = PsiManager.getInstance(project).findFile(file);
  //        if (psiFile != null) {
  //          document = PsiDocumentManager.getInstance(project).getDocument(psiFile);
  //        }
  //      }
  //    }
  //  }
  //  catch (AbsentInformationException e) {
  //    LOG.debug(e);
  //  }
  //  catch (InternalError e) {
  //    LOG.debug(e);
  //  }
  //
  //  if (document == null) return null;
  //
  //  FieldBreakpoint fieldBreakpoint = new FieldBreakpoint(project, createHighlighter(project, document, line), fieldName, xBreakpoint);
  //  if (!fieldBreakpoint.isStatic()) {
  //    fieldBreakpoint.addInstanceFilter(object.uniqueID());
  //  }
  //  return (FieldBreakpoint)fieldBreakpoint.init();
  //}

  public static PsiField findField(Project project, Document document, int offset) {
    PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(document);
    if (file == null) return null;
    offset = CharArrayUtil.shiftForward(document.getCharsSequence(), offset, " \t");
    PsiElement element = file.findElementAt(offset);
    if (element == null) return null;
    PsiField field = PsiTreeUtil.getParentOfType(element, PsiField.class, false);
    int line = document.getLineNumber(offset);
    if (field == null) {
      final PsiField[] fld = {null};
      XDebuggerUtil.getInstance().iterateLine(project, document, line, element1 -> {
        PsiField field1 = PsiTreeUtil.getParentOfType(element1, PsiField.class, false);
        if (field1 != null) {
          fld[0] = field1;
          return false;
        }
        return true;
      });
      field = fld[0];
    }

    return field;
  }

  @Override
  public void readExternal(@NotNull Element breakpointNode) throws InvalidDataException {
    super.readExternal(breakpointNode);
    setFieldName(breakpointNode.getAttributeValue("field_name"));
    if (getFieldName() == null) {
      throw new InvalidDataException("No field name for field breakpoint");
    }
    try {
      getProperties().WATCH_MODIFICATION = Boolean.parseBoolean(JDOMExternalizerUtil.readField(breakpointNode, "WATCH_MODIFICATION"));
    }
    catch (Exception ignored) {
    }
    try {
      getProperties().WATCH_ACCESS = Boolean.parseBoolean(JDOMExternalizerUtil.readField(breakpointNode, "WATCH_ACCESS"));
    }
    catch (Exception ignored) {
    }
  }
  //
  //@Override
  //@SuppressWarnings({"HardCodedStringLiteral"})
  //public void writeExternal(@NotNull Element parentNode) throws WriteExternalException {
  //  super.writeExternal(parentNode);
  //  parentNode.setAttribute("field_name", getFieldName());
  //}

  @Override
  public PsiElement getEvaluationElement() {
    return getPsiClass();
  }

  private boolean isWatchModification() {
    return getProperties().WATCH_MODIFICATION;
  }

  private boolean isWatchAccess() {
    return getProperties().WATCH_ACCESS;
  }

  void setFieldName(String fieldName) {
    getProperties().myFieldName = fieldName;
  }
}
/*
 * Copyright 2000-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.ui.IdeBorderFactory;
import com.intellij.util.ui.DialogUtil;
import com.intellij.xdebugger.breakpoints.XLineBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import com.intellij.xdebugger.impl.breakpoints.XBreakpointBase;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.java.debugger.breakpoints.properties.JavaFieldBreakpointProperties;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class FieldBreakpointPropertiesPanel extends XBreakpointCustomPropertiesPanel<XLineBreakpoint<JavaFieldBreakpointProperties>> {
  private JCheckBox myWatchAccessCheckBox;
  private JCheckBox myWatchModificationCheckBox;

  //public FieldBreakpointPropertiesPanel(final Project project, boolean compact) {
  //  super(project, FieldBreakpoint.CATEGORY, compact);
  //}


  @NotNull
  @Override
  public JComponent getComponent() {
    JPanel _panel;
    JPanel _panel0;
    myWatchAccessCheckBox = new JCheckBox(JavaDebuggerBundle.message("label.field.breakpoint.properties.panel.field.access"));
    myWatchModificationCheckBox = new JCheckBox(JavaDebuggerBundle.message("label.field.breakpoint.properties.panel.field.modification"));
    DialogUtil.registerMnemonic(myWatchAccessCheckBox);
    DialogUtil.registerMnemonic(myWatchModificationCheckBox);


    Box watchBox = Box.createVerticalBox();
    _panel = new JPanel(new BorderLayout());
    _panel.add(myWatchAccessCheckBox, BorderLayout.NORTH);
    watchBox.add(_panel);
    _panel = new JPanel(new BorderLayout());
    _panel.add(myWatchModificationCheckBox, BorderLayout.NORTH);
    watchBox.add(_panel);

    _panel = new JPanel(new BorderLayout());
    _panel0 = new JPanel(new BorderLayout());
    _panel0.add(watchBox, BorderLayout.CENTER);
    _panel0.add(Box.createHorizontalStrut(3), BorderLayout.WEST);
    _panel0.add(Box.createHorizontalStrut(3), BorderLayout.EAST);
    _panel.add(_panel0, BorderLayout.NORTH);
    _panel.setBorder(IdeBorderFactory.createTitledBorder(JavaDebuggerBundle.message("label.group.watch.events")));

    ActionListener listener = new ActionListener() {
      @Override
      public void actionPerformed(ActionEvent e) {
        JCheckBox toCheck = null;
        if (!myWatchAccessCheckBox.isSelected() && !myWatchModificationCheckBox.isSelected()) {
          Object source = e.getSource();
          if (myWatchAccessCheckBox.equals(source)) {
            toCheck = myWatchModificationCheckBox;
          }
          else if (myWatchModificationCheckBox.equals(source)) {
            toCheck = myWatchAccessCheckBox;
          }
          if (toCheck != null) {
            toCheck.setSelected(true);
          }
        }
      }
    };
    myWatchAccessCheckBox.addActionListener(listener);
    myWatchModificationCheckBox.addActionListener(listener);

    return _panel;
  }

  @Override
  public void loadFrom(@NotNull XLineBreakpoint<JavaFieldBreakpointProperties> breakpoint) {
    myWatchAccessCheckBox.setSelected(breakpoint.getProperties().WATCH_ACCESS);
    myWatchModificationCheckBox.setSelected(breakpoint.getProperties().WATCH_MODIFICATION);
  }

  @Override
  public void saveTo(@NotNull XLineBreakpoint<JavaFieldBreakpointProperties> breakpoint) {
    boolean changed = breakpoint.getProperties().WATCH_ACCESS != myWatchAccessCheckBox.isSelected();
    breakpoint.getProperties().WATCH_ACCESS = myWatchAccessCheckBox.isSelected();
    changed = breakpoint.getProperties().WATCH_MODIFICATION != myWatchModificationCheckBox.isSelected() || changed;
    breakpoint.getProperties().WATCH_MODIFICATION = myWatchModificationCheckBox.isSelected();
    if (changed) {
      ((XBreakpointBase<?, ?, ?>)breakpoint).fireBreakpointChanged();
    }
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.InstanceFilter;
import com.intellij.debugger.engine.requests.LocatableEventRequestor;
import com.intellij.ui.classFilter.ClassFilter;

public interface FilteredRequestor extends LocatableEventRequestor {
  @Override
  String getSuspendPolicy();

  boolean isInstanceFiltersEnabled();

  InstanceFilter[] getInstanceFilters();

  boolean isCountFilterEnabled();

  int getCountFilter();

  boolean isClassFiltersEnabled();

  ClassFilter[] getClassFilters();

  ClassFilter[] getClassExclusionFilters();

  default boolean isConditionEnabled() {
    return false;
  }
}
// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.InstanceFilter;
import com.intellij.debugger.engine.evaluation.CodeFragmentKind;
import com.intellij.debugger.engine.evaluation.TextWithImports;
import com.intellij.debugger.engine.evaluation.TextWithImportsImpl;
import com.intellij.debugger.engine.events.SuspendContextCommandImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.settings.DebuggerSettings;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.*;
import com.intellij.ui.classFilter.ClassFilter;
import com.intellij.xdebugger.impl.XDebuggerHistoryManager;
import com.intellij.xdebugger.impl.breakpoints.XBreakpointBase;
import com.intellij.xdebugger.impl.breakpoints.ui.XLightBreakpointPropertiesPanel;
import com.sun.jdi.event.LocatableEvent;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.List;

/*
 * Not used any more, since move to xBreakpoints
 */
public class FilteredRequestorImpl implements JDOMExternalizable, FilteredRequestor {

  public String SUSPEND_POLICY = DebuggerSettings.SUSPEND_ALL;
  public boolean SUSPEND = true;

  public boolean COUNT_FILTER_ENABLED = false;
  public int COUNT_FILTER = 0;

  public boolean CONDITION_ENABLED = false;
  private TextWithImports myCondition;

  public boolean CLASS_FILTERS_ENABLED = false;
  private ClassFilter[] myClassFilters = ClassFilter.EMPTY_ARRAY;
  private ClassFilter[] myClassExclusionFilters = ClassFilter.EMPTY_ARRAY;

  public boolean INSTANCE_FILTERS_ENABLED = false;
  private InstanceFilter[] myInstanceFilters = InstanceFilter.EMPTY_ARRAY;

  @NonNls private static final String FILTER_OPTION_NAME = "filter";
  @NonNls private static final String EXCLUSION_FILTER_OPTION_NAME = "exclusion_filter";
  @NonNls private static final String INSTANCE_ID_OPTION_NAME = "instance_id";
  @NonNls private static final String CONDITION_OPTION_NAME = "CONDITION";
  protected final Project myProject;

  public FilteredRequestorImpl(@NotNull Project project) {
    myProject = project;
    myCondition = new TextWithImportsImpl(CodeFragmentKind.EXPRESSION, "");
  }

  @Override
  public InstanceFilter[] getInstanceFilters() {
    return myInstanceFilters;
  }

  public void setInstanceFilters(InstanceFilter[] instanceFilters) {
    myInstanceFilters = instanceFilters != null ? instanceFilters : InstanceFilter.EMPTY_ARRAY;
  }

  @Override
  public String getSuspendPolicy() {
    return SUSPEND ? SUSPEND_POLICY : DebuggerSettings.SUSPEND_NONE;
  }

  @Override
  public final ClassFilter[] getClassFilters() {
    return myClassFilters;
  }

  public final void setClassFilters(ClassFilter[] classFilters) {
    myClassFilters = classFilters != null ? classFilters : ClassFilter.EMPTY_ARRAY;
  }

  @Override
  public ClassFilter[] getClassExclusionFilters() {
    return myClassExclusionFilters;
  }

  public void setClassExclusionFilters(ClassFilter[] classExclusionFilters) {
    myClassExclusionFilters = classExclusionFilters != null ? classExclusionFilters : ClassFilter.EMPTY_ARRAY;
  }

  public void readTo(Element parentNode, Breakpoint breakpoint) throws InvalidDataException {
    readExternal(parentNode);
    if (SUSPEND) {
      breakpoint.setSuspendPolicy(SUSPEND_POLICY);
    }
    else {
      breakpoint.setSuspendPolicy(DebuggerSettings.SUSPEND_NONE);
    }

    breakpoint.setCountFilterEnabled(COUNT_FILTER_ENABLED);
    breakpoint.setCountFilter(COUNT_FILTER);

    breakpoint.setCondition(myCondition);
    ((XBreakpointBase<?, ?, ?>)breakpoint.myXBreakpoint).setConditionEnabled(CONDITION_ENABLED);
    if (myCondition != null && !myCondition.isEmpty()) {
      XDebuggerHistoryManager.getInstance(myProject).addRecentExpression(XLightBreakpointPropertiesPanel.CONDITION_HISTORY_ID, TextWithImportsImpl.toXExpression(myCondition));
    }

    breakpoint.setClassFiltersEnabled(CLASS_FILTERS_ENABLED);
    breakpoint.setClassFilters(getClassFilters());
    breakpoint.setClassExclusionFilters(getClassExclusionFilters());

    breakpoint.setInstanceFiltersEnabled(INSTANCE_FILTERS_ENABLED);
    breakpoint.setInstanceFilters(getInstanceFilters());
  }

  @Override
  public void readExternal(Element parentNode) throws InvalidDataException {
    DefaultJDOMExternalizer.readExternal(this, parentNode);
    if (DebuggerSettings.SUSPEND_NONE.equals(SUSPEND_POLICY)) { // compatibility with older format
      SUSPEND = false;
      SUSPEND_POLICY = DebuggerSettings.SUSPEND_ALL;
    }
    String condition = JDOMExternalizerUtil.readField(parentNode, CONDITION_OPTION_NAME);
    if (condition != null) {
      setCondition(new TextWithImportsImpl(CodeFragmentKind.EXPRESSION, condition));
    }

    myClassFilters = DebuggerUtilsEx.readFilters(parentNode.getChildren(FILTER_OPTION_NAME));
    myClassExclusionFilters = DebuggerUtilsEx.readFilters(parentNode.getChildren(EXCLUSION_FILTER_OPTION_NAME));

    final ClassFilter[] instanceFilters = DebuggerUtilsEx.readFilters(parentNode.getChildren(INSTANCE_ID_OPTION_NAME));
    final List<InstanceFilter> iFilters = new ArrayList<>(instanceFilters.length);

    for (ClassFilter instanceFilter : instanceFilters) {
      try {
        iFilters.add(InstanceFilter.create(instanceFilter));
      }
      catch (Exception ignored) {
      }
    }
    myInstanceFilters = iFilters.isEmpty() ? InstanceFilter.EMPTY_ARRAY : iFilters.toArray(InstanceFilter.EMPTY_ARRAY);
  }

  @Override
  public void writeExternal(Element parentNode) throws WriteExternalException {
    DefaultJDOMExternalizer.writeExternal(this, parentNode);
    JDOMExternalizerUtil.writeField(parentNode, CONDITION_OPTION_NAME, getCondition().toExternalForm());
    DebuggerUtilsEx.writeFilters(parentNode, FILTER_OPTION_NAME, myClassFilters);
    DebuggerUtilsEx.writeFilters(parentNode, EXCLUSION_FILTER_OPTION_NAME, myClassExclusionFilters);
    DebuggerUtilsEx.writeFilters(parentNode, INSTANCE_ID_OPTION_NAME, InstanceFilter.createClassFilters(myInstanceFilters));
  }

  public TextWithImports getCondition() {
    return myCondition;
  }

  public void setCondition(TextWithImports condition) {
    myCondition = condition;
  }

  public Project getProject() {
    return myProject;
  }

  @Override
  public boolean isCountFilterEnabled() {
    return COUNT_FILTER_ENABLED;
  }

  @Override
  public int getCountFilter() {
    return COUNT_FILTER;
  }

  @Override
  public boolean isClassFiltersEnabled() {
    return CLASS_FILTERS_ENABLED;
  }

  @Override
  public boolean isInstanceFiltersEnabled() {
    return INSTANCE_FILTERS_ENABLED;
  }

  @Override
  public boolean processLocatableEvent(@NotNull SuspendContextCommandImpl action, LocatableEvent event)
    throws EventProcessingException {
    return false;
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.events.SuspendContextCommandImpl;
import com.intellij.debugger.engine.requests.RequestManagerImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.requests.Requestor;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.util.ReflectionUtil;
import com.intellij.util.containers.ContainerUtil;
import com.jetbrains.jdi.ReferenceTypeImpl;
import com.jetbrains.jdi.VirtualMachineImpl;
import com.sun.jdi.*;
import com.sun.jdi.event.LocatableEvent;
import one.util.streamex.StreamEx;
import org.jetbrains.annotations.NotNull;

import java.lang.reflect.InaccessibleObjectException;
import java.lang.reflect.InvocationTargetException;
import java.util.List;

public final class InstrumentationTracker {
  private static final Logger LOG = Logger.getInstance(InstrumentationTracker.class);

  @SuppressWarnings("FieldCanBeLocal") private final InstrumentationMethodBreakpoint myRedefineBreakpoint;
  @SuppressWarnings("FieldCanBeLocal") private final InstrumentationMethodBreakpoint myRetransformBreakpoint;
  @NotNull private final DebugProcessImpl myDebugProcess;

  private static final java.lang.reflect.Method ourNoticeRedefineClassMethod;

  static {
    java.lang.reflect.Method redefineMethod = null;
    try {
      redefineMethod = ReflectionUtil.getDeclaredMethod(Class.forName("com.sun.tools.jdi.ReferenceTypeImpl"), "noticeRedefineClass");
    }
    catch (ClassNotFoundException | InaccessibleObjectException e) {
      LOG.warn(e);
    }
    ourNoticeRedefineClassMethod = redefineMethod;
  }

  public static void track(DebugProcessImpl debugProcess) {
    if (ourNoticeRedefineClassMethod != null || debugProcess.getVirtualMachineProxy().getVirtualMachine() instanceof VirtualMachineImpl) {
      new InstrumentationTracker(debugProcess);
    }
  }

  private InstrumentationTracker(DebugProcessImpl debugProcess) {
    myRedefineBreakpoint =
      new InstrumentationMethodBreakpoint(debugProcess.getProject(), "sun.instrument.InstrumentationImpl", "redefineClasses") {
        @Override
        public boolean processLocatableEvent(@NotNull SuspendContextCommandImpl action, LocatableEvent event) {
          try {
            Value value = ContainerUtil.getFirstItem(DebuggerUtilsEx.getArgumentValues(event.thread().frame(0)));
            if (value instanceof ArrayReference) {
              ((ArrayReference)value).getValues().forEach(v -> {
                Value aClass = ((ObjectReference)v).getValue(((ReferenceType)v.type()).fieldByName("mClass"));
                noticeRedefineClass(((ClassObjectReference)aClass).reflectedType());
              });
            }
          }
          catch (IncompatibleThreadStateException e) {
            LOG.warn(e);
          }
          return false;
        }
      };
    myRetransformBreakpoint =
      new InstrumentationMethodBreakpoint(debugProcess.getProject(), "sun.instrument.InstrumentationImpl", "retransformClasses") {
        @Override
        public boolean processLocatableEvent(@NotNull SuspendContextCommandImpl action, LocatableEvent event) {
          try {
            Value value = ContainerUtil.getFirstItem(DebuggerUtilsEx.getArgumentValues(event.thread().frame(0)));
            if (value instanceof ArrayReference) {
              ((ArrayReference)value).getValues().forEach(v -> noticeRedefineClass(((ClassObjectReference)v).reflectedType()));
            }
          }
          catch (IncompatibleThreadStateException e) {
            LOG.warn(e);
          }
          return false;
        }
      };
    myDebugProcess = debugProcess;

    myRedefineBreakpoint.createRequest(debugProcess);
    myRetransformBreakpoint.createRequest(debugProcess);
  }

  private void noticeRedefineClass(ReferenceType type) {
    if (!(type instanceof ReferenceTypeImpl) && !ourNoticeRedefineClassMethod.getDeclaringClass().isAssignableFrom(type.getClass())) {
      return;
    }
    List<Requestor> requestors = StreamEx.of(type.virtualMachine().eventRequestManager().breakpointRequests())
      .filter(r -> type.equals(r.location().declaringType()))
      .map(RequestManagerImpl::findRequestor)
      .toList();
    requestors.forEach(myDebugProcess.getRequestsManager()::deleteRequest);

    if (type instanceof ReferenceTypeImpl) {
      ((ReferenceTypeImpl)type).noticeRedefineClass();
    }
    else {
      try {
        ourNoticeRedefineClassMethod.invoke(type);
      }
      catch (IllegalAccessException | InvocationTargetException e) {
        LOG.error(e);
      }
    }

    StreamEx.of(requestors).select(Breakpoint.class).forEach(b -> b.createRequest(myDebugProcess));
  }

  public static class InstrumentationMethodBreakpoint extends SyntheticLineBreakpoint {
    private final String myClassName;
    private final String myMethodName;

    public InstrumentationMethodBreakpoint(@NotNull Project project, String className, String methodName) {
      super(project);
      myClassName = className;
      myMethodName = methodName;
    }

    @Override
    public void createRequest(@NotNull DebugProcessImpl debugProcess) {
      createOrWaitPrepare(debugProcess, myClassName);
    }

    @Override
    protected void createRequestForPreparedClass(DebugProcessImpl debugProcess, ReferenceType classType) {
      for (Method method : DebuggerUtilsEx.declaredMethodsByName(classType, myMethodName)) {
        createRequestInMethod(debugProcess, method);
      }
    }

    protected void createRequestInMethod(DebugProcessImpl debugProcess, Method method) {
      try {
        Location location = ContainerUtil.getLastItem(method.allLineLocations());
        BreakpointWithHighlighter.createLocationBreakpointRequest(this, location, debugProcess);
      }
      catch (AbsentInformationException ignored) {
      }
    }

    @Override
    public String getDisplayName() {
      return JavaDebuggerBundle.message("label.instrumentation.tracker", myMethodName);
    }
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.breakpoints

import com.intellij.internal.statistic.eventLog.EventLogGroup
import com.intellij.internal.statistic.eventLog.events.EventFields
import com.intellij.internal.statistic.eventLog.events.EventPair
import com.intellij.internal.statistic.service.fus.collectors.CounterUsagesCollector
import com.intellij.internal.statistic.utils.getPluginInfo
import com.intellij.xdebugger.breakpoints.XBreakpointType
import org.jetbrains.java.debugger.breakpoints.properties.JavaLineBreakpointProperties

object JavaBreakpointsUsageCollector : CounterUsagesCollector() {
  private enum class LineBreakpointKind {
    LINE,
    LAMBDA,
    LINE_AND_LAMBDAS,
    RETURN,
  }

  private val GROUP = EventLogGroup("debugger.breakpoints.usage.java", 1)
  private val LINE_BREAKPOINT_KIND_FIELD = EventFields.Enum<LineBreakpointKind>("kind")
  private val LINE_BREAKPOINT_ADDED = GROUP.registerEvent("line.breakpoint.added",
                                                          EventFields.PluginInfo, LINE_BREAKPOINT_KIND_FIELD)

  @JvmStatic
  fun reportNewBreakpoint(breakpoint: Breakpoint<*>, type: XBreakpointType<*, *>) {
    val properties = breakpoint.properties
    if (type is JavaLineBreakpointType && properties is JavaLineBreakpointProperties) {
      val pluginInfo = getPluginInfo(type.javaClass)
      val lambdaOrdinal = properties.lambdaOrdinal
      val kind = when {
        properties.isConditionalReturn -> LineBreakpointKind.RETURN
        lambdaOrdinal == null -> LineBreakpointKind.LINE_AND_LAMBDAS
        lambdaOrdinal >= 0 -> LineBreakpointKind.LAMBDA
        else -> LineBreakpointKind.LINE
      }

      LINE_BREAKPOINT_ADDED.log(breakpoint.project, pluginInfo, kind)
    }
  }

  override fun getGroup(): EventLogGroup = GROUP
}
/*
 * Copyright 2000-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.openapi.project.Project;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties;

/**
 * Base class for all Java breakpoint types
 *
 * @author egor
 */
public interface JavaBreakpointType<P extends JavaBreakpointProperties> {
  @NotNull
  Breakpoint<P> createJavaBreakpoint(Project project, XBreakpoint<P> breakpoint);
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.project.Project;
import com.intellij.psi.PsiClass;
import com.intellij.xdebugger.XDebugSession;
import com.intellij.xdebugger.XDebuggerUtil;
import com.intellij.xdebugger.XSourcePosition;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.XBreakpointType;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import com.intellij.xdebugger.evaluation.XDebuggerEditorsProvider;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.JavaDebuggerEditorsProvider;
import org.jetbrains.java.debugger.breakpoints.JavaBreakpointFiltersPanel;
import org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties;

import java.util.List;

/**
 * Base class for non-line java breakpoint
 *
 * @author egor
 */
public abstract class JavaBreakpointTypeBase<T extends JavaBreakpointProperties> extends XBreakpointType<XBreakpoint<T>, T>
  implements JavaBreakpointType<T> {
  protected JavaBreakpointTypeBase(@NonNls @NotNull String id, @Nls @NotNull String title) {
    super(id, title, true);
  }

  @Override
  public final boolean isAddBreakpointButtonVisible() {
    return true;
  }

  @NotNull
  @Override
  public final XBreakpointCustomPropertiesPanel<XBreakpoint<T>> createCustomRightPropertiesPanel(@NotNull Project project) {
    return new JavaBreakpointFiltersPanel<>(project);
  }

  @NotNull
  @Override
  public final XDebuggerEditorsProvider getEditorsProvider(@NotNull XBreakpoint<T> breakpoint, @NotNull Project project) {
    return new JavaDebuggerEditorsProvider();
  }

  @Nullable
  @Override
  public XSourcePosition getSourcePosition(@NotNull XBreakpoint<T> breakpoint) {
    Breakpoint javaBreakpoint = BreakpointManager.getJavaBreakpoint(breakpoint);
    if (javaBreakpoint != null) {
      PsiClass aClass = javaBreakpoint.getPsiClass();
      if (aClass != null) {
        return ReadAction.compute(() -> XDebuggerUtil.getInstance().createPositionByElement(aClass));
      }
    }
    return null;
  }

  @Override
  public List<? extends AnAction> getAdditionalPopupMenuActions(@NotNull XBreakpoint<T> breakpoint,
                                                                @Nullable XDebugSession currentSession) {
    return BreakpointIntentionAction.getIntentions(breakpoint, currentSession);
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.HelpID;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.WriteAction;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Ref;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.*;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.xdebugger.XDebuggerManager;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.XLineBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import com.siyeh.ig.psiutils.CollectionUtils;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaCollectionBreakpointProperties;
import org.jetbrains.java.debugger.breakpoints.properties.JavaFieldBreakpointProperties;

import javax.swing.*;

@ApiStatus.Experimental
public class JavaCollectionBreakpointType extends JavaLineBreakpointTypeBase<JavaCollectionBreakpointProperties> {

  public JavaCollectionBreakpointType() {
    super("java-collection", JavaDebuggerBundle.message("collection.watchpoints.tab.title"));
  }

  @Override
  public boolean isAddBreakpointButtonVisible() {
    return Registry.is("debugger.collection.watchpoints.enabled");
  }

  @NotNull
  @Override
  public Icon getEnabledIcon() {
    return AllIcons.Debugger.Db_field_breakpoint;
  }

  @NotNull
  @Override
  public Icon getDisabledIcon() {
    return AllIcons.Debugger.Db_disabled_field_breakpoint;
  }

  @NotNull
  @Override
  public Icon getSuspendNoneIcon() {
    return AllIcons.Debugger.Db_no_suspend_field_breakpoint;
  }

  @NotNull
  @Override
  public Icon getMutedEnabledIcon() {
    return AllIcons.Debugger.Db_muted_field_breakpoint;
  }

  @NotNull
  @Override
  public Icon getMutedDisabledIcon() {
    return AllIcons.Debugger.Db_muted_disabled_field_breakpoint;
  }

  @NotNull
  @Override
  public Icon getInactiveDependentIcon() {
    return AllIcons.Debugger.Db_dep_field_breakpoint;
  }

  @Override
  public @Nullable XBreakpointCustomPropertiesPanel<XLineBreakpoint<JavaCollectionBreakpointProperties>> createCustomConditionsPanel() {
    return new CollectionBreakpointPropertiesPanel();
  }

  //@Override
  protected String getHelpID() {
    return HelpID.COLLECTION_WATCHPOINTS;
  }

  //@Override
  public String getDisplayName() {
    return JavaDebuggerBundle.message("collection.watchpoints.tab.title");
  }


  @Nls
  public String getText(XLineBreakpoint<JavaFieldBreakpointProperties> breakpoint) {
    JavaFieldBreakpointProperties properties = breakpoint.getProperties();
    final String className = properties.myClassName;
    return className != null && !className.isEmpty() ? className + "." + properties.myFieldName : properties.myFieldName;
  }

  @Nullable
  @Override
  public JavaCollectionBreakpointProperties createProperties() {
    return new JavaCollectionBreakpointProperties();
  }

  @Nullable
  @Override
  public JavaCollectionBreakpointProperties createBreakpointProperties(@NotNull VirtualFile file, int line) {
    return new JavaCollectionBreakpointProperties();
  }

  @NotNull
  @Override
  public Breakpoint<JavaCollectionBreakpointProperties> createJavaBreakpoint(Project project, XBreakpoint breakpoint) {
    return new CollectionBreakpoint(project, breakpoint);
  }

  @Override
  public boolean canBeHitInOtherPlaces() {
    return true;
  }

  @Override
  public boolean canPutAt(@NotNull VirtualFile file, int line, @NotNull Project project) {
    if (!Registry.is("debugger.collection.watchpoints.enabled")) {
      return false;
    }
    return canPutAtElement(file, line, project, (element, document) -> {
      if (element instanceof PsiField) {
        boolean isFinal = ((PsiField)element).hasModifierProperty(PsiModifier.FINAL);
        boolean isPrivate = ((PsiField)element).hasModifierProperty(PsiModifier.PRIVATE);
        boolean isProtected = ((PsiField)element).hasModifierProperty(PsiModifier.PROTECTED);
        boolean hasValidModifiers = isFinal || isPrivate || isProtected;
        PsiType type = ((PsiField)element).getType();
        return hasValidModifiers && CollectionUtils.isCollectionClassOrInterface(type);
      }
      return false;
    });
  }

  @Nullable
  @Override
  public XLineBreakpoint<JavaCollectionBreakpointProperties> addBreakpoint(final Project project, JComponent parentComponent) {
    final Ref<XLineBreakpoint<JavaCollectionBreakpointProperties>> result = Ref.create(null);
    AddFieldBreakpointDialog dialog = new AddFieldBreakpointDialog(project) {
      @Override
      protected boolean validateData() {
        final String className = getClassName();
        if (className.length() == 0) {
          return false;
        }
        final String fieldName = getFieldName();
        if (fieldName.length() == 0) {
          return false;
        }
        PsiClass psiClass = JavaPsiFacade.getInstance(project).findClass(className, GlobalSearchScope.allScope(project));
        if (psiClass != null) {
          final PsiFile psiFile = psiClass.getContainingFile();
          Document document = PsiDocumentManager.getInstance(project).getDocument(psiFile);
          if (document != null) {
            PsiField field = psiClass.findFieldByName(fieldName, false);
            if (field != null) {
              final int line = document.getLineNumber(field.getTextOffset());
              WriteAction.run(() -> {
                XLineBreakpoint<JavaCollectionBreakpointProperties> fieldBreakpoint =
                  XDebuggerManager.getInstance(project).getBreakpointManager()
                    .addLineBreakpoint(JavaCollectionBreakpointType.this, psiFile.getVirtualFile().getUrl(), line,
                                       new JavaCollectionBreakpointProperties(fieldName, className));
                result.set(fieldBreakpoint);
              });
              return true;
            }
          }
        }
        return false;
      }
    };
    dialog.show();
    return result.get();
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.HelpID;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.JVMNameUtil;
import com.intellij.icons.AllIcons;
import com.intellij.ide.util.TreeClassChooser;
import com.intellij.ide.util.TreeClassChooserFactory;
import com.intellij.openapi.application.WriteAction;
import com.intellij.openapi.project.Project;
import com.intellij.psi.CommonClassNames;
import com.intellij.psi.JavaPsiFacade;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiClassOwner;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.xdebugger.XDebuggerManager;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaExceptionBreakpointProperties;

import javax.swing.*;

/**
 * @author Eugene Zhuravlev
 */
public class JavaExceptionBreakpointType extends JavaBreakpointTypeBase<JavaExceptionBreakpointProperties> {
  public JavaExceptionBreakpointType() {
    super("java-exception", JavaDebuggerBundle.message("exception.breakpoints.tab.title"));
  }

  @NotNull
  @Override
  public Icon getEnabledIcon() {
    return AllIcons.Debugger.Db_exception_breakpoint;
  }

  @NotNull
  @Override
  public Icon getDisabledIcon() {
    return AllIcons.Debugger.Db_disabled_exception_breakpoint;
  }

  @NotNull
  @Override
  public Icon getMutedEnabledIcon() {
    return AllIcons.Debugger.Db_exception_breakpoint;
  }

  @NotNull
  @Override
  public Icon getMutedDisabledIcon() {
    return AllIcons.Debugger.Db_exception_breakpoint;
  }

  //@Override
  protected String getHelpID() {
    return HelpID.EXCEPTION_BREAKPOINTS;
  }

  //@Override
  public String getDisplayName() {
    return JavaDebuggerBundle.message("exception.breakpoints.tab.title");
  }

  @Override
  public String getDisplayText(XBreakpoint<JavaExceptionBreakpointProperties> breakpoint) {
    String name = breakpoint.getProperties().myQualifiedName;
    if (name != null) {
      return JavaDebuggerBundle.message("breakpoint.exception.breakpoint.display.name", name);
    }
    else {
      return JavaDebuggerBundle.message("breakpoint.any.exception.display.name");
    }
  }

  @Nullable
  @Override
  public JavaExceptionBreakpointProperties createProperties() {
    return new JavaExceptionBreakpointProperties();
  }

  @Nullable
  @Override
  public XBreakpointCustomPropertiesPanel<XBreakpoint<JavaExceptionBreakpointProperties>> createCustomPropertiesPanel(@NotNull Project project) {
    return new ExceptionBreakpointPropertiesPanel();
  }

  @Nullable
  @Override
  public XBreakpoint<JavaExceptionBreakpointProperties> createDefaultBreakpoint(@NotNull XBreakpointCreator<JavaExceptionBreakpointProperties> creator) {
    return creator.createBreakpoint(new JavaExceptionBreakpointProperties());
  }

  //public Key<ExceptionBreakpoint> getBreakpointCategory() {
  //  return ExceptionBreakpoint.CATEGORY;
  //}

  @Nullable
  @Override
  public XBreakpoint<JavaExceptionBreakpointProperties> addBreakpoint(final Project project, JComponent parentComponent) {
    final PsiClass throwableClass =
      JavaPsiFacade.getInstance(project).findClass(CommonClassNames.JAVA_LANG_THROWABLE, GlobalSearchScope.allScope(project));
    TreeClassChooser chooser = TreeClassChooserFactory.getInstance(project)
      .createInheritanceClassChooser(JavaDebuggerBundle.message("add.exception.breakpoint.classchooser.title"),
                                     GlobalSearchScope.allScope(project), throwableClass, true, true, null);
    chooser.showDialog();
    final PsiClass selectedClass = chooser.getSelected();
    final String qName = selectedClass == null ? null : JVMNameUtil.getNonAnonymousClassName(selectedClass);

    if (qName != null && qName.length() > 0) {
      return WriteAction.compute(() -> XDebuggerManager.getInstance(project).getBreakpointManager()
        .addBreakpoint(this, new JavaExceptionBreakpointProperties(qName, ((PsiClassOwner)selectedClass.getContainingFile()).getPackageName())));
    }
    return null;
  }

  @NotNull
  @Override
  public Breakpoint<JavaExceptionBreakpointProperties> createJavaBreakpoint(Project project, XBreakpoint<JavaExceptionBreakpointProperties> breakpoint) {
    if (!XDebuggerManager.getInstance(project).getBreakpointManager().isDefaultBreakpoint(breakpoint)) {
      return new ExceptionBreakpoint(project, breakpoint);
    }
    else {
      return new AnyExceptionBreakpoint(project, breakpoint);
    }
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.CommonBundle;
import com.intellij.debugger.HelpID;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.WriteAction;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.util.Ref;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.*;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.util.ClassUtil;
import com.intellij.xdebugger.XDebuggerManager;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.XLineBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaFieldBreakpointProperties;

import javax.swing.*;

/**
 * @author Eugene Zhuravlev
 */
public class JavaFieldBreakpointType extends JavaLineBreakpointTypeBase<JavaFieldBreakpointProperties> {
  public JavaFieldBreakpointType() {
    super("java-field", JavaDebuggerBundle.message("field.watchpoints.tab.title"));
  }

  @Override
  public boolean isAddBreakpointButtonVisible() {
    return true;
  }

  @NotNull
  @Override
  public Icon getEnabledIcon() {
    return AllIcons.Debugger.Db_field_breakpoint;
  }

  @NotNull
  @Override
  public Icon getDisabledIcon() {
    return AllIcons.Debugger.Db_disabled_field_breakpoint;
  }

  @NotNull
  @Override
  public Icon getSuspendNoneIcon() {
    return AllIcons.Debugger.Db_no_suspend_field_breakpoint;
  }

  @NotNull
  @Override
  public Icon getMutedEnabledIcon() {
    return AllIcons.Debugger.Db_muted_field_breakpoint;
  }

  @NotNull
  @Override
  public Icon getMutedDisabledIcon() {
    return AllIcons.Debugger.Db_muted_disabled_field_breakpoint;
  }

  @NotNull
  @Override
  public Icon getInactiveDependentIcon() {
    return AllIcons.Debugger.Db_dep_field_breakpoint;
  }

  //@Override
  protected String getHelpID() {
    return HelpID.FIELD_WATCHPOINTS;
  }

  //@Override
  public String getDisplayName() {
    return JavaDebuggerBundle.message("field.watchpoints.tab.title");
  }

  @Override
  public String getShortText(XLineBreakpoint<JavaFieldBreakpointProperties> breakpoint) {
    return getText(breakpoint, true);
  }

  @Nls
  public String getText(XLineBreakpoint<JavaFieldBreakpointProperties> breakpoint) {
    return getText(breakpoint, false);
  }

  @Nls
  private static String getText(XBreakpoint<JavaFieldBreakpointProperties> breakpoint, boolean simple) {
    //if (!isValid()) {
    //  return JavaDebuggerBundle.message("status.breakpoint.invalid");
    //}

    JavaFieldBreakpointProperties properties = breakpoint.getProperties();
    String className = properties.myClassName;
    if (className == null || className.isEmpty()) return properties.myFieldName;
    String displayedClassName = simple ? ClassUtil.extractClassName(className) : className;
    return displayedClassName + "." + properties.myFieldName;
  }

  @Nullable
  @Override
  public XBreakpointCustomPropertiesPanel<XLineBreakpoint<JavaFieldBreakpointProperties>> createCustomPropertiesPanel(@NotNull Project project) {
    return new FieldBreakpointPropertiesPanel();
  }

  @Nullable
  @Override
  public JavaFieldBreakpointProperties createProperties() {
    return new JavaFieldBreakpointProperties();
  }

  @Nullable
  @Override
  public JavaFieldBreakpointProperties createBreakpointProperties(@NotNull VirtualFile file, int line) {
    return new JavaFieldBreakpointProperties();
  }

  @Nullable
  @Override
  public XLineBreakpoint<JavaFieldBreakpointProperties> addBreakpoint(Project project, JComponent parentComponent) {
    Ref<XLineBreakpoint<JavaFieldBreakpointProperties>> result = Ref.create(null);
    AddFieldBreakpointDialog dialog = new AddFieldBreakpointDialog(project) {
      @Override
      protected boolean validateData() {
        String className = getClassName();
        if (className.isEmpty()) {
          Messages.showMessageDialog(
            project,
            JavaDebuggerBundle.message("error.field.breakpoint.class.name.not.specified"),
            JavaDebuggerBundle.message("add.field.breakpoint.dialog.title"),
            Messages.getErrorIcon()
          );
          return false;
        }
        String fieldName = getFieldName();
        if (fieldName.isEmpty()) {
          Messages.showMessageDialog(
            project,
            JavaDebuggerBundle.message("error.field.breakpoint.field.name.not.specified"),
            JavaDebuggerBundle.message("add.field.breakpoint.dialog.title"),
            Messages.getErrorIcon()
          );
          return false;
        }
        PsiClass psiClass = JavaPsiFacade.getInstance(project).findClass(className, GlobalSearchScope.allScope(project));
        if (psiClass == null) {
          Messages.showMessageDialog(
            project,
            JavaDebuggerBundle.message("error.field.breakpoint.class.sources.not.found", className, fieldName, className),
            CommonBundle.getErrorTitle(),
            Messages.getErrorIcon()
          );
          return false;
        }
        PsiFile psiFile = psiClass.getContainingFile();
        Document document = PsiDocumentManager.getInstance(project).getDocument(psiFile);
        if (document == null) {
          return false;
        }
        PsiField field = psiClass.findFieldByName(fieldName, false);
        if (field == null) {
          Messages.showMessageDialog(
            project,
            JavaDebuggerBundle.message("error.field.breakpoint.field.not.found", className, fieldName, fieldName),
            CommonBundle.getErrorTitle(),
            Messages.getErrorIcon()
          );
          return false;
        }
        int line = document.getLineNumber(field.getTextOffset());
        WriteAction.run(() -> {
          XLineBreakpoint<JavaFieldBreakpointProperties> fieldBreakpoint =
            XDebuggerManager.getInstance(project).getBreakpointManager().addLineBreakpoint(
              JavaFieldBreakpointType.this,
              psiFile.getVirtualFile().getUrl(),
              line,
              new JavaFieldBreakpointProperties(fieldName, className)
            );
          result.set(fieldBreakpoint);
        });
        return true;
      }
    };
    dialog.show();
    return result.get();
  }

  @NotNull
  @Override
  public Breakpoint<JavaFieldBreakpointProperties> createJavaBreakpoint(Project project, XBreakpoint breakpoint) {
    return new FieldBreakpoint(project, breakpoint);
  }

  @Override
  public boolean canBeHitInOtherPlaces() {
    return true;
  }

  @Override
  public boolean canPutAt(@NotNull VirtualFile file, int line, @NotNull Project project) {
    return canPutAtElement(file, line, project, (element, document) -> element instanceof PsiField);
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.HelpID;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.PositionManagerImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.jdi.MethodBytecodeUtil;
import com.intellij.facet.FacetManager;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.module.ModuleUtilCore;
import com.intellij.openapi.project.DumbService;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.TextRange;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.*;
import com.intellij.psi.impl.source.tree.LeafElement;
import com.intellij.util.DocumentUtil;
import com.intellij.util.Processor;
import com.intellij.util.SmartList;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.xdebugger.XDebuggerUtil;
import com.intellij.xdebugger.XSourcePosition;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.XLineBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointGroupingRule;
import com.intellij.xdebugger.impl.XDebuggerUtilImpl;
import com.intellij.xdebugger.impl.XSourcePositionImpl;
import com.intellij.xdebugger.impl.breakpoints.XLineBreakpointImpl;
import com.sun.jdi.Location;
import com.sun.jdi.Method;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties;
import org.jetbrains.java.debugger.breakpoints.properties.JavaLineBreakpointProperties;
import org.jetbrains.org.objectweb.asm.Label;
import org.jetbrains.org.objectweb.asm.MethodVisitor;
import org.jetbrains.org.objectweb.asm.Opcodes;

import javax.swing.*;
import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;

/**
 * Base class for java line-connected breakpoints (line, method, field)
 *
 * @author egor
 */
public class JavaLineBreakpointType extends JavaLineBreakpointTypeBase<JavaLineBreakpointProperties> {
  public JavaLineBreakpointType() {
    super("java-line", JavaDebuggerBundle.message("line.breakpoints.tab.title"));
  }

  protected JavaLineBreakpointType(@NonNls @NotNull String id, @Nls @NotNull String title) {
    super(id, title);
  }

  //@Override
  protected String getHelpID() {
    return HelpID.LINE_BREAKPOINTS;
  }

  //@Override
  public String getDisplayName() {
    return JavaDebuggerBundle.message("line.breakpoints.tab.title");
  }

  @Override
  public List<XBreakpointGroupingRule<XLineBreakpoint<JavaLineBreakpointProperties>, ?>> getGroupingRules() {
    return XDebuggerUtil.getInstance().getGroupingByFileRuleAsList();
  }

  @Nullable
  @Override
  public JavaLineBreakpointProperties createProperties() {
    return new JavaLineBreakpointProperties();
  }

  @NotNull
  @Override
  public JavaLineBreakpointProperties createBreakpointProperties(@NotNull VirtualFile file, int line) {
    return new JavaLineBreakpointProperties();
  }

  @NotNull
  @Override
  public Breakpoint<JavaLineBreakpointProperties> createJavaBreakpoint(Project project, XBreakpoint<JavaLineBreakpointProperties> breakpoint) {
    return new LineBreakpoint<>(project, breakpoint);
  }

  @Override
  public int getPriority() {
    return 100;
  }

  @NotNull
  @Override
  public List<JavaBreakpointVariant> computeVariants(@NotNull Project project, @NotNull XSourcePosition position) {
    SourcePosition pos = DebuggerUtilsEx.toSourcePosition(position, project);
    if (pos == null) {
      return Collections.emptyList();
    }

    Document document = PsiDocumentManager.getInstance(project).getDocument(pos.getFile());
    if (document == null) {
      return Collections.emptyList();
    }

    PsiElement startMethod = DebuggerUtilsEx.getContainingMethod(pos);
    List<PsiLambdaExpression> lambdas = DebuggerUtilsEx.collectLambdas(pos, true);
    PsiElement condRet = canStopOnConditionalReturn(pos.getFile())
                         ? findSingleConditionalReturn(project, document, position.getLine())
                         : null;

    if ((lambdas.isEmpty() || (lambdas.contains(startMethod) && lambdas.size() == 1)) && condRet == null) {
      return Collections.emptyList();
    }

    List<JavaBreakpointVariant> res = new SmartList<>();

    int lambdaCount = 0;
    if (!(startMethod instanceof PsiLambdaExpression)) {
      res.add(new LineJavaBreakpointVariant(position, startMethod, -1));
    }

    {
      int ordinal = 0;
      for (PsiLambdaExpression lambda : lambdas) { //lambdas
        PsiElement firstElem = DebuggerUtilsEx.getFirstElementOnTheLine(lambda, document, position.getLine());
        XSourcePositionImpl elementPosition = XSourcePositionImpl.createByElement(firstElem);
        if (elementPosition != null) {
          if (lambda == startMethod) {
            res.add(0, new LineJavaBreakpointVariant(elementPosition, lambda, ordinal++));
          }
          else {
            lambdaCount++;
            res.add(new LambdaJavaBreakpointVariant(elementPosition, lambda, ordinal++));
          }
        }
      }
    }

    if (lambdaCount > 0) {
      res.add(new JavaBreakpointVariant(position, lambdaCount)); //all
    }

    if (condRet != null) {
      PsiElement method = DebuggerUtilsEx.getContainingMethod(condRet);
      int ordinal = lambdas.indexOf(method);
      res.add(new ConditionalReturnJavaBreakpointVariant(position, condRet, ordinal)); //conditional return
    }

    return res;
  }

  /**
   * @param pos specifies the line in the file where {@code return} is looked for
   */
  public static @Nullable PsiElement findSingleConditionalReturn(@Nullable SourcePosition pos) {
    if (pos == null) return null;
    return findSingleConditionalReturn(pos.getFile(), pos.getLine());
  }

  public static @Nullable PsiElement findSingleConditionalReturn(@NotNull PsiFile file, int line) {
    Project project = file.getProject();
    Document document = PsiDocumentManager.getInstance(project).getDocument(file);
    if (document == null) return null;
    return findSingleConditionalReturn(project, document, line);
  }

  protected static @Nullable PsiElement findSingleConditionalReturn(@NotNull Project project, @NotNull Document document, int line) {
    if (!DocumentUtil.isValidLine(line, document)) return null;

    class RetFinder implements Processor<PsiElement> {
      // Our ultimate goal is to find the single return statement which is executed conditionally to break on it.
      // However, in most cases it's enough to just check that return is not the first on the line
      // (code like `workHard(); return result();` is quite rare,
      // also note that putting breakpoint on such return would not lead to catastrophic circumstances).
      // We ignore multiple returns because it's not easy to map them in source code to multiple return instructions in bytecode.

      boolean somethingBeforeReturn = false;
      @Nullable PsiElement singleReturn = null;

      @Override
      public boolean process(PsiElement element) {
        if (isReturnKeyword(element)) {
          if (singleReturn != null) {
            singleReturn = null;
            return false;
          }

          if (!somethingBeforeReturn) {
            assert singleReturn == null;
            return false;
          }

          singleReturn = element;
        }

        if (!(element instanceof PsiWhiteSpace || element instanceof PsiComment)) {
          somethingBeforeReturn = true;
        }

        return true;
      }
    }
    RetFinder finder = new RetFinder();
    new XDebuggerUtilImpl().iterateLine(project, document, line, finder);
    return finder.singleReturn;
  }

  public static boolean isReturnKeyword(@NotNull PsiElement element) {
    // Don't check for PsiKeyword to cover many languages at once.
    return element instanceof LeafElement && element.getText().equals("return");
  }

  public static boolean canStopOnConditionalReturn(@NotNull PsiFile file) {
    // We haven't implemented Dalvik bytecode parsing yet.
    Module module = ModuleUtilCore.findModuleForFile(file);
    return module == null ||
           !ContainerUtil.exists(FacetManager.getInstance(module).getAllFacets(), f -> f.getName().equals("Android"));
  }

  public boolean matchesPosition(@NotNull LineBreakpoint<?> breakpoint, @NotNull SourcePosition position) {
    JavaBreakpointProperties properties = breakpoint.getProperties();
    if (properties instanceof JavaLineBreakpointProperties) {
      if (!(breakpoint instanceof RunToCursorBreakpoint) && ((JavaLineBreakpointProperties)properties).getLambdaOrdinal() == null) return true;
      PsiElement containingMethod = getContainingMethod(breakpoint);
      if (containingMethod == null) return false;
      return DebuggerUtilsEx.inTheMethod(position, containingMethod);
    }
    return true;
  }

  @Nullable
  public PsiElement getContainingMethod(@NotNull LineBreakpoint<?> breakpoint) {
    SourcePosition position = breakpoint.getSourcePosition();
    if (position == null) return null;

    JavaBreakpointProperties properties = breakpoint.getProperties();
    if (properties instanceof JavaLineBreakpointProperties && !(breakpoint instanceof RunToCursorBreakpoint)) {
      Integer ordinal = ((JavaLineBreakpointProperties)properties).getLambdaOrdinal();
      if (ordinal != null && ordinal != -1) {
        List<PsiLambdaExpression> lambdas = DebuggerUtilsEx.collectLambdas(position, true);
        if (ordinal < lambdas.size()) {
          return lambdas.get(ordinal);
        }
      }
    }
    return DebuggerUtilsEx.getContainingMethod(position);
  }

  protected static Stream<Location> collectInlineConditionalReturnLocations(@NotNull Method method, int lineNumber) {
    assert lineNumber > 0;
    class Visitor extends MethodVisitor implements MethodBytecodeUtil.InstructionOffsetReader {
      final SmartList<Integer> returnOffsets = new SmartList<>();
      private int bytecodeOffset = -1;
      private boolean lineMatched;
      private boolean lastAddedReturnIsLastInstruction;

      protected Visitor() {
        super(Opcodes.API_VERSION);
      }

      @Override
      public void readBytecodeInstructionOffset(int offset) {
        bytecodeOffset = offset;
      }

      @Override
      public void visitLineNumber(int line, Label start) {
        lineMatched = line == lineNumber;
      }

      @Override
      public void visitInsn(int opcode) {
        lastAddedReturnIsLastInstruction = false;
        if (lineMatched && Opcodes.IRETURN <= opcode && opcode <= Opcodes.RETURN) {
          assert bytecodeOffset >= 0;
          returnOffsets.add(bytecodeOffset);
          lastAddedReturnIsLastInstruction = true;
        }
      }
    }
    Visitor visitor = new Visitor();
    MethodBytecodeUtil.visit(method, visitor, true);
    if (visitor.lastAddedReturnIsLastInstruction && visitor.returnOffsets.size() >= 2) {
      // Return at the end of the method is likely to be implicitly generated,
      // it is not the conditional return we were looking for, drop it.
      visitor.returnOffsets.remove(visitor.returnOffsets.size() - 1);
    }
    return visitor.returnOffsets.stream().map(offs -> method.locationOfCodeIndex(offs));
  }

  public class JavaBreakpointVariant extends XLineBreakpointAllVariant {
    private final int lambdaCount;

    public JavaBreakpointVariant(@NotNull XSourcePosition position, int lambdaCount) {
      super(position);
      this.lambdaCount = lambdaCount;
    }

    public JavaBreakpointVariant(@NotNull XSourcePosition position) {
      this(position, -1);
    }

    @Override
    public @NotNull String getText() {
      return lambdaCount >= 0
             ? JavaDebuggerBundle.message("breakpoint.variant.text.line.and.lambda", lambdaCount)
             : JavaDebuggerBundle.message("breakpoint.variant.text.line.and.lambda.uknown.count");
    }
  }

  public class ExactJavaBreakpointVariant extends JavaBreakpointVariant {
    private final PsiElement myElement;
    private final Integer myEncodedInlinePosition;

    public ExactJavaBreakpointVariant(@NotNull XSourcePosition position, @Nullable PsiElement element, Integer encodedInlinePosition) {
      super(position);
      myElement = element;
      myEncodedInlinePosition = encodedInlinePosition;
    }

    @Override
    public Icon getIcon() {
      return myElement != null ? myElement.getIcon(0) : AllIcons.Debugger.Db_set_breakpoint;
    }

    @NotNull
    @Override
    public String getText() {
      return myElement != null
             ? StringUtil.shortenTextWithEllipsis(ReadAction.compute(() -> myElement.getText()), 100, 0)
             : JavaDebuggerBundle.message("breakpoint.variant.text.line");
    }

    @Override
    public TextRange getHighlightRange() {
      if (myElement != null) {
        return DebuggerUtilsEx.intersectWithLine(myElement.getTextRange(), myElement.getContainingFile(), mySourcePosition.getLine());
      }
      return null;
    }

    @NotNull
    @Override
    public JavaLineBreakpointProperties createProperties() {
      JavaLineBreakpointProperties properties = super.createProperties();
      assert properties != null;
      properties.setEncodedInlinePosition(myEncodedInlinePosition);
      return properties;
    }
  }

  public class LineJavaBreakpointVariant extends ExactJavaBreakpointVariant {
    public LineJavaBreakpointVariant(@NotNull XSourcePosition position, @Nullable PsiElement element, int lambdaOrdinal) {
      super(position, element, JavaLineBreakpointProperties.encodeInlinePosition(lambdaOrdinal, false));
    }

    @NotNull
    @Override
    public String getText() {
      return JavaDebuggerBundle.message("breakpoint.variant.text.line");
    }

    @Override
    public Icon getIcon() {
      return AllIcons.Debugger.Db_set_breakpoint;
    }
  }

  public class LambdaJavaBreakpointVariant extends ExactJavaBreakpointVariant {
    public LambdaJavaBreakpointVariant(@NotNull XSourcePosition position, @NotNull PsiElement element, int lambdaOrdinal) {
      super(position, element, JavaLineBreakpointProperties.encodeInlinePosition(lambdaOrdinal, false));
    }

    @Override
    public Icon getIcon() {
      return AllIcons.Debugger.LambdaBreakpoint;
    }
  }

  public class ConditionalReturnJavaBreakpointVariant extends ExactJavaBreakpointVariant {
    public ConditionalReturnJavaBreakpointVariant(@NotNull XSourcePosition position, PsiElement element, int lambdaOrdinal) {
      super(position, element, JavaLineBreakpointProperties.encodeInlinePosition(lambdaOrdinal, true));
    }

    @Override
    public Icon getIcon() {
      return AllIcons.Debugger.Db_set_breakpoint;
    }
  }

  @Nullable
  @Override
  public TextRange getHighlightRange(XLineBreakpoint<JavaLineBreakpointProperties> breakpoint) {
    PsiElement highlightedElement = null;
    Integer lambdaOrdinal = getLambdaOrdinal(breakpoint);
    if (lambdaOrdinal != null) {
      Breakpoint<?> javaBreakpoint = BreakpointManager.getJavaBreakpoint(breakpoint);
      if (javaBreakpoint instanceof LineBreakpoint<?> lineBreakpoint) {
        assert breakpoint.getProperties() != null;
        if (breakpoint.getProperties().isConditionalReturn()) {
          highlightedElement = findSingleConditionalReturn(lineBreakpoint.getSourcePosition());
        }
        else {
          highlightedElement = getContainingMethod(lineBreakpoint);
        }
      }
    }
    return highlightedElement != null
           ? DebuggerUtilsEx.intersectWithLine(highlightedElement.getTextRange(), highlightedElement.getContainingFile(), breakpoint.getLine())
           : null;
  }

  @Override
  public XSourcePosition getSourcePosition(@NotNull XBreakpoint<JavaLineBreakpointProperties> breakpoint) {
    JavaLineBreakpointProperties properties = breakpoint.getProperties();
    if (properties == null) return null;

    boolean condRet = properties.isConditionalReturn();
    Integer lambdaOrdinal = properties.getLambdaOrdinal();
    boolean isLambda = lambdaOrdinal != null && lambdaOrdinal != -1;
    if (!condRet && !isLambda) return null;

    return ReadAction.compute(() -> {
      SourcePosition linePosition = createLineSourcePosition((XLineBreakpointImpl)breakpoint);
      if (linePosition != null) {
        PsiElement theReturn = condRet ? findSingleConditionalReturn(linePosition) : null;
        if (theReturn != null) {
          return XSourcePositionImpl.createByElement(theReturn);
        }
        else if (isLambda) {
          return DebuggerUtilsEx.toXSourcePosition(new PositionManagerImpl.JavaSourcePosition(linePosition, lambdaOrdinal));
        }
      }
      return null;
    });
  }

  @Nullable
  private static Integer getLambdaOrdinal(XBreakpoint<JavaLineBreakpointProperties> breakpoint) {
    JavaLineBreakpointProperties properties = breakpoint.getProperties();
    return properties != null ? properties.getLambdaOrdinal() : null;
  }

  @Nullable
  private static SourcePosition createLineSourcePosition(XLineBreakpointImpl breakpoint) {
    VirtualFile file = breakpoint.getFile();
    if (file != null) {
      PsiFile psiFile = PsiManager.getInstance(breakpoint.getProject()).findFile(file);
      if (psiFile != null) {
        return SourcePosition.createFromLine(psiFile, breakpoint.getLine());
      }
    }
    return null;
  }

  @Override
  public boolean canBeHitInOtherPlaces() {
    return true; // line breakpoints could be hit in other versions of the same classes
  }

  @Override
  public boolean canPutAt(@NotNull VirtualFile file, int line, @NotNull Project project) {
    return canPutAtElement(file, line, project, (element, document) -> {
      if (DumbService.isDumb(project)) { // always allow line breakpoints in dumb mode
        return true;
      }

      if (element instanceof PsiField) {
        PsiExpression initializer = ((PsiField)element).getInitializer();
        if (initializer != null && !PsiTypes.nullType().equals(initializer.getType())) {
          Object value = JavaPsiFacade.getInstance(project).getConstantEvaluationHelper().computeConstantExpression(initializer);
          return value == null;
        }
        return false;
      }
      else if (element instanceof PsiMethod) {
        PsiCodeBlock body = ((PsiMethod)element).getBody();
        if (body != null) {
          PsiStatement[] statements = body.getStatements();
          if (statements.length > 0 && document.getLineNumber(statements[0].getTextOffset()) == line) {
            return true;
          }
        }
        return false;
      }
      return true;
    });
  }

  @Nullable
  @Override
  public XBreakpointCustomPropertiesPanel<XLineBreakpoint<JavaLineBreakpointProperties>> createCustomPropertiesPanel(@NotNull Project project) {
    if (Registry.is("debugger.call.tracing")) {
      return new CallTracingPropertiesPanel(project);
    }
    return null;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.ide.highlighter.JavaClassFileType;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.fileEditor.FileDocumentManager;
import com.intellij.openapi.fileTypes.StdFileTypes;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Ref;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.*;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.util.DocumentUtil;
import com.intellij.xdebugger.XDebugSession;
import com.intellij.xdebugger.XDebuggerUtil;
import com.intellij.xdebugger.breakpoints.XLineBreakpoint;
import com.intellij.xdebugger.breakpoints.XLineBreakpointType;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import com.intellij.xdebugger.evaluation.XDebuggerEditorsProvider;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.JavaDebuggerEditorsProvider;
import org.jetbrains.java.debugger.breakpoints.JavaBreakpointFiltersPanel;
import org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties;

import java.util.List;
import java.util.function.BiFunction;

/**
 * Base class for java line-connected breakpoints (line, method, field)
 *
 * @author egor
 */
public abstract class JavaLineBreakpointTypeBase<P extends JavaBreakpointProperties> extends XLineBreakpointType<P>
  implements JavaBreakpointType<P> {
  public JavaLineBreakpointTypeBase(@NonNls @NotNull String id, @Nls @NotNull String title) {
    super(id, title);
  }

  @Override
  public final boolean isSuspendThreadSupported() {
    return true;
  }

  @NotNull
  @Override
  public final XBreakpointCustomPropertiesPanel<XLineBreakpoint<P>> createCustomRightPropertiesPanel(@NotNull Project project) {
    return new JavaBreakpointFiltersPanel<>(project);
  }

  @NotNull
  @Override
  public final XDebuggerEditorsProvider getEditorsProvider(@NotNull XLineBreakpoint<P> breakpoint, @NotNull Project project) {
    return new JavaDebuggerEditorsProvider();
  }

  @Override
  public String getDisplayText(XLineBreakpoint<P> breakpoint) {
    BreakpointWithHighlighter javaBreakpoint = (BreakpointWithHighlighter)BreakpointManager.getJavaBreakpoint(breakpoint);
    if (javaBreakpoint != null) {
      return javaBreakpoint.getDescription();
    }
    else {
      return super.getDisplayText(breakpoint);
    }
  }

  protected static boolean canPutAtElement(@NotNull final VirtualFile file,
                                           final int line,
                                           @NotNull Project project,
                                           @NotNull BiFunction<? super PsiElement, ? super Document, Boolean> processor) {
    PsiFile psiFile = PsiManager.getInstance(project).findFile(file);
    // JSPX supports jvm debugging, but not in XHTML files
    if (psiFile == null || psiFile.getViewProvider().getFileType() == StdFileTypes.XHTML) {
      return false;
    }

    if (!JavaClassFileType.INSTANCE.equals(psiFile.getFileType()) && !DebuggerUtils.isBreakpointAware(psiFile)) {
      return false;
    }

    Document document = FileDocumentManager.getInstance().getDocument(file);
    if (document != null) {
      Ref<Boolean> res = Ref.create(false);
      XDebuggerUtil.getInstance().iterateLine(project, document, line, element -> {
        // avoid comments
        if ((element instanceof PsiWhiteSpace)
            || (PsiTreeUtil.getParentOfType(element, PsiComment.class, PsiImportStatementBase.class, PsiPackageStatement.class) != null)) {
          return true;
        }
        PsiElement parent = element;
        while (element != null) {
          // skip modifiers
          if (element instanceof PsiModifierList) {
            element = element.getParent();
            continue;
          }

          final int offset = element.getTextOffset();
          if (!DocumentUtil.isValidOffset(offset, document) || document.getLineNumber(offset) != line) {
            break;
          }
          parent = element;
          element = element.getParent();
        }

        if (processor.apply(parent, document)) {
          res.set(true);
          return false;
        }
        return true;
      });
      return res.get();
    }
    return false;
  }

  @Override
  public List<? extends AnAction> getAdditionalPopupMenuActions(@NotNull XLineBreakpoint<P> breakpoint,
                                                                @Nullable XDebugSession currentSession) {
    return BreakpointIntentionAction.getIntentions(breakpoint, currentSession);
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.HelpID;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiMethod;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.XLineBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaMethodBreakpointProperties;

import javax.swing.*;

/**
 * @author Eugene Zhuravlev
 */
public class JavaMethodBreakpointType extends JavaLineBreakpointTypeBase<JavaMethodBreakpointProperties> {
  public JavaMethodBreakpointType(@NotNull String id, @Nls @NotNull String message) {
    super(id, message);
  }

  public JavaMethodBreakpointType() {
    this("java-method", JavaDebuggerBundle.message("method.breakpoints.tab.title"));
  }

  @NotNull
  @Override
  public Icon getEnabledIcon() {
    return AllIcons.Debugger.Db_method_breakpoint;
  }

  @NotNull
  @Override
  public Icon getDisabledIcon() {
    return AllIcons.Debugger.Db_disabled_method_breakpoint;
  }

  @NotNull
  @Override
  public Icon getSuspendNoneIcon() {
    return AllIcons.Debugger.Db_no_suspend_method_breakpoint;
  }

  @NotNull
  @Override
  public Icon getMutedEnabledIcon() {
    return AllIcons.Debugger.Db_muted_method_breakpoint;
  }

  @NotNull
  @Override
  public Icon getMutedDisabledIcon() {
    return AllIcons.Debugger.Db_muted_disabled_method_breakpoint;
  }

  @NotNull
  @Override
  public Icon getInactiveDependentIcon() {
    return AllIcons.Debugger.Db_dep_method_breakpoint;
  }

  //@Override
  protected String getHelpID() {
    return HelpID.METHOD_BREAKPOINTS;
  }

  //@Override
  public String getDisplayName() {
    return JavaDebuggerBundle.message("method.breakpoints.tab.title");
  }

  @Override
  public String getShortText(XLineBreakpoint<JavaMethodBreakpointProperties> breakpoint) {
    return getText(breakpoint);
  }

  @Nls
  static String getText(XBreakpoint<JavaMethodBreakpointProperties> breakpoint) {
    final StringBuilder buffer = new StringBuilder();
    //if (isValid()) {
    final String className = breakpoint.getProperties().myClassPattern;
    final boolean classNameExists = className != null && className.length() > 0;
    if (classNameExists) {
      buffer.append(className);
    }
    if (breakpoint.getProperties().myMethodName != null) {
      if (classNameExists) {
        buffer.append(".");
      }
      buffer.append(breakpoint.getProperties().myMethodName);
    }
    //}
    //else {
    //  buffer.append(JavaDebuggerBundle.message("status.breakpoint.invalid"));
    //}
    //noinspection HardCodedStringLiteral
    return buffer.toString();
  }

  @Nullable
  @Override
  public XBreakpointCustomPropertiesPanel createCustomPropertiesPanel(@NotNull Project project) {
    return new MethodBreakpointPropertiesPanel();
  }

  @Nullable
  @Override
  public JavaMethodBreakpointProperties createProperties() {
    return new JavaMethodBreakpointProperties();
  }

  @Nullable
  @Override
  public JavaMethodBreakpointProperties createBreakpointProperties(@NotNull VirtualFile file, int line) {
    JavaMethodBreakpointProperties properties = new JavaMethodBreakpointProperties();
    if (Registry.is("debugger.emulate.method.breakpoints")) {
      properties.EMULATED = true; // create all new emulated
    }
    if (Registry.is("debugger.method.breakpoints.entry.default")) {
      properties.WATCH_EXIT = false;
    }
    return properties;
  }

  @NotNull
  @Override
  public Breakpoint<JavaMethodBreakpointProperties> createJavaBreakpoint(Project project, XBreakpoint breakpoint) {
    return new MethodBreakpoint(project, breakpoint);
  }

  @Override
  public boolean canBeHitInOtherPlaces() {
    return true;
  }

  @Override
  public boolean canPutAt(@NotNull VirtualFile file, int line, @NotNull Project project) {
    return canPutAtElement(file, line, project, (element, document) -> element instanceof PsiMethod);
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.HelpID;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.WriteAction;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.xdebugger.XDebuggerManager;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaMethodBreakpointProperties;

import javax.swing.*;

/**
 * @author Egor
 */
public class JavaWildcardMethodBreakpointType extends JavaBreakpointTypeBase<JavaMethodBreakpointProperties> {
  public JavaWildcardMethodBreakpointType() {
    super("java-wildcard-method", JavaDebuggerBundle.message("method.breakpoints.tab.title"));
  }

  @NotNull
  @Override
  public Icon getEnabledIcon() {
    return AllIcons.Debugger.Db_method_breakpoint;
  }

  @NotNull
  @Override
  public Icon getDisabledIcon() {
    return AllIcons.Debugger.Db_disabled_method_breakpoint;
  }

  @NotNull
  @Override
  public Icon getMutedEnabledIcon() {
    return AllIcons.Debugger.Db_muted_method_breakpoint;
  }

  @NotNull
  @Override
  public Icon getMutedDisabledIcon() {
    return AllIcons.Debugger.Db_muted_disabled_method_breakpoint;
  }

  //@Override
  protected String getHelpID() {
    return HelpID.METHOD_BREAKPOINTS;
  }

  //@Override
  public String getDisplayName() {
    return JavaDebuggerBundle.message("method.breakpoints.tab.title");
  }

  @Override
  public String getDisplayText(XBreakpoint<JavaMethodBreakpointProperties> breakpoint) {
    return JavaMethodBreakpointType.getText(breakpoint);
  }

  @Nullable
  @Override
  public XBreakpointCustomPropertiesPanel<XBreakpoint<JavaMethodBreakpointProperties>> createCustomPropertiesPanel(@NotNull Project project) {
    return new MethodBreakpointPropertiesPanel();
  }

  //@Override
  //public Key<MethodBreakpoint> getBreakpointCategory() {
  //  return MethodBreakpoint.CATEGORY;
  //}

  @Nullable
  @Override
  public JavaMethodBreakpointProperties createProperties() {
    return new JavaMethodBreakpointProperties();
  }

  @Nullable
  @Override
  public XBreakpoint<JavaMethodBreakpointProperties> addBreakpoint(final Project project, JComponent parentComponent) {
    final AddWildcardBreakpointDialog dialog = new AddWildcardBreakpointDialog(project);
    if (!dialog.showAndGet()) {
      return null;
    }
    return WriteAction.compute(() -> {
      JavaMethodBreakpointProperties properties = new JavaMethodBreakpointProperties(dialog.getClassPattern(), dialog.getMethodName());
      if (Registry.is("debugger.emulate.method.breakpoints")) {
        properties.EMULATED = true; // create all new emulated
      }
      if (Registry.is("debugger.method.breakpoints.entry.default")) {
        properties.WATCH_EXIT = false;
      }
      return XDebuggerManager.getInstance(project).getBreakpointManager().addBreakpoint(this, properties);
    });
  }

  @NotNull
  @Override
  public Breakpoint<JavaMethodBreakpointProperties> createJavaBreakpoint(Project project, XBreakpoint<JavaMethodBreakpointProperties> breakpoint) {
    return new WildcardMethodBreakpoint(project, breakpoint);
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

/*
 * Class LineBreakpoint
 * @author Jeka
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.ContextUtil;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.jdi.MethodBytecodeUtil;
import com.intellij.debugger.jdi.VirtualMachineProxyImpl;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.roots.ProjectFileIndex;
import com.intellij.openapi.roots.ProjectRootManager;
import com.intellij.openapi.ui.MessageType;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.NlsContexts;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.*;
import com.intellij.psi.jsp.JspFile;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.ui.LayeredIcon;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.xdebugger.XDebuggerUtil;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.XBreakpointType;
import com.intellij.xdebugger.impl.XDebuggerManagerImpl;
import com.intellij.xdebugger.impl.XDebuggerUtilImpl;
import com.sun.jdi.*;
import com.sun.jdi.event.LocatableEvent;
import one.util.streamex.StreamEx;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties;
import org.jetbrains.java.debugger.breakpoints.properties.JavaLineBreakpointProperties;
import org.jetbrains.jps.model.java.JavaModuleSourceRootTypes;

import javax.swing.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.regex.Pattern;

public class LineBreakpoint<P extends JavaBreakpointProperties> extends BreakpointWithHighlighter<P> {
  private final boolean myIgnoreSameLineLocations;

  static final Logger LOG = Logger.getInstance(LineBreakpoint.class);

  public static final @NonNls Key<LineBreakpoint> CATEGORY = BreakpointCategory.lookup("line_breakpoints");

  protected LineBreakpoint(Project project, XBreakpoint xBreakpoint) {
    this(project, xBreakpoint, true);
  }

  protected LineBreakpoint(Project project, XBreakpoint xBreakpoint, boolean ignoreSameLineLocations) {
    super(project, xBreakpoint);
    myIgnoreSameLineLocations = ignoreSameLineLocations;
  }

  @Override
  protected Icon getDisabledIcon(boolean isMuted) {
    if (DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().findMasterBreakpoint(this) != null) {
      return isMuted ? AllIcons.Debugger.Db_muted_dep_line_breakpoint : AllIcons.Debugger.Db_dep_line_breakpoint;
    }
    return null;
  }

  @Override
  protected Icon getVerifiedIcon(boolean isMuted) {
    return XDebuggerUtilImpl.getVerifiedIcon(myXBreakpoint);
  }

  @Override
  protected Icon getVerifiedWarningsIcon(boolean isMuted) {
    return new LayeredIcon(isMuted ? AllIcons.Debugger.Db_muted_breakpoint : AllIcons.Debugger.Db_set_breakpoint,
                           AllIcons.General.WarningDecorator);
  }

  @Override
  public Key<LineBreakpoint> getCategory() {
    return CATEGORY;
  }

  @Override
  protected void createOrWaitPrepare(DebugProcessImpl debugProcess, String classToBeLoaded) {
    if (isInScopeOf(debugProcess, classToBeLoaded)) {
      super.createOrWaitPrepare(debugProcess, classToBeLoaded);
    }
  }

  @Override
  protected void createRequestForPreparedClass(final DebugProcessImpl debugProcess, final ReferenceType classType) {
    if (!ReadAction.compute(() -> isInScopeOf(debugProcess, classType.name()))) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(classType.name() + " is out of debug-process scope, breakpoint request won't be created for line " + getLineIndex());
      }
      return;
    }
    try {
      SourcePosition position = getSourcePosition();
      List<Location> locations = debugProcess.getPositionManager().locationsOfLine(classType, position);
      if (!locations.isEmpty()) {
        VirtualMachineProxyImpl vm = debugProcess.getVirtualMachineProxy();
        locations = StreamEx.of(locations).peek(loc -> {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Found location [codeIndex=" + loc.codeIndex() +
                      "] for reference type " + classType.name() +
                      " at line " + getLineIndex() +
                      "; isObsolete: " + (vm.versionHigher("1.4") && loc.method().isObsolete()));
          }
        }).filter(l -> acceptLocation(debugProcess, classType, l)).toList();

        if (getProperties() instanceof JavaLineBreakpointProperties props && props.isConditionalReturn()) {
          if (DebuggerUtils.isAndroidVM(vm.getVirtualMachine())) {
            XDebuggerManagerImpl.getNotificationGroup()
              .createNotification(JavaDebuggerBundle.message("message.conditional.return.breakpoint.on.android"), MessageType.INFO)
              .notify(debugProcess.getProject());
          }
          else if (vm.canGetBytecodes() && vm.canGetConstantPool()) {
            locations = locations.stream()
              .map(l -> l.method())
              .distinct()
              .flatMap(m -> JavaLineBreakpointType.collectInlineConditionalReturnLocations(m, position.getLine() + 1))
              .toList();
          }
        }
        else if (myIgnoreSameLineLocations) {
          locations = MethodBytecodeUtil.removeSameLineLocations(locations);
        }

        for (Location loc : locations) {
          createLocationBreakpointRequest(this, loc, debugProcess);
          if (LOG.isDebugEnabled()) {
            LOG.debug("Created breakpoint request for reference type " + classType.name() + " at line " + getLineIndex() + "; codeIndex=" + loc.codeIndex());
          }
        }
      }
      else if (DebuggerUtilsEx.allLineLocations(classType) == null) {
        // there's no line info in this class
        debugProcess.getRequestsManager()
          .setInvalid(this, JavaDebuggerBundle.message("error.invalid.breakpoint.no.line.info", classType.name()));
        if (LOG.isDebugEnabled()) {
          LOG.debug("No line number info in " + classType.name());
        }
      }
      else {
        // there's no executable code in this class
        debugProcess.getRequestsManager().setInvalid(this, JavaDebuggerBundle.message(
          "error.invalid.breakpoint.no.executable.code", (getLineIndex() + 1), classType.name())
        );
        if (LOG.isDebugEnabled()) {
          LOG.debug("No locations of type " + classType.name() + " found at line " + getLineIndex());
        }
      }
    }
    catch (ClassNotPreparedException ex) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("ClassNotPreparedException: " + ex.getMessage());
      }
      // there's a chance to add a breakpoint when the class is prepared
    }
    catch (ObjectCollectedException ex) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("ObjectCollectedException: " + ex.getMessage());
      }
      // there's a chance to add a breakpoint when the class is prepared
    }
    catch (Exception ex) {
      LOG.info(ex);
    }
    updateUI();
  }

  private static final Pattern ourAnonymousPattern = Pattern.compile(".*\\$\\d*$");

  private static boolean isAnonymousClass(ReferenceType classType) {
    if (classType instanceof ClassType) {
      return ourAnonymousPattern.matcher(classType.name()).matches();
    }
    return false;
  }

  protected boolean acceptLocation(final DebugProcessImpl debugProcess, ReferenceType classType, final Location loc) {
    // Some frameworks may create synthetic methods with lines mapped to user code, see IDEA-143852
    // if (DebuggerUtils.isSynthetic(method)) { return false; }
    if (isAnonymousClass(classType)) {
      Method method = loc.method();
      if ((method.isConstructor() && loc.codeIndex() == 0) || method.isBridge()) return false;
    }
    SourcePosition position = debugProcess.getPositionManager().getSourcePosition(loc);
    if (position == null) return false;

    return ReadAction.compute(() -> {
      JavaLineBreakpointType type = getXBreakpointType();
      if (type == null) return true;
      return type.matchesPosition(this, position);
    });
  }

  @Nullable
  protected JavaLineBreakpointType getXBreakpointType() {
    XBreakpointType<?, P> type = myXBreakpoint.getType();
    // Nashorn breakpoints do not contain JavaLineBreakpointType
    if (type instanceof JavaLineBreakpointType) {
      return (JavaLineBreakpointType)type;
    }
    return null;
  }

  private boolean isInScopeOf(DebugProcessImpl debugProcess, String className) {
    final SourcePosition position = getSourcePosition();
    if (position != null) {
      final VirtualFile breakpointFile = position.getFile().getVirtualFile();
      final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();
      if (breakpointFile != null && fileIndex.isUnderSourceRootOfType(breakpointFile, JavaModuleSourceRootTypes.SOURCES)) {
        if (debugProcess.getSearchScope().contains(breakpointFile)) {
          return true;
        }
        // apply filtering to breakpoints from content sources only, not for sources attached to libraries
        final Collection<VirtualFile> candidates = findClassCandidatesInSourceContent(className, debugProcess.getSearchScope(), fileIndex);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Found " + (candidates == null ? "null" : candidates.size()) + " candidate containing files for class " + className);
        }
        if (candidates == null) {
          // If no candidates are found in scope then assume that class is loaded dynamically and allow breakpoint
          return true;
        }

        // breakpointFile is not in scope here and there are some candidates in scope
        //for (VirtualFile classFile : candidates) {
        //  if (LOG.isDebugEnabled()) {
        //    LOG.debug("Breakpoint file: " + breakpointFile.getPath()+ "; candidate file: " + classFile.getPath());
        //  }
        //  if (breakpointFile.equals(classFile)) {
        //    return true;
        //  }
        //}
        if (LOG.isDebugEnabled()) {
          final GlobalSearchScope scope = debugProcess.getSearchScope();
          final boolean contains = scope.contains(breakpointFile);
          List<VirtualFile> files = ContainerUtil.map(
            JavaPsiFacade.getInstance(myProject).findClasses(className, scope),
            aClass -> aClass.getContainingFile().getVirtualFile());
          List<VirtualFile> allFiles = ContainerUtil.map(
            JavaPsiFacade.getInstance(myProject).findClasses(className, GlobalSearchScope.everythingScope(myProject)),
            aClass -> aClass.getContainingFile().getVirtualFile());
          final VirtualFile contentRoot = fileIndex.getContentRootForFile(breakpointFile);
          final Module module = fileIndex.getModuleForFile(breakpointFile);

          LOG.debug("Did not find '" +
                    className + "' in " + scope +
                    "; contains=" + contains +
                    "; contentRoot=" + contentRoot +
                    "; module = " + module +
                    "; all files in index are: " + files +
                    "; all possible files are: " + allFiles
          );
        }

        return false;
      }
    }
    return true;
  }

  @Nullable
  private Collection<VirtualFile> findClassCandidatesInSourceContent(final String className, final GlobalSearchScope scope, final ProjectFileIndex fileIndex) {
    final int dollarIndex = className.indexOf("$");
    final String topLevelClassName = dollarIndex >= 0 ? className.substring(0, dollarIndex) : className;
    return ReadAction.compute(() -> {
      final PsiClass[] classes = JavaPsiFacade.getInstance(myProject).findClasses(topLevelClassName, scope);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Found " + classes.length + " classes " + topLevelClassName + " in scope " + scope);
      }
      if (classes.length == 0) {
        return null;
      }
      final List<VirtualFile> list = new ArrayList<>(classes.length);
      for (PsiClass aClass : classes) {
        final PsiFile psiFile = aClass.getContainingFile();

        if (LOG.isDebugEnabled()) {
          final StringBuilder msg = new StringBuilder();
          msg.append("Checking class ").append(aClass.getQualifiedName());
          msg.append("\n\t").append("PsiFile=").append(psiFile);
          if (psiFile != null) {
            final VirtualFile vFile = psiFile.getVirtualFile();
            msg.append("\n\t").append("VirtualFile=").append(vFile);
            if (vFile != null) {
              msg.append("\n\t").append("isInSourceContent=").append(fileIndex.isUnderSourceRootOfType(vFile, JavaModuleSourceRootTypes.SOURCES));
            }
          }
          LOG.debug(msg.toString());
        }

        if (psiFile == null) {
          return null;
        }
        final VirtualFile vFile = psiFile.getVirtualFile();
        if (vFile == null || !fileIndex.isUnderSourceRootOfType(vFile, JavaModuleSourceRootTypes.SOURCES)) {
          return null; // this will switch off the check if at least one class is from libraries
        }
        list.add(vFile);
      }
      return list;
    });
  }

  @Override
  public String getShortName() {
    return getDisplayInfoInternal(false, 30);
  }

  @Override
  public String getDisplayName() {
    return getDisplayInfoInternal(true, -1);
  }

  private @NlsContexts.Label String getDisplayInfoInternal(boolean showPackageInfo, int totalTextLength) {
    if (isValid()) {
      final int lineNumber = getLineIndex() + 1;
      String className = getClassName();
      final boolean hasClassInfo = className != null && className.length() > 0;
      final String methodName = getMethodName();
      final String displayName = methodName != null ? methodName + "()" : null;
      final boolean hasMethodInfo = displayName != null;
      if (hasClassInfo || hasMethodInfo) {
        final StringBuilder info = new StringBuilder();
        boolean isFile = getFileName().equals(className);
        String packageName = null;
        if (hasClassInfo) {
          final int dotIndex = className.lastIndexOf(".");
          if (dotIndex >= 0 && !isFile) {
            packageName = className.substring(0, dotIndex);
            className = className.substring(dotIndex + 1);
          }

          if (totalTextLength != -1) {
            if (className.length() + (hasMethodInfo ? displayName.length() : 0) > totalTextLength + 3) {
              int offset = totalTextLength - (hasMethodInfo ? displayName.length() : 0);
              if (offset > 0 && offset < className.length()) {
                className = className.substring(className.length() - offset);
                info.append("...");
              }
            }
          }

          info.append(className);
        }
        if (hasMethodInfo) {
          if (isFile) {
            info.append(":");
          }
          else if (hasClassInfo) {
            info.append(".");
          }
          info.append(displayName);
        }
        if (showPackageInfo && packageName != null) {
          info.append(" (").append(packageName).append(")");
        }
        return JavaDebuggerBundle.message("line.breakpoint.display.name.with.class.or.method", lineNumber, info.toString());
      }
      return JavaDebuggerBundle.message("line.breakpoint.display.name", lineNumber);
    }
    return JavaDebuggerBundle.message("status.breakpoint.invalid");
  }

  @Nullable
  private static String findOwnerMethod(final PsiFile file, final int offset) {
    if (offset < 0 || file instanceof JspFile) {
      return null;
    }
    if (file instanceof PsiClassOwner) {
      return ReadAction.compute(() -> {
        PsiMethod method = DebuggerUtilsEx.findPsiMethod(file, offset);
        return method != null ? method.getName() : null;
      });
    }
    return null;
  }

  @Override
  public String getEventMessage(LocatableEvent event) {
    final Location location = event.location();
    String sourceName = DebuggerUtilsEx.getSourceName(location, e -> getFileName());

    return JavaDebuggerBundle.message(
      "status.line.breakpoint.reached",
      DebuggerUtilsEx.getLocationMethodQName(location),
      sourceName,
      getLineIndex() + 1
    );
  }

  @Override
  public PsiElement getEvaluationElement() {
    return ContextUtil.getContextElement(getSourcePosition());
  }

  public static LineBreakpoint create(@NotNull Project project, XBreakpoint xBreakpoint) {
    LineBreakpoint breakpoint = new LineBreakpoint(project, xBreakpoint);
    return (LineBreakpoint)breakpoint.init();
  }

  //@Override
  //public boolean canMoveTo(SourcePosition position) {
  //  if (!super.canMoveTo(position)) {
  //    return false;
  //  }
  //  final Document document = PsiDocumentManager.getInstance(getProject()).getDocument(position.getFile());
  //  return canAddLineBreakpoint(myProject, document, position.getLine());
  //}

  public static boolean canAddLineBreakpoint(Project project, final Document document, final int lineIndex) {
    if (lineIndex < 0 || lineIndex >= document.getLineCount()) {
      return false;
    }
    final BreakpointManager breakpointManager = DebuggerManagerEx.getInstanceEx(project).getBreakpointManager();
    final LineBreakpoint breakpointAtLine = breakpointManager.findBreakpoint(document, document.getLineStartOffset(lineIndex), CATEGORY);
    if (breakpointAtLine != null) {
      // there already exists a line breakpoint at this line
      return false;
    }
    PsiDocumentManager.getInstance(project).commitDocument(document);

    final boolean[] canAdd = new boolean[]{false};
    XDebuggerUtil.getInstance().iterateLine(project, document, lineIndex, element -> {
      if ((element instanceof PsiWhiteSpace) || (PsiTreeUtil.getParentOfType(element, PsiComment.class, false) != null)) {
        return true;
      }
      PsiElement child = element;
      while (element != null) {

        final int offset = element.getTextOffset();
        if (offset >= 0) {
          if (document.getLineNumber(offset) != lineIndex) {
            break;
          }
        }
        child = element;
        element = element.getParent();
      }

      if (child instanceof PsiMethod && child.getTextRange().getEndOffset() >= document.getLineEndOffset(lineIndex)) {
        PsiCodeBlock body = ((PsiMethod)child).getBody();
        if (body == null) {
          canAdd[0] = false;
        }
        else {
          PsiStatement[] statements = body.getStatements();
          canAdd[0] = statements.length > 0 && document.getLineNumber(statements[0].getTextOffset()) == lineIndex;
        }
      }
      else {
        canAdd[0] = true;
      }
      return false;
    });

    return canAdd[0];
  }

  @Nullable
  public String getMethodName() {
    SourcePosition position = getSourcePosition();
    if (position != null) {
      return findOwnerMethod(position.getFile(), position.getOffset());
    }
    return null;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

/*
 * Class MethodBreakpoint
 * @author Jeka
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerManagerThreadImpl;
import com.intellij.debugger.engine.JVMName;
import com.intellij.debugger.engine.JVMNameUtil;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.requests.RequestManagerImpl;
import com.intellij.debugger.impl.DebuggerUtilsAsync;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.impl.DebuggerUtilsImpl;
import com.intellij.debugger.impl.PositionUtil;
import com.intellij.debugger.jdi.ClassesByNameProvider;
import com.intellij.debugger.jdi.MethodBytecodeUtil;
import com.intellij.debugger.requests.Requestor;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.progress.ProgressIndicator;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.util.ProgressWindow;
import com.intellij.openapi.project.IndexNotReadyException;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.JDOMExternalizerUtil;
import com.intellij.openapi.util.Key;
import com.intellij.psi.*;
import com.intellij.ui.LayeredIcon;
import com.intellij.util.DocumentUtil;
import com.intellij.util.SlowOperations;
import com.intellij.util.containers.MultiMap;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.XBreakpointListener;
import com.sun.jdi.*;
import com.sun.jdi.event.LocatableEvent;
import com.sun.jdi.event.MethodEntryEvent;
import com.sun.jdi.event.MethodExitEvent;
import com.sun.jdi.request.*;
import one.util.streamex.StreamEx;
import org.jdom.Element;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaMethodBreakpointProperties;
import org.jetbrains.org.objectweb.asm.MethodVisitor;
import org.jetbrains.org.objectweb.asm.Opcodes;

import javax.swing.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;

public class MethodBreakpoint extends BreakpointWithHighlighter<JavaMethodBreakpointProperties> implements MethodBreakpointBase {
  private static final Logger LOG = Logger.getInstance(MethodBreakpoint.class);
  @Nullable protected JVMName mySignature;
  protected boolean myIsStatic;

  public static final @NonNls Key<MethodBreakpoint> CATEGORY = BreakpointCategory.lookup("method_breakpoints");

  protected MethodBreakpoint(@NotNull Project project, XBreakpoint breakpoint) {
    super(project, breakpoint);
  }

  public boolean isStatic() {
    return myIsStatic;
  }

  @Override
  @NotNull
  public Key<MethodBreakpoint> getCategory() {
    return CATEGORY;
  }

  @Override
  public boolean isValid() {
    return super.isValid() && getMethodName() != null;
  }

  @Override
  public void reload() {
    super.reload();

    setMethodName(null);
    mySignature = null;

    SourcePosition sourcePosition = getSourcePosition();
    if (sourcePosition != null) {
      SlowOperations.allowSlowOperations(() -> {
        MethodDescriptor descriptor = getMethodDescriptor(myProject, sourcePosition);
        if (descriptor != null) {
          setMethodName(descriptor.methodName);
          mySignature = descriptor.methodSignature;
          myIsStatic = descriptor.isStatic;
        }
      });
    }
    PsiClass psiClass = getPsiClass();
    if (psiClass != null) {
      getProperties().myClassPattern = psiClass.getQualifiedName();
    }
    if (myIsStatic) {
      setInstanceFiltersEnabled(false);
    }
  }

  private static void createRequestForSubClasses(@NotNull MethodBreakpointBase breakpoint,
                                                 @NotNull DebugProcessImpl debugProcess,
                                                 @NotNull ReferenceType baseType) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    RequestManagerImpl requestsManager = debugProcess.getRequestsManager();
    ClassPrepareRequest request = requestsManager.createClassPrepareRequest((debuggerProcess, referenceType) -> {
      if (DebuggerUtilsImpl.instanceOf(referenceType, baseType)) {
        createRequestForPreparedClassEmulated(breakpoint, debugProcess, referenceType, false);
      }
    }, null);
    if (request != null) {
      requestsManager.registerRequest(breakpoint, request);
      request.enable();
    }

    ProgressWindow indicator =
      new ProgressWindow(true, false, debugProcess.getProject(), JavaDebuggerBundle.message("cancel.emulation"));
    indicator.setDelayInMillis(2000);

    AtomicBoolean changed = new AtomicBoolean();
    XBreakpointListener<XBreakpoint<?>> listener = new XBreakpointListener<XBreakpoint<?>>() {
      void changed(@NotNull XBreakpoint b) {
        if (b == breakpoint.getXBreakpoint()) {
          changed.set(true);
          indicator.cancel();
        }
      }

      @Override
      public void breakpointRemoved(@NotNull XBreakpoint b) {
        changed(b);
      }

      @Override
      public void breakpointChanged(@NotNull XBreakpoint b) {
        changed(b);
      }
    };

    debugProcess.getProject().getMessageBus().connect(indicator).subscribe(XBreakpointListener.TOPIC, listener);
    ProgressManager.getInstance().executeProcessUnderProgress(
      () -> processPreparedSubTypes(baseType,
                                    (subType, classesByName) ->
                                      createRequestForPreparedClassEmulated(breakpoint, debugProcess, subType, classesByName, false),
                                    indicator),
      indicator);
    if (indicator.isCanceled() && !changed.get()) {
      breakpoint.disableEmulation();
    }
  }

  @Override
  public void disableEmulation() {
    MethodBreakpointBase.disableEmulation(this);
  }

  static void createRequestForPreparedClassEmulated(@NotNull MethodBreakpointBase breakpoint,
                                                    @NotNull DebugProcessImpl debugProcess,
                                                    @NotNull ReferenceType classType,
                                                    boolean base) {
    createRequestForPreparedClassEmulated(breakpoint, debugProcess, classType, debugProcess.getVirtualMachineProxy().getClassesByNameProvider(), base);
  }

  static void createRequestForPreparedClassEmulated(@NotNull MethodBreakpointBase breakpoint,
                                                    @NotNull DebugProcessImpl debugProcess,
                                                    @NotNull ReferenceType classType,
                                                    @NotNull ClassesByNameProvider classesByName,
                                                    boolean base) {
    if (breakpoint.isWatchExit() && !MethodBreakpointBase.canBeWatchExitEmulated(debugProcess)) {
      breakpoint.disableEmulation();
      return;
    }
    if (!base && !shouldCreateRequest(breakpoint, breakpoint.getXBreakpoint(), debugProcess, true)) {
      return;
    }
    Method lambdaMethod = MethodBytecodeUtil.getLambdaMethod(classType, classesByName);
    if (lambdaMethod != null &&
        breakpoint
          .matchingMethods(StreamEx.of(((ClassType)classType).interfaces()).flatCollection(ReferenceType::allMethods), debugProcess)
          .findFirst().isEmpty()) {
      return;
    }
    StreamEx<Method> methods = lambdaMethod != null
                               ? StreamEx.of(lambdaMethod)
                               : breakpoint.matchingMethods(StreamEx.of(classType.methods()).filter(m -> base || !m.isAbstract()), debugProcess);
    boolean found = false;
    for (Method method : methods) {
      found = true;
      if (method.isNative()) {
        LOG.info("Breakpoint emulation was disabled because " + method + " is native");
        breakpoint.disableEmulation();
        return;
      }
      else if (method.isAbstract()) {
        continue;
      }

      Method target = MethodBytecodeUtil.getBridgeTargetMethod(method, classesByName);
      if (target != null) {
        method = target;
      }

      if (breakpoint.isWatchEntry()) {
        // We assume that all VMs start code indexes from zero.
        Location location = new LocationCodeIndexOnly(method, 0);
        createLocationBreakpointRequest(breakpoint, location, debugProcess, true);
      }

      if (breakpoint.isWatchExit()) {
        final Method finalMethod = method;
        class BytecodeVisitor extends MethodVisitor implements MethodBytecodeUtil.InstructionOffsetReader {
          private int bytecodeOffset = -1;

          BytecodeVisitor() {
            super(Opcodes.API_VERSION);
          }

          @Override
          public void readBytecodeInstructionOffset(int offset) {
            bytecodeOffset = offset;
          }

          @Override
          public void visitInsn(int opcode) {
            if (Opcodes.IRETURN <= opcode && opcode <= Opcodes.RETURN) {
              assert bytecodeOffset >= 0;
              Location location = new LocationCodeIndexOnly(finalMethod, bytecodeOffset);
              createLocationBreakpointRequest(breakpoint, location, debugProcess, false);
            }
          }
        }
        MethodBytecodeUtil.visit(method, new BytecodeVisitor(), false);
      }
    }
    if (base && found) {
      // desired class found - now also track all new classes
      createRequestForSubClasses(breakpoint, debugProcess, classType);
    }
  }

  private static void createLocationBreakpointRequest(@NotNull FilteredRequestor requestor,
                                                      @Nullable Location location,
                                                      @NotNull DebugProcessImpl debugProcess,
                                                      boolean methodEntry) {
    BreakpointRequest request = createLocationBreakpointRequest(requestor, location, debugProcess);
    if (request != null) {
      request.putProperty(METHOD_ENTRY_KEY, methodEntry);
    }
  }

  @Override
  protected void createRequestForPreparedClass(@NotNull DebugProcessImpl debugProcess, @NotNull ReferenceType classType) {
    if (isEmulated()) {
      createRequestForPreparedClassEmulated(this, debugProcess, classType, true);
    }
    else {
      createRequestForPreparedClassOriginal(debugProcess, classType);
    }
  }

  /**
   * Return `true` if the method has the same name and signature as the breakpoint.
   */
  protected boolean isMethodMatch(@NotNull Method method, @NotNull DebugProcessImpl debugProcess) {
    try {
      String name = getMethodName();
      return
        name != null && name.equals(method.name()) &&
        mySignature != null && mySignature.getName(debugProcess).equals(method.signature());
    }
    catch (EvaluateException e) {
      LOG.debug("Should not happen. mySignature is a JVMRawText and it doesn't throw", e);
      return false;
    }
  }

  private void createRequestForPreparedClassOriginal(@NotNull DebugProcessImpl debugProcess, @NotNull ReferenceType classType) {
    boolean hasMethod = false;
    for (Method method : classType.allMethods()) {
      if (isMethodMatch(method, debugProcess)) {
        hasMethod = true;
        break;
      }
    }

    if (!hasMethod) {
      debugProcess.getRequestsManager().setInvalid(
        this, JavaDebuggerBundle.message("error.invalid.breakpoint.method.not.found", classType.name())
      );
      return;
    }

    RequestManagerImpl requestManager = debugProcess.getRequestsManager();
    if (isWatchEntry()) {
      MethodEntryRequest entryRequest = findRequest(debugProcess, MethodEntryRequest.class, this);
      if (entryRequest == null) {
        entryRequest = requestManager.createMethodEntryRequest(this);
      }
      else {
        entryRequest.disable();
      }
      //entryRequest.addClassFilter(myClassQualifiedName);
      // use addClassFilter(ReferenceType) in order to stop on subclasses also!
      entryRequest.addClassFilter(classType);
      debugProcess.getRequestsManager().enableRequest(entryRequest);
    }
    if (isWatchExit()) {
      MethodExitRequest exitRequest = findRequest(debugProcess, MethodExitRequest.class, this);
      if (exitRequest == null) {
        exitRequest = requestManager.createMethodExitRequest(this);
      }
      else {
        exitRequest.disable();
      }
      //exitRequest.addClassFilter(myClassQualifiedName);
      exitRequest.addClassFilter(classType);
      debugProcess.getRequestsManager().enableRequest(exitRequest);
    }
  }

  @Override
  public String getEventMessage(@NotNull LocatableEvent event) {
    return getEventMessage(event, getFileName());
  }

  static @Nls String getEventMessage(@NotNull LocatableEvent event, @NotNull String defaultFileName) {
    Location location = event.location();
    if (event instanceof MethodEntryEvent) {
      return getEventMessage(true, ((MethodEntryEvent)event).method(), location, defaultFileName);
    }
    if (event instanceof MethodExitEvent) {
      return getEventMessage(false, ((MethodExitEvent)event).method(), location, defaultFileName);
    }
    Object entryProperty = event.request().getProperty(METHOD_ENTRY_KEY);
    if (entryProperty instanceof Boolean) {
      return getEventMessage((Boolean)entryProperty, location.method(), location, defaultFileName);
    }
    return "";
  }

  private static @Nls String getEventMessage(boolean entry, Method method, Location location, String defaultFileName) {
    String locationQName = DebuggerUtilsEx.getLocationMethodQName(location);
    String locationFileName = DebuggerUtilsEx.getSourceName(location, e -> defaultFileName);
    int locationLine = location.lineNumber();
    return JavaDebuggerBundle.message(entry ? "status.method.entry.breakpoint.reached" : "status.method.exit.breakpoint.reached",
                                      method.declaringType().name() + "." + method.name() + "()",
                                      locationQName,
                                      locationFileName,
                                      locationLine
    );
  }

  @Override
  public PsiElement getEvaluationElement() {
    return getPsiClass();
  }

  @Override
  protected Icon getDisabledIcon(boolean isMuted) {
    if (DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().findMasterBreakpoint(this) != null && isMuted) {
      return AllIcons.Debugger.Db_muted_dep_method_breakpoint;
    }
    return null;
  }

  @Override
  protected Icon getVerifiedIcon(boolean isMuted) {
    return isSuspend() ? AllIcons.Debugger.Db_verified_method_breakpoint : AllIcons.Debugger.Db_verified_no_suspend_method_breakpoint;
  }

  @Override
  @NotNull
  protected Icon getVerifiedWarningsIcon(boolean isMuted) {
    return new LayeredIcon(isMuted ? AllIcons.Debugger.Db_muted_method_breakpoint : AllIcons.Debugger.Db_method_breakpoint,
                           AllIcons.General.WarningDecorator);
  }

  @Override
  public String getDisplayName() {
    final @Nls StringBuilder buffer = new StringBuilder();
    if (isValid()) {
      final String className = getClassName();
      final boolean classNameExists = className != null && className.length() > 0;
      if (classNameExists) {
        buffer.append(className);
      }
      if (getMethodName() != null) {
        if (classNameExists) {
          buffer.append(".");
        }
        buffer.append(getMethodName());
      }
    }
    else {
      buffer.append(JavaDebuggerBundle.message("status.breakpoint.invalid"));
    }
    return buffer.toString();
  }

  @Override
  public boolean evaluateCondition(@NotNull EvaluationContextImpl context, @NotNull LocatableEvent event) throws EvaluateException {
    if (!matchesEvent(event, context.getDebugProcess())) {
      return false;
    }
    return super.evaluateCondition(context, event);
  }

  public boolean matchesEvent(@NotNull final LocatableEvent event, final DebugProcessImpl process) {
    if (isEmulated()) {
      return true;
    }
    if (getMethodName() == null || mySignature == null) {
      return false;
    }
    final Method method = event.location().method();
    return isMethodMatch(method, process);
  }

  @Nullable
  public static MethodBreakpoint create(@NotNull Project project, XBreakpoint xBreakpoint) {
    final MethodBreakpoint breakpoint = new MethodBreakpoint(project, xBreakpoint);
    return (MethodBreakpoint)breakpoint.init();
  }


  //public boolean canMoveTo(final SourcePosition position) {
  //  return super.canMoveTo(position) && PositionUtil.getPsiElementAt(getProject(), PsiMethod.class, position) != null;
  //}

  /**
   * finds FQ method's class name and method's signature
   */
  @Nullable
  private static MethodDescriptor getMethodDescriptor(@NotNull final Project project, @NotNull final SourcePosition sourcePosition) {
    Document document = PsiDocumentManager.getInstance(project).getDocument(sourcePosition.getFile());
    if (document == null) {
      return null;
    }
    //final int endOffset = document.getLineEndOffset(sourcePosition);
    //final MethodDescriptor descriptor = docManager.commitAndRunReadAction(new Computable<MethodDescriptor>() {
    // conflicts with readAction on initial breakpoints creation
    final MethodDescriptor descriptor = ReadAction.compute(() -> {
      //PsiMethod method = DebuggerUtilsEx.findPsiMethod(psiJavaFile, endOffset);
      PsiMethod method = PositionUtil.getPsiElementAt(project, PsiMethod.class, sourcePosition);
      if (method == null) {
        return null;
      }
      final int methodOffset = method.getTextOffset();
      if (!DocumentUtil.isValidOffset(methodOffset, document) || document.getLineNumber(methodOffset) < sourcePosition.getLine()) {
        return null;
      }

      final PsiIdentifier identifier = method.getNameIdentifier();
      int methodNameOffset = identifier != null ? identifier.getTextOffset() : methodOffset;
      final MethodDescriptor res =
        new MethodDescriptor();
      res.methodName = JVMNameUtil.getJVMMethodName(method);
      try {
        res.methodSignature = JVMNameUtil.getJVMSignature(method);
        res.isStatic = method.hasModifierProperty(PsiModifier.STATIC);
      }
      catch (IndexNotReadyException ignored) {
        return null;
      }
      res.methodLine = document.getLineNumber(methodNameOffset);
      return res;
    });
    if (descriptor == null || descriptor.methodName == null || descriptor.methodSignature == null) {
      return null;
    }
    return descriptor;
  }

  @Nullable
  static <T extends EventRequest> T findRequest(@NotNull DebugProcessImpl debugProcess, Class<T> requestClass, Requestor requestor) {
    return StreamEx.of(debugProcess.getRequestsManager().findRequests(requestor)).select(requestClass).findFirst().orElse(null);
  }

  @Override
  public void readExternal(@NotNull Element breakpointNode) throws InvalidDataException {
    super.readExternal(breakpointNode);
    try {
      getProperties().WATCH_ENTRY = Boolean.parseBoolean(JDOMExternalizerUtil.readField(breakpointNode, "WATCH_ENTRY"));
    }
    catch (Exception ignored) {
    }
    try {
      getProperties().WATCH_EXIT = Boolean.parseBoolean(JDOMExternalizerUtil.readField(breakpointNode, "WATCH_EXIT"));
    }
    catch (Exception ignored) {
    }
  }

  public boolean isEmulated() {
    return getProperties().EMULATED;
  }

  @Override
  public boolean isWatchEntry() {
    return getProperties().WATCH_ENTRY;
  }

  @Override
  public boolean isWatchExit() {
    return getProperties().WATCH_EXIT;
  }

  @Override
  public StreamEx<Method> matchingMethods(StreamEx<Method> methods, DebugProcessImpl debugProcess) {
    try {
      String methodName = getMethodName();
      String signature = mySignature != null ? mySignature.getName(debugProcess) : null;
      return methods.filter(m -> Objects.equals(methodName, m.name()) && Objects.equals(signature, m.signature())).limit(1);
    }
    catch (EvaluateException e) {
      LOG.warn(e);
    }
    return StreamEx.empty();
  }

  @Nullable
  protected String getMethodName() {
    return getProperties().myMethodName;
  }

  protected void setMethodName(@Nullable String methodName) {
    getProperties().myMethodName = methodName;
  }

  public static final class MethodDescriptor {
    public String methodName;
    public JVMName methodSignature;
    public boolean isStatic;
    public int methodLine;
  }

  private static void processPreparedSubTypes(ReferenceType classType,
                                              BiConsumer<? super ReferenceType, ? super ClassesByNameProvider> consumer,
                                              ProgressIndicator progressIndicator) {
    long start = 0;
    if (LOG.isDebugEnabled()) {
      start = System.currentTimeMillis();
    }
    progressIndicator.setIndeterminate(false);
    progressIndicator.start();
    progressIndicator.setText(JavaDebuggerBundle.message("label.method.breakpoints.processing.classes"));
    try {
      MultiMap<ReferenceType, ReferenceType> inheritance = MultiMap.createConcurrentSet();
      List<ReferenceType> allTypes = classType.virtualMachine().allClasses();
      int allSize = allTypes.size();
      List<CompletableFuture> futures = new ArrayList<>();
      AtomicInteger processed = new AtomicInteger();
      for (ReferenceType type : allTypes) {
        if (progressIndicator.isCanceled()) {
          return;
        }
        if (type.isPrepared()) {
          futures.add(DebuggerUtilsAsync.supertypes(type)
                        .thenAccept(supertypes -> supertypes.forEach(st -> inheritance.putValue(st, type)))
                        .exceptionally(throwable -> {
                          throwable = DebuggerUtilsAsync.unwrap(throwable);
                          if (throwable instanceof ObjectCollectedException) {
                            return null;
                          }
                          throw new CompletionException(throwable);
                        })
                        .thenRun(() -> updateProgress(progressIndicator, processed.incrementAndGet(), allSize)));
        }
      }
      CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
      List<ReferenceType> types = StreamEx.ofTree(classType, t -> StreamEx.of(inheritance.get(t))).skip(1).toList();

      if (LOG.isDebugEnabled()) {
        long current = System.currentTimeMillis();
        LOG.debug("Processed  " + allSize + " classes in " + (current - start) + "ms");
        start = current;
      }

      progressIndicator.setText(JavaDebuggerBundle.message("label.method.breakpoints.setting.breakpoints"));

      ClassesByNameProvider classesByName = ClassesByNameProvider.createCache(allTypes);

      int typesSize = types.size();
      for (int i = 0; i < typesSize; i++) {
        if (progressIndicator.isCanceled()) {
          return;
        }
        consumer.accept(types.get(i), classesByName);
        updateProgress(progressIndicator, i, typesSize);
      }

      if (LOG.isDebugEnabled()) {
        LOG.debug("Created " + typesSize + " requests in " + (System.currentTimeMillis() - start) + "ms");
      }
    }
    finally {
      progressIndicator.stop();
    }
  }

  private static void updateProgress(ProgressIndicator progressIndicator, int current, int total) {
    progressIndicator.setText2(current + "/" + total);
    progressIndicator.setFraction((double)current / total);
  }

  /**
   * Optimized {@link Location} which should be used only to create breakpoint
   * at known valid code index.
   * <p/>
   * The key difference with {@link com.jetbrains.jdi.ConcreteMethodImpl#locationOfCodeIndex(long)}
   * is an absence of index validity checks, which normally would require to load line number information.
   */
  private static class LocationCodeIndexOnly implements Location {
    private final Method method;
    private final long codeIndex;

    public LocationCodeIndexOnly(Method method, long codeIndex) {
      assert !method.isNative() && !method.isAbstract();
      assert codeIndex >= 0;

      this.method = method;
      this.codeIndex = codeIndex;
    }

    @Override
    public VirtualMachine virtualMachine() {
      return method.virtualMachine();
    }

    @Override
    public ReferenceType declaringType() {
      return method.declaringType();
    }

    @Override
    public Method method() {
      return method;
    }

    @Override
    public long codeIndex() {
      return codeIndex;
    }

    @Override
    public boolean equals(Object other) {
      if (this == other) return true;
      if (other == null || getClass() != other.getClass()) return false;
      LocationCodeIndexOnly that = (LocationCodeIndexOnly)other;
      return this.codeIndex == that.codeIndex &&
             this.method.equals(that.method);
    }

    @Override
    public int hashCode() {
      return Objects.hash(method, codeIndex);
    }

    @Override
    public int compareTo(@NotNull Location that) {
      // Same as in LocationImpl
      int res = this.method().compareTo(that.method());
      if (res != 0) {
        return res;
      }
      return Long.compare(codeIndex(), that.codeIndex());
    }

    // region Absent information about source code
    @Override
    public int lineNumber() {
      return -1;
    }

    @Override
    public int lineNumber(String stratum) {
      return -1;
    }

    @Override
    public String sourceName() throws AbsentInformationException {
      throw new AbsentInformationException();
    }

    @Override
    public String sourceName(String stratum) throws AbsentInformationException {
      throw new AbsentInformationException();
    }

    @Override
    public String sourcePath() throws AbsentInformationException {
      throw new AbsentInformationException();
    }

    @Override
    public String sourcePath(String stratum) throws AbsentInformationException {
      throw new AbsentInformationException();
    }
    // endregion
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.jdi.VirtualMachineProxyImpl;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.sun.jdi.Method;
import one.util.streamex.StreamEx;
import org.jetbrains.java.debugger.breakpoints.properties.JavaMethodBreakpointProperties;

public interface MethodBreakpointBase extends FilteredRequestor {
  String METHOD_ENTRY_KEY = "METHOD_ENTRY_KEY";

  XBreakpoint<JavaMethodBreakpointProperties> getXBreakpoint();

  boolean isWatchEntry();

  boolean isWatchExit();

  StreamEx<Method> matchingMethods(StreamEx<Method> methods, DebugProcessImpl debugProcess);

  void disableEmulation();

  static boolean canBeWatchExitEmulated(DebugProcessImpl debugProcess) {
    VirtualMachineProxyImpl virtualMachineProxy = debugProcess.getVirtualMachineProxy();
    return virtualMachineProxy.canGetBytecodes() && virtualMachineProxy.canGetConstantPool();
  }

  static void disableEmulation(Breakpoint<JavaMethodBreakpointProperties> breakpoint) {
    ApplicationManager.getApplication().invokeLater(() -> {
      breakpoint.getProperties().EMULATED = false;
      breakpoint.fireBreakpointChanged();
    });
  }
}
/*
 * Copyright 2000-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.ui.IdeBorderFactory;
import com.intellij.util.ui.DialogUtil;
import com.intellij.util.ui.JBUI;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import com.intellij.xdebugger.impl.breakpoints.XBreakpointBase;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.java.debugger.breakpoints.properties.JavaMethodBreakpointProperties;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class MethodBreakpointPropertiesPanel extends XBreakpointCustomPropertiesPanel<XBreakpoint<JavaMethodBreakpointProperties>> {
  private JCheckBox myEmulatedCheckBox;
  private JCheckBox myWatchEntryCheckBox;
  private JCheckBox myWatchExitCheckBox;

  //public MethodBreakpointPropertiesPanel(final Project project, boolean compact) {
  //  super(project, MethodBreakpoint.CATEGORY, compact);
  //}


  @NotNull
  @Override
  public JComponent getComponent() {
    JPanel _panel, _panel0;

    myEmulatedCheckBox = new JCheckBox(JavaDebuggerBundle.message("label.method.breakpoint.properties.panel.emulated"));
    myWatchEntryCheckBox = new JCheckBox(JavaDebuggerBundle.message("label.method.breakpoint.properties.panel.method.entry"));
    myWatchExitCheckBox = new JCheckBox(JavaDebuggerBundle.message("label.method.breakpoint.properties.panel.method.exit"));
    DialogUtil.registerMnemonic(myWatchEntryCheckBox);
    DialogUtil.registerMnemonic(myWatchExitCheckBox);


    Box watchBox = Box.createVerticalBox();
    _panel = JBUI.Panels.simplePanel();
    _panel.add(myEmulatedCheckBox, BorderLayout.NORTH);
    watchBox.add(_panel);
    _panel = new JPanel(new BorderLayout());
    _panel.add(myWatchEntryCheckBox, BorderLayout.NORTH);
    watchBox.add(_panel);
    _panel = new JPanel(new BorderLayout());
    _panel.add(myWatchExitCheckBox, BorderLayout.NORTH);
    watchBox.add(_panel);

    _panel = new JPanel(new BorderLayout());
    _panel0 = new JPanel(new BorderLayout());
    _panel0.add(watchBox, BorderLayout.CENTER);
    _panel0.add(Box.createHorizontalStrut(3), BorderLayout.WEST);
    _panel0.add(Box.createHorizontalStrut(3), BorderLayout.EAST);
    _panel.add(_panel0, BorderLayout.NORTH);
    _panel.setBorder(IdeBorderFactory.createTitledBorder(JavaDebuggerBundle.message("label.group.watch.events")));

    ActionListener listener = new ActionListener() {
      @Override
      public void actionPerformed(ActionEvent e) {
        JCheckBox toCheck = null;
        if (!myWatchEntryCheckBox.isSelected() && !myWatchExitCheckBox.isSelected()) {
          Object source = e.getSource();
          if (myWatchEntryCheckBox.equals(source)) {
            toCheck = myWatchExitCheckBox;
          }
          else if (myWatchExitCheckBox.equals(source)) {
            toCheck = myWatchEntryCheckBox;
          }
          if (toCheck != null) {
            toCheck.setSelected(true);
          }
        }
      }
    };
    myWatchEntryCheckBox.addActionListener(listener);
    myWatchExitCheckBox.addActionListener(listener);

    return _panel;
  }

  @Override
  public void loadFrom(@NotNull XBreakpoint<JavaMethodBreakpointProperties> breakpoint) {
    myEmulatedCheckBox.setSelected(breakpoint.getProperties().EMULATED);

    myWatchEntryCheckBox.setSelected(breakpoint.getProperties().WATCH_ENTRY);
    myWatchExitCheckBox.setSelected(breakpoint.getProperties().WATCH_EXIT);
  }

  @Override
  public void saveTo(@NotNull XBreakpoint<JavaMethodBreakpointProperties> breakpoint) {
    boolean changed = breakpoint.getProperties().EMULATED != myEmulatedCheckBox.isSelected();
    breakpoint.getProperties().EMULATED = myEmulatedCheckBox.isSelected();
    changed = breakpoint.getProperties().WATCH_ENTRY != myWatchEntryCheckBox.isSelected() || changed;
    breakpoint.getProperties().WATCH_ENTRY = myWatchEntryCheckBox.isSelected();
    changed = breakpoint.getProperties().WATCH_EXIT != myWatchExitCheckBox.isSelected() || changed;
    breakpoint.getProperties().WATCH_EXIT = myWatchExitCheckBox.isSelected();
    if (changed) {
      ((XBreakpointBase<?, ?, ?>)breakpoint).fireBreakpointChanged();
    }
  }
}
// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.RequestHint;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiManager;
import com.intellij.xdebugger.XDebuggerUtil;
import com.intellij.xdebugger.XSourcePosition;
import com.intellij.xdebugger.breakpoints.XLineBreakpointType;
import com.sun.jdi.event.LocatableEvent;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * @author Eugene Zhuravlev
 */
public class RunToCursorBreakpoint extends SyntheticLineBreakpoint implements SteppingBreakpoint {
  private final boolean myRestoreBreakpoints;
  @NotNull
  protected final SourcePosition myCustomPosition;

  protected RunToCursorBreakpoint(@NotNull Project project, @NotNull SourcePosition pos, boolean restoreBreakpoints) {
    super(project);
    myCustomPosition = pos;
    myRestoreBreakpoints = restoreBreakpoints;
  }

  @NotNull
  @Override
  public SourcePosition getSourcePosition() {
    return myCustomPosition;
  }

  @Override
  public int getLineIndex() {
    return myCustomPosition.getLine();
  }

  @Override
  protected String getFileName() {
    return myCustomPosition.getFile().getName();
  }

  @Override
  public boolean isRestoreBreakpoints() {
    return myRestoreBreakpoints;
  }

  @Override
  public String getEventMessage(LocatableEvent event) {
    return JavaDebuggerBundle.message("status.stopped.at.cursor");
  }

  @Nullable
  @Override
  protected JavaLineBreakpointType getXBreakpointType() {
    SourcePosition position = getSourcePosition();
    VirtualFile file = position.getFile().getVirtualFile();
    int line = position.getLine();
    for (XLineBreakpointType<?> type : XDebuggerUtil.getInstance().getLineBreakpointTypes()) {
      if (type instanceof JavaLineBreakpointType && type.canPutAt(file, line, myProject)) {
        return ((JavaLineBreakpointType)type);
      }
    }
    return null;
  }

  @Nullable
  protected static RunToCursorBreakpoint create(@NotNull Project project, @NotNull XSourcePosition position, boolean restoreBreakpoints) {
    PsiFile psiFile = PsiManager.getInstance(project).findFile(position.getFile());
    if (psiFile == null) {
      return null;
    }
    return new RunToCursorBreakpoint(project, SourcePosition.createFromOffset(psiFile, position.getOffset()), restoreBreakpoints);
  }

  @Override
  public void setRequestHint(RequestHint hint) {
  }

  @Override
  public boolean track() {
    return false;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.*;
import com.intellij.debugger.engine.evaluation.*;
import com.intellij.debugger.engine.evaluation.expression.Evaluator;
import com.intellij.debugger.engine.evaluation.expression.EvaluatorBuilderImpl;
import com.intellij.debugger.engine.evaluation.expression.ExpressionEvaluator;
import com.intellij.debugger.engine.evaluation.expression.ExpressionEvaluatorImpl;
import com.intellij.debugger.engine.events.SuspendContextCommandImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.jdi.DecompiledLocalVariable;
import com.intellij.debugger.jdi.StackFrameProxyImpl;
import com.intellij.debugger.jdi.ThreadReferenceProxyImpl;
import com.intellij.debugger.memory.utils.StackFrameItem;
import com.intellij.debugger.settings.CapturePoint;
import com.intellij.debugger.settings.DebuggerSettings;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.PsiElement;
import com.intellij.ui.SimpleColoredComponent;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.containers.FixedHashMap;
import com.sun.jdi.*;
import com.sun.jdi.event.LocatableEvent;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.CopyOnWriteArrayList;


public class StackCapturingLineBreakpoint extends SyntheticMethodBreakpoint {
  private static final Logger LOG = Logger.getInstance(StackCapturingLineBreakpoint.class);

  private final CapturePoint myCapturePoint;

  private final MyEvaluator myCaptureEvaluator;
  private final MyEvaluator myInsertEvaluator;

  public static final Key<List<StackCapturingLineBreakpoint>> CAPTURE_BREAKPOINTS = Key.create("CAPTURE_BREAKPOINTS");
  private static final Key<Map<Object, List<StackFrameItem>>> CAPTURED_STACKS = Key.create("CAPTURED_STACKS");
  private static final int MAX_STORED_STACKS = 1000;

  public StackCapturingLineBreakpoint(Project project, CapturePoint capturePoint) {
    super(capturePoint.myClassName, capturePoint.myMethodName, null, project);
    myCapturePoint = capturePoint;
    myCaptureEvaluator = new MyEvaluator(myCapturePoint.myCaptureKeyExpression);
    myInsertEvaluator = new MyEvaluator(myCapturePoint.myInsertKeyExpression);
    setSuspendPolicy(DebuggerSettings.SUSPEND_THREAD);
  }

  @Override
  public boolean processLocatableEvent(@NotNull SuspendContextCommandImpl action, LocatableEvent event) {
    SuspendContextImpl suspendContext = action.getSuspendContext();
    if (suspendContext != null) {
      ThreadReferenceProxyImpl thread = suspendContext.getThread();
      if (thread != null) {
        DebugProcessImpl process = suspendContext.getDebugProcess();
        try {
          StackFrameProxyImpl frameProxy = ContainerUtil.getFirstItem(thread.forceFrames());
          if (frameProxy != null) {
            Map<Object, List<StackFrameItem>> stacks = process.getUserData(CAPTURED_STACKS);
            if (stacks == null) {
              stacks = new FixedHashMap<>(MAX_STORED_STACKS);
              AsyncStacksUtils.putProcessUserData(CAPTURED_STACKS, Collections.synchronizedMap(stacks), process);
            }
            Value key = myCaptureEvaluator.evaluate(new EvaluationContextImpl(suspendContext, frameProxy));
            if (key instanceof ObjectReference) {
              List<StackFrameItem> frames = StackFrameItem.createFrames(suspendContext, true);
              frames = ContainerUtil.getFirstItems(frames, AsyncStacksUtils.getMaxStackLength());
              stacks.put(getKey((ObjectReference)key), frames);
            }
          }
        }
        catch (EvaluateException e) {
          LOG.debug(e);
          process.printToConsole(JavaDebuggerBundle.message("error.unable.to.evaluate.capture.expression", e.getMessage()) + "\n");
        }
      }
    }

    return false;
  }

  public static void deleteAll(DebugProcessImpl debugProcess) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    List<StackCapturingLineBreakpoint> bpts = debugProcess.getUserData(CAPTURE_BREAKPOINTS);
    if (!ContainerUtil.isEmpty(bpts)) {
      bpts.forEach(debugProcess.getRequestsManager()::deleteRequest);
      bpts.clear();
    }
  }

  public static void createAll(DebugProcessImpl debugProcess) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    DebuggerSettings.getInstance().getCapturePoints().stream().filter(c -> c.myEnabled).forEach(c -> track(debugProcess, c));
  }

  public static void clearCaches(DebugProcessImpl debugProcess) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    List<StackCapturingLineBreakpoint> bpts = debugProcess.getUserData(CAPTURE_BREAKPOINTS);
    if (!ContainerUtil.isEmpty(bpts)) {
      bpts.forEach(b -> {
        b.myCaptureEvaluator.clearCache();
        b.myInsertEvaluator.clearCache();
      });
    }
  }

  @Override
  public void createRequest(DebugProcessImpl debugProcess) {
    if (!StringUtil.isEmpty(getClassName())) {
      super.createRequest(debugProcess);
    }
  }

  @Override
  public void customizeRenderer(SimpleColoredComponent renderer) {
    renderer.append(JavaDebuggerBundle.message("label.capture.point.at", myCapturePoint.myClassName, myCapturePoint.myMethodName));
  }

  @Override
  public boolean isEnabled() {
    return myCapturePoint.myEnabled;
  }

  @Override
  public void setEnabled(boolean enabled) {
    myCapturePoint.myEnabled = enabled;
    DebuggerSettings.getInstance().setCapturePoints(DebuggerSettings.getInstance().getCapturePoints()); // to fire change event
  }

  private static void track(DebugProcessImpl debugProcess, CapturePoint capturePoint) {
    StackCapturingLineBreakpoint breakpoint = new StackCapturingLineBreakpoint(debugProcess.getProject(), capturePoint);
    breakpoint.createRequest(debugProcess);
    List<StackCapturingLineBreakpoint> bpts = debugProcess.getUserData(CAPTURE_BREAKPOINTS);
    if (bpts == null) {
      bpts = new CopyOnWriteArrayList<>();
      AsyncStacksUtils.putProcessUserData(CAPTURE_BREAKPOINTS, bpts, debugProcess);
    }
    bpts.add(breakpoint);
  }

  @Nullable
  public static List<StackFrameItem> getRelatedStack(@NotNull StackFrameProxyImpl frame, @NotNull SuspendContextImpl suspendContext) {
    DebugProcessImpl debugProcess = suspendContext.getDebugProcess();
    Map<Object, List<StackFrameItem>> capturedStacks = debugProcess.getUserData(CAPTURED_STACKS);
    if (ContainerUtil.isEmpty(capturedStacks)) {
      return null;
    }
    List<StackCapturingLineBreakpoint> captureBreakpoints = debugProcess.getUserData(CAPTURE_BREAKPOINTS);
    if (ContainerUtil.isEmpty(captureBreakpoints)) {
      return null;
    }
    try {
      Location location = frame.location();
      String className = location.declaringType().name();
      String methodName = DebuggerUtilsEx.getLocationMethodName(location);

      for (StackCapturingLineBreakpoint b : captureBreakpoints) {
        String insertClassName = b.myCapturePoint.myInsertClassName;
        if ((StringUtil.isEmpty(insertClassName) || StringUtil.equals(insertClassName, className)) &&
            StringUtil.equals(b.myCapturePoint.myInsertMethodName, methodName)) {
          try {
            Value key = b.myInsertEvaluator.evaluate(new EvaluationContextImpl(suspendContext, frame));
            return key instanceof ObjectReference ? capturedStacks.get(getKey((ObjectReference)key)) : null;
          }
          catch (EvaluateException e) {
            LOG.debug(e);
            if (!(e.getCause() instanceof IncompatibleThreadStateException)) {
              debugProcess.printToConsole(JavaDebuggerBundle.message("error.unable.to.evaluate.insert.expression", e.getMessage()) + "\n");
            }
          }
        }
      }
    }
    catch (EvaluateException e) {
      LOG.debug(e);
    }
    return null;
  }

  @Nullable
  public static List<StackFrameItem> getRelatedStack(@Nullable ObjectReference key, @Nullable DebugProcessImpl process) {
    if (process != null && key != null) {
      Map<Object, List<StackFrameItem>> data = process.getUserData(CAPTURED_STACKS);
      if (data != null) {
        return data.get(getKey(key));
      }
    }
    return null;
  }

  private static Object getKey(ObjectReference reference) {
    return reference instanceof StringReference ? ((StringReference)reference).value() : reference;
  }

  private static class MyEvaluator {
    private final String myExpression;
    private ExpressionEvaluator myEvaluator;
    private final Map<Location, ExpressionEvaluator> myEvaluatorCache = new WeakHashMap<>();

    MyEvaluator(String expression) {
      myExpression = expression;
      int paramId = DecompiledLocalVariable.getParamId(myExpression);
      boolean paramEvaluator = paramId > -1;
      if (paramEvaluator) {
        myEvaluator = new ExpressionEvaluatorImpl(new Evaluator() {
          @Override
          public Object evaluate(EvaluationContextImpl context) throws EvaluateException {
            @SuppressWarnings("ConstantConditions")
            List<Value> argumentValues = context.getFrameProxy().getArgumentValues();
            if (paramId >= argumentValues.size()) {
              throw new EvaluateException("Param index " + paramId + " requested, but only " + argumentValues.size() + " available");
            }
            return argumentValues.get(paramId);
          }
        });
      }
    }

    @Nullable
    Value evaluate(final EvaluationContext context) throws EvaluateException {
      ExpressionEvaluator evaluator = myEvaluator;
      if (evaluator == null) {
        @SuppressWarnings("ConstantConditions")
        Location location = context.getFrameProxy().location();
        evaluator = location == null ? null : myEvaluatorCache.get(location);
        if (evaluator == null && !StringUtil.isEmpty(myExpression)) {
          evaluator = ReadAction.compute(() -> {
            SourcePosition sourcePosition = ContextUtil.getSourcePosition(context);
            PsiElement contextElement = ContextUtil.getContextElement(sourcePosition);
            return EvaluatorBuilderImpl.build(
              new TextWithImportsImpl(CodeFragmentKind.EXPRESSION, myExpression), contextElement, sourcePosition, context.getProject());
          });
          myEvaluatorCache.put(location, evaluator);
        }
      }
      if (evaluator != null) {
        return evaluator.evaluate(context);
      }
      return null;
    }

    void clearCache() {
      DebuggerManagerThreadImpl.assertIsManagerThread();
      myEvaluatorCache.clear();
    }
  }

  public static class CaptureAsyncStackTraceProvider implements AsyncStackTraceProvider {
    @Nullable
    @Override
    public List<StackFrameItem> getAsyncStackTrace(@NotNull JavaStackFrame stackFrame, @NotNull SuspendContextImpl suspendContext) {
      return getRelatedStack(stackFrame.getStackFrameProxy(), suspendContext);
    }
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.*;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.events.SuspendContextCommandImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.util.containers.MultiMap;
import com.sun.jdi.*;
import com.sun.jdi.event.LocatableEvent;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Arrays;
import java.util.List;

/**
 * @author Eugene Zhuravlev
 */
public class StepIntoBreakpoint extends RunToCursorBreakpoint {
  private static final Logger LOG = Logger.getInstance(StepIntoBreakpoint.class);
  @NotNull private final BreakpointStepMethodFilter myFilter;
  @Nullable private RequestHint myHint;

  protected StepIntoBreakpoint(@NotNull Project project, @NotNull SourcePosition pos, @NotNull BreakpointStepMethodFilter filter) {
    super(project, pos, false);
    myFilter = filter;
  }

  @Override
  protected void createRequestForPreparedClass(DebugProcessImpl debugProcess, ReferenceType classType) {
    try {
      final CompoundPositionManager positionManager = debugProcess.getPositionManager();
      List<Location> locations = positionManager.locationsOfLine(classType, myCustomPosition);

      if (locations.isEmpty()) {
        // sometimes first statements are mapped to some weird line number, or there are no executable instructions at first statement's line
        // so if lambda or method body spans for more than one lines, try get some locations from these lines
        final int lastLine = myFilter.getLastStatementLine();
        if (lastLine >= 0) {
          int nextLine = myCustomPosition.getLine() + 1;
          while (nextLine <= lastLine && locations.isEmpty()) {
            locations = positionManager.locationsOfLine(classType, SourcePosition.createFromLine(myCustomPosition.getFile(), nextLine++));
          }
        }
      }

      if (!locations.isEmpty()) {
        MultiMap<Method, Location> methods = new MultiMap<>();
        for (Location loc : locations) {
          if (acceptLocation(debugProcess, classType, loc)) {
            methods.putValue(loc.method(), loc);
          }
        }
        Location location = null;
        final int methodsFound = methods.size();
        if (methodsFound == 1) {
          location = methods.values().iterator().next();
        }
        else {
          if (myFilter instanceof LambdaMethodFilter lambdaFilter) {
            if (lambdaFilter.getLambdaOrdinal() < methodsFound) {
              Method[] candidates = methods.keySet().toArray(new Method[methodsFound]);
              Arrays.sort(candidates, DebuggerUtilsEx.LAMBDA_ORDINAL_COMPARATOR);
              location = methods.get(candidates[lambdaFilter.getLambdaOrdinal()]).iterator().next();
            }
          }
          else {
            if (methodsFound > 0) {
              location = methods.values().iterator().next();
            }
          }
        }
        createLocationBreakpointRequest(this, location, debugProcess);
      }
    }
    catch (ClassNotPreparedException ex) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("ClassNotPreparedException: " + ex.getMessage());
      }
    }
    catch (ObjectCollectedException ex) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("ObjectCollectedException: " + ex.getMessage());
      }
    }
    catch (Exception ex) {
      LOG.info(ex);
    }
  }

  @Override
  protected boolean acceptLocation(DebugProcessImpl debugProcess, ReferenceType classType, Location loc) {
    try {
      return myFilter.locationMatches(debugProcess, loc);
    }
    catch (EvaluateException e) {
      LOG.info(e);
    }
    return true;
  }

  @Nullable
  protected static StepIntoBreakpoint create(@NotNull Project project, @NotNull BreakpointStepMethodFilter filter) {
    final SourcePosition pos = filter.getBreakpointPosition();
    if (pos != null) {
      final StepIntoBreakpoint breakpoint = new StepIntoBreakpoint(project, pos, filter);
      breakpoint.init();
      return breakpoint;
    }
    return null;
  }

  @Override
  public boolean processLocatableEvent(@NotNull SuspendContextCommandImpl action, LocatableEvent event)
    throws EventProcessingException {
    boolean res = super.processLocatableEvent(action, event);
    SuspendContextImpl context = action.getSuspendContext();
    if (res && context != null) {
      context.getDebugProcess().resetIgnoreSteppingFilters(event.location(), myHint);
    }
    return res;
  }

  @Override
  public void setRequestHint(RequestHint hint) {
    myHint = hint;
  }
}
// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.RequestHint;
import com.intellij.debugger.requests.Requestor;

public interface SteppingBreakpoint extends Requestor {
  boolean isRestoreBreakpoints();

  void setRequestHint(RequestHint hint);

  void setSuspendPolicy(String s);

  void createRequest(DebugProcessImpl process);
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.openapi.project.Project;
import com.intellij.xdebugger.XDebuggerUtil;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaLineBreakpointProperties;

public class SyntheticLineBreakpoint extends LineBreakpoint<JavaLineBreakpointProperties> {
  private String mySuspendPolicy;
  private final JavaLineBreakpointProperties myProperties = new JavaLineBreakpointProperties();

  public SyntheticLineBreakpoint(@NotNull Project project) {
    super(project, null);
  }

  @Override
  public String getSuspendPolicy() {
    return mySuspendPolicy;
  }

  @Override
  public void setSuspendPolicy(String policy) {
    mySuspendPolicy = policy;
  }

  @Override
  protected boolean isLogEnabled() {
    return false;
  }

  @Override
  protected boolean isLogStack() {
    return false;
  }

  @Override
  protected boolean isLogExpressionEnabled() {
    return false;
  }

  @Override
  public boolean isEnabled() {
    return true;
  }

  @Override
  public void setEnabled(boolean enabled) {
  }

  @Override
  public boolean isCountFilterEnabled() {
    return false;
  }

  @Override
  public boolean isClassFiltersEnabled() {
    return false;
  }

  @Override
  public boolean isConditionEnabled() {
    return false;
  }

  @Override
  public void reload() {
  }

  @Override
  protected boolean isVisible() {
    return false;
  }

  @Override
  public boolean isValid() {
    return true;
  }

  @NotNull
  @Override
  protected JavaLineBreakpointProperties getProperties() {
    return myProperties;
  }

  @Override
  protected void fireBreakpointChanged() {
  }

  @Nullable
  @Override
  protected JavaLineBreakpointType getXBreakpointType() {
    return XDebuggerUtil.getInstance().findBreakpointType(JavaLineBreakpointType.class);
  }

  @Override
  protected boolean isMuted(@NotNull final DebugProcessImpl debugProcess) {
    return false;  // always enabled
  }
}
/*
 * Copyright 2004-2006 Alexey Efimov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.breakpoints;

import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcess;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerManagerThreadImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.requests.RequestManagerImpl;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.JDOMExternalizerUtil;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiElement;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.util.PatternUtil;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.sun.jdi.Method;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.event.LocatableEvent;
import com.sun.jdi.request.MethodEntryRequest;
import com.sun.jdi.request.MethodExitRequest;
import one.util.streamex.StreamEx;
import org.jdom.Element;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.java.debugger.breakpoints.properties.JavaMethodBreakpointProperties;

import javax.swing.*;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

public class WildcardMethodBreakpoint extends Breakpoint<JavaMethodBreakpointProperties> implements MethodBreakpointBase {
  private static final Logger LOG = Logger.getInstance(ExceptionBreakpoint.class);

  public WildcardMethodBreakpoint(Project project, XBreakpoint<JavaMethodBreakpointProperties> breakpoint) {
    super(project, breakpoint);
  }

  @Override
  public Key<MethodBreakpoint> getCategory() {
    return MethodBreakpoint.CATEGORY;
  }

  protected WildcardMethodBreakpoint(Project project, @NotNull String classPattern, @NotNull String methodName, XBreakpoint<JavaMethodBreakpointProperties> breakpoint) {
    super(project, breakpoint);
    setClassPattern(classPattern);
    setMethodName(methodName);
  }

  @Override
  public String getClassName() {
    return getClassPattern();
  }

  @Override
  public @Nullable String getShortClassName() {
    return getClassName();
  }

  public @NlsSafe String getMethodName() {
    return getProperties().myMethodName;
  }

  @Override
  public void disableEmulation() {
    MethodBreakpointBase.disableEmulation(this);
  }

  @Override
  public PsiClass getPsiClass() {
    return ReadAction.compute(() -> getClassName() != null ? DebuggerUtils.findClass(getClassName(), myProject, GlobalSearchScope.allScope(myProject)) : null);
  }

  @Override
  public String getDisplayName() {
    if (!isValid()) {
      return JavaDebuggerBundle.message("status.breakpoint.invalid");
    }
    return getClassPattern() + "." + getMethodName() + "()";
  }

  @Override
  public Icon getIcon() {
    if (!isEnabled()) {
      final Breakpoint master = DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager().findMasterBreakpoint(this);
      return master == null ? AllIcons.Debugger.Db_disabled_method_breakpoint : AllIcons.Debugger.Db_dep_method_breakpoint;
    }
    return AllIcons.Debugger.Db_method_breakpoint;
  }

  @Override
  public void reload() {
  }

  @Override
  public boolean evaluateCondition(EvaluationContextImpl context, LocatableEvent event) throws EvaluateException {
    return (isEmulated() || matchesMethod(event.location().method())) && super.evaluateCondition(context, event);
  }

  @Override
  public void createRequest(DebugProcessImpl debugProcess) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    if (!shouldCreateRequest(debugProcess)) {
      return;
    }
    if (isEmulated()) {
      debugProcess.getRequestsManager().callbackOnPrepareClasses(this, getClassPattern());

      Pattern pattern = PatternUtil.fromMask(getClassPattern());
      debugProcess.getVirtualMachineProxy().allClasses().stream()
        .filter(c -> pattern.matcher(c.name()).matches())
        .filter(ReferenceType::isPrepared)
        .forEach(aList -> processClassPrepare(debugProcess, aList));
    }
    else {
      try {
        RequestManagerImpl requestManager = debugProcess.getRequestsManager();
        if (isWatchEntry()) {
          MethodEntryRequest entryRequest = MethodBreakpoint.findRequest(debugProcess, MethodEntryRequest.class, this);
          if (entryRequest == null) {
            entryRequest = requestManager.createMethodEntryRequest(this);
          }
          else {
            entryRequest.disable();
          }
          entryRequest.addClassFilter(getClassPattern());
          debugProcess.getRequestsManager().enableRequest(entryRequest);
        }
        if (isWatchExit()) {
          MethodExitRequest exitRequest = MethodBreakpoint.findRequest(debugProcess, MethodExitRequest.class, this);
          if (exitRequest == null) {
            exitRequest = requestManager.createMethodExitRequest(this);
          }
          else {
            exitRequest.disable();
          }
          exitRequest.addClassFilter(getClassPattern());
          debugProcess.getRequestsManager().enableRequest(exitRequest);
        }
      }
      catch (Exception e) {
        LOG.debug(e);
      }
    }
  }

  @Override
  public void processClassPrepare(DebugProcess debugProcess, ReferenceType refType) {
    if (isEmulated()) {
      MethodBreakpoint.createRequestForPreparedClassEmulated(this, (DebugProcessImpl)debugProcess, refType, true);
    }
    else {
      // should be empty - does not make sense for this breakpoint
    }
  }

  @Override
  public String getEventMessage(@NotNull LocatableEvent event) {
    return MethodBreakpoint.getEventMessage(event, "");
  }

  @Override
  public boolean isValid() {
    return !StringUtil.isEmpty(getClassPattern()) && !StringUtil.isEmpty(getMethodName());
  }

  //@SuppressWarnings({"HardCodedStringLiteral"}) public void writeExternal(Element parentNode) throws WriteExternalException {
  //  super.writeExternal(parentNode);
  //  parentNode.setAttribute(JDOM_LABEL, "true");
  //  if (getClassPattern() != null) {
  //    parentNode.setAttribute("class_name", getClassPattern());
  //  }
  //  if (getMethodName() != null) {
  //    parentNode.setAttribute("method_name", getMethodName());
  //  }
  //}

  @Override
  public PsiElement getEvaluationElement() {
    return null;
  }

  @Override
  public void readExternal(Element parentNode) throws InvalidDataException {
    super.readExternal(parentNode);

    String className = parentNode.getAttributeValue("class_name");
    setClassPattern(className);

    String methodName = parentNode.getAttributeValue("method_name");
    setMethodName(methodName);

    try {
      getProperties().WATCH_ENTRY = Boolean.parseBoolean(JDOMExternalizerUtil.readField(parentNode, "WATCH_ENTRY"));
    }
    catch (Exception ignored) {
    }
    try {
      getProperties().WATCH_EXIT = Boolean.parseBoolean(JDOMExternalizerUtil.readField(parentNode, "WATCH_EXIT"));
    }
    catch (Exception ignored) {
    }

    if (className == null || methodName == null) {
      throw new InvalidDataException();
    }
  }

  @Override
  public StreamEx<Method> matchingMethods(StreamEx<Method> methods, DebugProcessImpl debugProcess) {
    return methods.filter(this::matchesMethod);
  }

  private boolean matchesMethod(Method method) {
    StringBuilder sb = new StringBuilder();
    for (String mask : StringUtil.split(getMethodName(), ",")) {
      if (sb.length() > 0) {
        sb.append('|');
      }
      sb.append('(').append(PatternUtil.convertToRegex(mask)).append(')');
    }

    try {
      return method != null && Pattern.compile(sb.toString()).matcher(method.name()).matches();
    }
    catch (PatternSyntaxException e) {
      LOG.warn(e);
      return false;
    }
  }

  public static WildcardMethodBreakpoint create(Project project,
                                                final String classPattern,
                                                final String methodName,
                                                XBreakpoint<JavaMethodBreakpointProperties> xBreakpoint) {
    return new WildcardMethodBreakpoint(project, classPattern, methodName, xBreakpoint);
  }

  public boolean isEmulated() {
    return getProperties().EMULATED;
  }

  @Override
  public boolean isWatchEntry() {
    return getProperties().WATCH_ENTRY;
  }

  @Override
  public boolean isWatchExit() {
    return getProperties().WATCH_EXIT;
  }

  private @NlsSafe String getClassPattern() {
    return getProperties().myClassPattern;
  }

  private void setClassPattern(String classPattern) {
    getProperties().myClassPattern = classPattern;
  }

  private void setMethodName(String methodName) {
    getProperties().myMethodName = methodName;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui;

import com.intellij.debugger.DebugEnvironment;
import com.intellij.debugger.DebugUIEnvironment;
import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.DefaultDebugUIEnvironment;
import com.intellij.debugger.engine.JavaDebugProcess;
import com.intellij.debugger.impl.DebuggerSession;
import com.intellij.execution.ExecutionException;
import com.intellij.execution.configurations.RemoteConnection;
import com.intellij.execution.configurations.RunProfileState;
import com.intellij.execution.runners.ExecutionEnvironment;
import com.intellij.execution.ui.RunContentDescriptor;
import com.intellij.openapi.components.Service;
import com.intellij.openapi.project.Project;
import com.intellij.xdebugger.XDebugProcess;
import com.intellij.xdebugger.XDebugProcessStarter;
import com.intellij.xdebugger.XDebugSession;
import com.intellij.xdebugger.XDebuggerManager;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

@Service(Service.Level.PROJECT)
public final class DebuggerPanelsManager {
  private final Project myProject;

  public DebuggerPanelsManager(Project project) {
    myProject = project;
  }

  @Nullable
  public RunContentDescriptor attachVirtualMachine(@NotNull ExecutionEnvironment environment,
                                                   RunProfileState state,
                                                   RemoteConnection remoteConnection,
                                                   boolean pollConnection) throws ExecutionException {
    return attachVirtualMachine(new DefaultDebugUIEnvironment(environment, state, remoteConnection, pollConnection));
  }

  @Nullable
  public RunContentDescriptor attachVirtualMachine(DebugUIEnvironment environment) throws ExecutionException {
    final DebugEnvironment modelEnvironment = environment.getEnvironment();
    final DebuggerSession debuggerSession = DebuggerManagerEx.getInstanceEx(myProject).attachVirtualMachine(modelEnvironment);
    if (debuggerSession == null) {
      return null;
    }

    XDebugSession debugSession =
      XDebuggerManager.getInstance(myProject).startSessionAndShowTab(modelEnvironment.getSessionName(), environment.getReuseContent(), new XDebugProcessStarter() {
        @Override
        @NotNull
        public XDebugProcess start(@NotNull XDebugSession session) {
          return JavaDebugProcess.create(session, debuggerSession);
        }
      });
    return debugSession.getRunContentDescriptor();
  }

  public static DebuggerPanelsManager getInstance(Project project) {
    return project.getService(DebuggerPanelsManager.class);
  }
}
/*
 * Copyright 2000-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui;

import com.intellij.debugger.impl.DebuggerSession;

public interface DebuggerView {

  void setUpdateEnabled(boolean enabled);

  boolean isRefreshNeeded();

  void rebuildIfVisible(final DebuggerSession.Event eventContext);
}
/*
 * Copyright 2000-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui;

import com.intellij.codeInsight.hint.HintManager;
import com.intellij.debugger.DebuggerInvocationUtil;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.events.DebuggerContextCommandImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.progress.ProgressIndicator;
import com.intellij.openapi.progress.util.ProgressIndicatorUtils;
import com.intellij.psi.PsiElement;
import org.jetbrains.annotations.Nullable;

public abstract class EditorEvaluationCommand<T> extends DebuggerContextCommandImpl {
  protected final PsiElement myElement;
  @Nullable private final Editor myEditor;
  protected final ProgressIndicator myProgressIndicator;

  public EditorEvaluationCommand(@Nullable Editor editor, PsiElement expression, DebuggerContextImpl context,
                                 final ProgressIndicator indicator) {
    super(context);
    myProgressIndicator = indicator;
    myEditor = editor;
    myElement = expression;
  }

  @Override
  public Priority getPriority() {
    return Priority.HIGH;
  }

  protected abstract T evaluate(EvaluationContextImpl evaluationContext) throws EvaluateException;

  public T evaluate() throws EvaluateException {
    myProgressIndicator.setText(JavaDebuggerBundle.message("progress.evaluating", ReadAction.compute(myElement::getText)));

    try {
      T result = evaluate(getDebuggerContext().createEvaluationContext());

      ProgressIndicatorUtils.checkCancelledEvenWithPCEDisabled(myProgressIndicator);

      return result;
    }
    catch (final EvaluateException e) {
      if (myEditor != null) {
        DebuggerInvocationUtil.invokeLater(myElement.getProject(),
                                           () -> showEvaluationHint(myEditor, myElement, e),
                                           myProgressIndicator.getModalityState());
      }
      throw e;
    }
  }

  public static void showEvaluationHint(final Editor myEditor, final PsiElement myElement, final EvaluateException e) {
    if (myEditor.isDisposed() || !myEditor.getComponent().isVisible()) return;

    HintManager.getInstance().showErrorHint(myEditor, e.getMessage(), myElement.getTextRange().getStartOffset(),
                                            myElement.getTextRange().getEndOffset(), HintManager.UNDER,
                                            HintManager.HIDE_BY_ESCAPE | HintManager.HIDE_BY_TEXT_CHANGE,
                                            1500);
  }
}
<?xml version="1.0" encoding="UTF-8"?>
<form xmlns="http://www.intellij.com/uidesigner/form/" version="1" bind-to-class="com.intellij.debugger.impl.GenericDebuggerParametersRunnerConfigurable">
  <grid id="a1cd4" binding="myPanel" layout-manager="GridLayoutManager" row-count="3" column-count="2" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
    <margin top="0" left="0" bottom="0" right="0"/>
    <constraints>
      <xy x="53" y="171" width="441" height="105"/>
    </constraints>
    <properties/>
    <border type="none"/>
    <children>
      <grid id="86bed" binding="myShMemPanel" layout-manager="GridLayoutManager" row-count="1" column-count="2" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
        <margin top="0" left="0" bottom="0" right="0"/>
        <constraints>
          <grid row="1" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="3" indent="0" use-parent-layout="false"/>
        </constraints>
        <properties/>
        <border type="none"/>
        <children>
          <component id="9f41f" class="javax.swing.JLabel">
            <constraints>
              <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="0" anchor="4" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.generic.debugger.parameters.patcher.configurable.shmem.address"/>
            </properties>
          </component>
          <component id="af504" class="javax.swing.JTextField" binding="myAddressField">
            <constraints>
              <grid row="0" column="1" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="1" indent="0" use-parent-layout="false">
                <preferred-size width="150" height="-1"/>
              </grid>
            </constraints>
            <properties>
              <text value=""/>
            </properties>
          </component>
        </children>
      </grid>
      <grid id="c2b5" binding="myPortPanel" layout-manager="GridLayoutManager" row-count="1" column-count="2" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
        <margin top="0" left="0" bottom="0" right="0"/>
        <constraints>
          <grid row="2" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="8" fill="2" indent="0" use-parent-layout="false"/>
        </constraints>
        <properties/>
        <border type="none"/>
        <children>
          <component id="6e48a" class="javax.swing.JLabel">
            <constraints>
              <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="0" anchor="4" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.generic.debugger.parameters.patcher.configurable.port"/>
            </properties>
          </component>
          <component id="3f860" class="javax.swing.JTextField" binding="myPortField">
            <constraints>
              <grid row="0" column="1" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <columns value="5"/>
            </properties>
          </component>
        </children>
      </grid>
      <component id="aad8d" class="javax.swing.JButton" binding="myDebuggerSettings">
        <constraints>
          <grid row="1" column="1" row-span="2" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
        </constraints>
        <properties>
          <text resource-bundle="messages/JavaDebuggerBundle" key="button.debugger.settings"/>
        </properties>
      </component>
      <grid id="b10c7" binding="myTransportPanel" layout-manager="GridLayoutManager" row-count="1" column-count="4" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
        <margin top="0" left="0" bottom="0" right="0"/>
        <constraints>
          <grid row="0" column="0" row-span="1" col-span="2" vsize-policy="3" hsize-policy="3" anchor="0" fill="3" indent="0" use-parent-layout="false"/>
        </constraints>
        <properties/>
        <border type="none"/>
        <children>
          <component id="63d09" class="javax.swing.JLabel">
            <constraints>
              <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="0" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.generic.debugger.parameters.patcher.configurable.transport"/>
            </properties>
          </component>
          <component id="f3bb4" class="javax.swing.JRadioButton" binding="mySocketTransport">
            <constraints>
              <grid row="0" column="1" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <selected value="true"/>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.generic.debugger.parameters.patcher.configurable.socket"/>
            </properties>
          </component>
          <component id="3bb61" class="javax.swing.JRadioButton" binding="myShmemTransport">
            <constraints>
              <grid row="0" column="2" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties>
              <text resource-bundle="messages/JavaDebuggerBundle" key="label.generic.debugger.parameters.patcher.configurable.shmem"/>
            </properties>
          </component>
          <hspacer id="b3e0f">
            <constraints>
              <grid row="0" column="3" row-span="1" col-span="1" vsize-policy="1" hsize-policy="6" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
            </constraints>
          </hspacer>
        </children>
      </grid>
    </children>
  </grid>
</form>
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui;

import com.intellij.debugger.DebuggerInvocationUtil;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.impl.DebuggerSession;
import com.intellij.debugger.impl.HotSwapProgress;
import com.intellij.execution.runners.ExecutionEnvironment;
import com.intellij.execution.runners.ExecutionUtil;
import com.intellij.notification.Notification;
import com.intellij.notification.NotificationAction;
import com.intellij.notification.NotificationGroup;
import com.intellij.notification.NotificationType;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.progress.ProgressIndicator;
import com.intellij.openapi.progress.impl.BackgroundableProcessIndicator;
import com.intellij.openapi.progress.util.AbstractProgressIndicatorExBase;
import com.intellij.openapi.progress.util.ProgressWindow;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.NlsContexts;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.wm.ToolWindowId;
import com.intellij.reference.SoftReference;
import com.intellij.util.SmartList;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.ui.MessageCategory;
import com.intellij.util.ui.update.MergingUpdateQueue;
import com.intellij.util.ui.update.Update;
import com.intellij.xdebugger.XDebugSession;
import com.intellij.xdebugger.impl.XDebugSessionImpl;
import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.ints.IntIterator;
import one.util.streamex.StreamEx;
import org.jetbrains.annotations.NotNull;

import java.awt.*;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

public final class HotSwapProgressImpl extends HotSwapProgress {
  static final NotificationGroup NOTIFICATION_GROUP = NotificationGroup.toolWindowGroup("HotSwap", ToolWindowId.DEBUG);

  private final Int2ObjectMap<List<String>> myMessages = new Int2ObjectOpenHashMap<>();
  private final ProgressWindow myProgressWindow;
  private @NlsContexts.ProgressTitle String myTitle = JavaDebuggerBundle.message("progress.hot.swap.title");
  private final MergingUpdateQueue myUpdateQueue;
  private WeakReference<XDebugSession> mySessionRef = null;
  private final List<HotSwapProgressListener> myListeners = ContainerUtil.createLockFreeCopyOnWriteList();

  public HotSwapProgressImpl(Project project) {
    super(project);
    assert EventQueue.isDispatchThread();
    myProgressWindow = new BackgroundableProcessIndicator(getProject(), myTitle, null, null, true);
    myProgressWindow.setIndeterminate(false);
    myProgressWindow.addStateDelegate(new AbstractProgressIndicatorExBase() {
      @Override
      public void cancel() {
        super.cancel();
        HotSwapProgressImpl.this.cancel();
      }
    });
    myUpdateQueue = new MergingUpdateQueue("HotSwapProgress update queue", 100, true, null, myProgressWindow);
  }

  @Override
  public void cancel() {
    super.cancel();
    for (HotSwapProgressListener listener : myListeners) {
      listener.onCancel();
    }
  }

  @Override
  public void finished() {
    super.finished();

    for (HotSwapProgressListener listener : myListeners) {
      listener.onFinish();
    }

    List<String> errors = getMessages(MessageCategory.ERROR);
    List<String> warnings = getMessages(MessageCategory.WARNING);

    if (!errors.isEmpty()) {
      notifyUser(JavaDebuggerBundle.message("status.hot.swap.completed.with.errors"), buildMessage(errors), true, NotificationType.ERROR);
    }
    else if (!warnings.isEmpty()) {
      notifyUser(JavaDebuggerBundle.message("status.hot.swap.completed.with.warnings"), buildMessage(warnings), true,
                 NotificationType.WARNING);
    }
    else if (!myMessages.isEmpty()) {
      List<String> messages = new ArrayList<>();
      for (IntIterator iterator = myMessages.keySet().iterator(); iterator.hasNext(); ) {
        messages.addAll(getMessages(iterator.nextInt()));
      }
      notifyUser("", buildMessage(messages), false, NotificationType.INFORMATION);
    }
  }

  private void notifyUser(@NlsContexts.NotificationTitle String title,
                          @NlsContexts.NotificationContent String message,
                          boolean withRestart,
                          NotificationType type) {
    Notification notification = NOTIFICATION_GROUP.createNotification(title, message, type);
    if (SoftReference.dereference(mySessionRef) != null) {
      notification.addAction(new StopHotSwapNotificationAction(mySessionRef));
      if (withRestart) {
        notification.addAction(new RestartHotSwapNotificationAction(mySessionRef));
      }
    }
    notification.setImportant(false).notify(getProject());
  }

  public void setSessionForActions(@NotNull DebuggerSession session) {
    mySessionRef = new WeakReference<>(session.getXDebugSession());
  }

  List<String> getMessages(int category) {
    return ContainerUtil.notNullize(myMessages.get(category));
  }

  private static @NlsSafe String buildMessage(List<String> messages) {
    return StreamEx.of(messages).map(m -> StringUtil.trimEnd(m, ';')).joining("\n");
  }

  @Override
  public void addMessage(DebuggerSession session, final int type, final String text) {
    List<String> messages = myMessages.get(type);
    if (messages == null) {
      messages = new SmartList<>();
      myMessages.put(type, messages);
    }
    messages.add(session.getSessionName() + ": " + text + ";");
  }

  @Override
  public void setText(final @NlsContexts.ProgressText String text) {
    myUpdateQueue.queue(new Update("Text") {
      @Override
      public void run() {
        DebuggerInvocationUtil.invokeLater(getProject(), () -> {
          if (!myProgressWindow.isCanceled() && myProgressWindow.isRunning()) {
            myProgressWindow.setText(text);
          }
        }, myProgressWindow.getModalityState());
      }
    });
  }

  @Override
  public void setTitle(final @NlsContexts.ProgressTitle @NotNull String text) {
    DebuggerInvocationUtil.invokeLater(getProject(), () -> {
      if (!myProgressWindow.isCanceled() && myProgressWindow.isRunning()) {
        myProgressWindow.setTitle(text);
      }
    }, myProgressWindow.getModalityState());
  }

  @Override
  public void setFraction(final double v) {
    DebuggerInvocationUtil.invokeLater(getProject(), () -> {
      if (!myProgressWindow.isCanceled() && myProgressWindow.isRunning()) {
        myProgressWindow.setFraction(v);
      }
    }, myProgressWindow.getModalityState());
  }

  @Override
  public boolean isCancelled() {
    return myProgressWindow.isCanceled();
  }

  public ProgressIndicator getProgressIndicator() {
    return myProgressWindow;
  }

  @Override
  public void setDebuggerSession(DebuggerSession session) {
    myTitle = JavaDebuggerBundle.message("progress.hot.swap.title") + " : " + session.getSessionName();
    myProgressWindow.setTitle(myTitle);
  }

  void addProgressListener(@NotNull HotSwapProgressListener listener) {
    myListeners.add(listener);
  }

  interface HotSwapProgressListener {
    default void onCancel() {
    }

    default void onFinish() {
    }
  }

  /**
   * Please do not inline, WeakReference is here for a reason.
   */
  private static class StopHotSwapNotificationAction extends NotificationAction {
    private final WeakReference<XDebugSession> mySessionRef;

    private StopHotSwapNotificationAction(@NotNull WeakReference<XDebugSession> session) {
      super(JavaDebuggerBundle.message("status.hot.swap.completed.stop"));
      mySessionRef = session;
    }

    @Override
    public void actionPerformed(@NotNull AnActionEvent e, @NotNull Notification notification) {
      XDebugSession session = SoftReference.dereference(mySessionRef);
      if (session != null) {
        notification.expire();
        session.stop();
      }
    }
  }

  /**
   * Please do not inline, WeakReference is here for a reason.
   */
  private static class RestartHotSwapNotificationAction extends NotificationAction {
    private final WeakReference<XDebugSession> mySessionRef;

    private RestartHotSwapNotificationAction(@NotNull WeakReference<XDebugSession> session) {
      super(JavaDebuggerBundle.message("status.hot.swap.completed.restart"));
      mySessionRef = session;
    }

    @Override
    public void actionPerformed(@NotNull AnActionEvent e, @NotNull Notification notification) {
      XDebugSession session = SoftReference.dereference(mySessionRef);
      if (session != null) {
        notification.expire();
        ExecutionEnvironment environment = ((XDebugSessionImpl)session).getExecutionEnvironment();
        if (environment != null) {
          ExecutionUtil.restart(environment);
        }
      }
    }
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui;

import com.intellij.debugger.impl.DebuggerSession;

import java.util.List;

/**
 * Each attempt at hotswapping some classes is either canceled, or it succeeds, or it fails.
 */
public interface HotSwapStatusListener {
  default void onCancel(List<DebuggerSession> sessions) {
  }

  default void onSuccess(List<DebuggerSession> sessions) {
  }

  default void onFailure(List<DebuggerSession> sessions) {
  }
}
// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

package com.intellij.debugger.ui;

import com.intellij.debugger.impl.DebuggerSession;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VirtualFile;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public abstract class HotSwapUI {
  public static HotSwapUI getInstance(Project project) {
    return project.getService(HotSwapUI.class);
  }

  public abstract void reloadChangedClasses(@NotNull DebuggerSession session, boolean compileBeforeHotswap);

  public abstract void reloadChangedClasses(@NotNull DebuggerSession session, boolean compileBeforeHotswap,
                                            @Nullable HotSwapStatusListener callback);

  public abstract void compileAndReload(@NotNull DebuggerSession session, VirtualFile @NotNull ... files);

  public abstract void addListener(HotSwapVetoableListener listener);

  public abstract void removeListener(HotSwapVetoableListener listener);
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui;

import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.impl.DebuggerManagerListener;
import com.intellij.debugger.impl.DebuggerSession;
import com.intellij.debugger.impl.HotSwapFile;
import com.intellij.debugger.impl.HotSwapManager;
import com.intellij.debugger.settings.DebuggerSettings;
import com.intellij.notification.NotificationType;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.compiler.CompilerPaths;
import com.intellij.openapi.module.ModuleManager;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.util.Disposer;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.KeyWithDefaultValue;
import com.intellij.openapi.util.NotNullLazyValue;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.task.*;
import com.intellij.task.impl.ProjectTaskManagerImpl;
import com.intellij.ui.UIBundle;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.containers.FileCollectionFactory;
import com.intellij.util.messages.MessageBusConnection;
import com.intellij.util.ui.MessageCategory;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.jps.util.JpsPathUtil;

import java.io.File;
import java.util.*;
import java.util.stream.Collectors;

public final class HotSwapUIImpl extends HotSwapUI {
  /**
   * There are cases when hotswapping the changed classes is not needed.
   * For example, for a Tomcat application 'redeploy',
   * all classes are replaced anyway using a fresh class loader,
   * so there's no need to try reloading classes,
   * as that could only cause hotswap failure UX issues.
   * <p>
   * The flag can be used to skip hotswap after the {@link ProjectTaskManager} run session finished.
   * To apply the flag, add it to the {@link ProjectTaskContext} user data.
   *
   * @see ProjectTaskContext#withUserData(Key, Object)
   */
  public static final Key<Boolean> SKIP_HOT_SWAP_KEY = KeyWithDefaultValue.create("skip_hotswap_after_this_compilation", false);
  private static final Key<HotSwapStatusListener> HOT_SWAP_CALLBACK_KEY = Key.create("hot_swap_callback");

  private final List<HotSwapVetoableListener> myListeners = ContainerUtil.createLockFreeCopyOnWriteList();
  private boolean myAskBeforeHotswap = true;
  private final Project myProject;

  public HotSwapUIImpl(@NotNull Project project) {
    myProject = project;
  }

  @Override
  public void addListener(HotSwapVetoableListener listener) {
    myListeners.add(listener);
  }

  @Override
  public void removeListener(HotSwapVetoableListener listener) {
    myListeners.remove(listener);
  }

  private static boolean shouldDisplayHangWarning(DebuggerSettings settings, List<DebuggerSession> sessions) {
    if (!settings.HOTSWAP_HANG_WARNING_ENABLED) {
      return false;
    }
    // todo: return false if yourkit agent is inactive
    return ContainerUtil.exists(sessions, DebuggerSession::isPaused);
  }

  /**
   * After a compilation has finished successfully,
   * decide which sessions and classes participate in the hotswap and reload them.
   *
   * @param generatedPaths the relative paths of the {@code .class} files that were compiled, grouped by their content root
   */
  private void hotSwapSessions(@NotNull List<DebuggerSession> sessions,
                               @Nullable Map<String, Collection<String>> generatedPaths,
                               @Nullable NotNullLazyValue<List<String>> outputPaths,
                               @Nullable HotSwapStatusListener callback) {
    boolean shouldAskBeforeHotswap = myAskBeforeHotswap;
    myAskBeforeHotswap = true;

    DebuggerSettings settings = DebuggerSettings.getInstance();
    String runHotswap = settings.RUN_HOTSWAP_AFTER_COMPILE;
    boolean shouldDisplayHangWarning = shouldDisplayHangWarning(settings, sessions);

    HotSwapStatusListener statusListener = makeNullSafe(callback);

    if (shouldAskBeforeHotswap && DebuggerSettings.RUN_HOTSWAP_NEVER.equals(runHotswap)) {
      statusListener.onCancel(sessions);
      return;
    }

    List<DebuggerSession> toScan = new ArrayList<>(sessions); // by default scan all sessions
    List<DebuggerSession> toUseGenerated = new ArrayList<>();

    if (generatedPaths != null) {
      toScan.clear();
      for (DebuggerSession session : sessions) {
        if (session.isModifiedClassesScanRequired()) {
          toScan.add(session);
        }
        else {
          toUseGenerated.add(session);
        }
        session.setModifiedClassesScanRequired(false);
      }
    }

    HotSwapProgressImpl findClassesProgress = !toScan.isEmpty() ? createHotSwapProgress(statusListener, sessions) : null;
    HotSwapProgressImpl outputPathsProgress =
      !toUseGenerated.isEmpty() && outputPaths != null ? createHotSwapProgress(statusListener, sessions) : null;

    ApplicationManager.getApplication().executeOnPooledThread(() -> {
      Map<DebuggerSession, Map<String, HotSwapFile>> modifiedClasses = new HashMap<>();
      if (!toUseGenerated.isEmpty()) {
        modifiedClasses.putAll(HotSwapManager.findModifiedClasses(toUseGenerated, generatedPaths));
        if (outputPathsProgress != null) {
          scanForModifiedClassesWithProgress(toUseGenerated, outputPaths, outputPathsProgress)
            .forEach(
              (session, map) -> modifiedClasses.merge(session, map, (map1, map2) -> {
                map1.putAll(map2);
                return map1;
              })
            );
        }
      }
      if (findClassesProgress != null) {
        modifiedClasses.putAll(scanForModifiedClassesWithProgress(toScan, null, findClassesProgress));
      }

      if (modifiedClasses.isEmpty()) {
        String message = JavaDebuggerBundle.message("status.hotswap.uptodate");
        HotSwapProgressImpl.NOTIFICATION_GROUP.createNotification(message, NotificationType.INFORMATION).notify(myProject);
        statusListener.onSuccess(sessions);
        return;
      }

      ApplicationManager.getApplication().invokeLater(() -> {
        if (shouldAskBeforeHotswap && !DebuggerSettings.RUN_HOTSWAP_ALWAYS.equals(runHotswap)) {
          RunHotswapDialog dialog = new RunHotswapDialog(myProject, sessions, shouldDisplayHangWarning);
          if (!dialog.showAndGet()) {
            for (DebuggerSession session : modifiedClasses.keySet()) {
              session.setModifiedClassesScanRequired(true);
            }
            statusListener.onCancel(sessions);
            return;
          }
          Set<DebuggerSession> toReload = new HashSet<>(dialog.getSessionsToReload());
          for (DebuggerSession session : modifiedClasses.keySet()) {
            if (!toReload.contains(session)) {
              session.setModifiedClassesScanRequired(true);
            }
          }
          modifiedClasses.keySet().retainAll(toReload);
        }
        else if (shouldDisplayHangWarning && !confirmPossibleHang(settings)) {
          for (DebuggerSession session : modifiedClasses.keySet()) {
            session.setModifiedClassesScanRequired(true);
          }
          statusListener.onCancel(sessions);
          return;
        }

        if (modifiedClasses.isEmpty()) {
          return; // Without calling onCancel.
        }

        HotSwapProgressImpl progress = new HotSwapProgressImpl(myProject);
        if (modifiedClasses.keySet().size() == 1) {
          progress.setSessionForActions(ContainerUtil.getFirstItem(modifiedClasses.keySet()));
        }
        progress.addProgressListener(delegatingTo(statusListener, sessions, progress));

        ApplicationManager.getApplication().executeOnPooledThread(
          () -> reloadModifiedClasses(modifiedClasses, progress)
        );
      }, ModalityState.nonModal());
    });
  }

  private static HotSwapProgressImpl.HotSwapProgressListener delegatingTo(
    HotSwapStatusListener statusListener, @NotNull List<DebuggerSession> sessions, HotSwapProgressImpl progress
  ) {
    return new HotSwapProgressImpl.HotSwapProgressListener() {
      @Override
      public void onCancel() {
        statusListener.onCancel(sessions);
      }

      @Override
      public void onFinish() {
        if (progress.getMessages(MessageCategory.ERROR).isEmpty()) {
          statusListener.onSuccess(sessions);
        }
        else {
          statusListener.onFailure(sessions);
        }
      }
    };
  }

  private static boolean confirmPossibleHang(@NotNull DebuggerSettings settings) {
    int answer = Messages.showCheckboxMessageDialog(
      JavaDebuggerBundle.message("hotswap.dialog.hang.warning"),
      JavaDebuggerBundle.message("hotswap.dialog.title"),
      new String[]{
        JavaDebuggerBundle.message("button.perform.reload.classes"),
        JavaDebuggerBundle.message("button.skip.reload.classes"),
      },
      UIBundle.message("dialog.options.do.not.show"),
      false, 1, 1, Messages.getWarningIcon(),
      (exitCode, cb) -> {
        settings.HOTSWAP_HANG_WARNING_ENABLED = !cb.isSelected();
        return exitCode == DialogWrapper.OK_EXIT_CODE ? exitCode : DialogWrapper.CANCEL_EXIT_CODE;
      }
    );
    return answer != DialogWrapper.CANCEL_EXIT_CODE;
  }

  @NotNull
  private HotSwapProgressImpl createHotSwapProgress(@NotNull HotSwapStatusListener statusListener,
                                                    @NotNull List<DebuggerSession> sessions) {
    HotSwapProgressImpl progress = new HotSwapProgressImpl(myProject);
    progress.addProgressListener(new HotSwapProgressImpl.HotSwapProgressListener() {
      @Override
      public void onCancel() {
        statusListener.onCancel(sessions);
      }
    });
    return progress;
  }

  @NotNull
  private static Map<DebuggerSession, Map<String, HotSwapFile>> scanForModifiedClassesWithProgress(@NotNull List<DebuggerSession> sessions,
                                                                                                   @Nullable NotNullLazyValue<List<String>> outputPaths,
                                                                                                   @NotNull HotSwapProgressImpl progress) {
    return ProgressManager.getInstance().runProcess(() -> {
      try {
        return HotSwapManager.scanForModifiedClasses(sessions, outputPaths, progress);
      }
      finally {
        progress.finished();
      }
    }, progress.getProgressIndicator());
  }

  private static void reloadModifiedClasses(Map<DebuggerSession, Map<String, HotSwapFile>> modifiedClasses,
                                            HotSwapProgressImpl progress) {
    ProgressManager.getInstance().runProcess(() -> {
      HotSwapManager.reloadModifiedClasses(modifiedClasses, progress);
      progress.finished();
    }, progress.getProgressIndicator());
  }

  @Override
  public void reloadChangedClasses(@NotNull DebuggerSession session, boolean compileBeforeHotswap) {
    reloadChangedClasses(session, compileBeforeHotswap, null);
  }

  @Override
  public void reloadChangedClasses(@NotNull DebuggerSession session,
                                   boolean compileBeforeHotswap,
                                   @Nullable HotSwapStatusListener callback) {
    dontAskHotswapAfterThisCompilation();
    if (compileBeforeHotswap) {
      Project project = session.getProject();
      ProjectTaskManagerImpl.putBuildOriginator(project, this.getClass());
      ProjectTaskManager projectTaskManager = ProjectTaskManager.getInstance(project);
      if (callback == null) {
        projectTaskManager.buildAllModules();
      }
      else {
        ProjectTask buildProjectTask = projectTaskManager.createAllModulesBuildTask(true, project);
        ProjectTaskContext context = new ProjectTaskContext(callback).withUserData(HOT_SWAP_CALLBACK_KEY, callback);
        projectTaskManager.run(context, buildProjectTask);
      }
    }
    else {
      if (session.isAttached()) {
        hotSwapSessions(Collections.singletonList(session), null, null, callback);
      }
      else if (callback != null) {
        callback.onFailure(List.of(session));
      }
    }
  }

  @Override
  public void compileAndReload(@NotNull DebuggerSession session, VirtualFile @NotNull ... files) {
    dontAskHotswapAfterThisCompilation();
    Project project = session.getProject();
    ProjectTaskManagerImpl.putBuildOriginator(project, this.getClass());
    ProjectTaskManager.getInstance(project).compile(files);
    // The control flow continues at MyCompilationStatusListener.finished.
  }

  public void dontAskHotswapAfterThisCompilation() {
    myAskBeforeHotswap = false;
  }

  private static final class MyCompilationStatusListener implements ProjectTaskListener {
    private final Set<File> myOutputRoots;
    private final Project myProject;

    private MyCompilationStatusListener(Project project) {
      myProject = project;
      myOutputRoots = FileCollectionFactory.createCanonicalFileSet();
      for (String path : CompilerPaths.getOutputPaths(ModuleManager.getInstance(myProject).getModules())) {
        myOutputRoots.add(new File(path));
      }
    }

    @Override
    public void started(@NotNull ProjectTaskContext context) {
      context.enableCollectionOfGeneratedFiles();
    }

    @Override
    public void finished(@NotNull ProjectTaskManager.Result result) {
      if (myProject.isDisposed()) return;
      if (!hasCompilationResults(result)) return;

      ProjectTaskContext context = result.getContext();
      if (result.hasErrors() || result.isAborted()) return;
      if (SKIP_HOT_SWAP_KEY.getRequired(context)) return;

      HotSwapUIImpl instance = (HotSwapUIImpl)getInstance(myProject);
      for (HotSwapVetoableListener listener : instance.myListeners) {
        if (!listener.shouldHotSwap(context)) return;
      }

      List<DebuggerSession> sessions = getHotSwappableDebugSessions(myProject);
      if (sessions.isEmpty()) return;

      Map<String, Collection<String>> generatedPaths = collectGeneratedPaths(context);
      HotSwapStatusListener callback = context.getUserData(HOT_SWAP_CALLBACK_KEY);
      NotNullLazyValue<List<String>> outputRoots = context.getDirtyOutputPaths()
        .map(stream -> NotNullLazyValue.createValue(() -> stream.collect(Collectors.toList())))
        .orElse(null);
      instance.hotSwapSessions(sessions, generatedPaths, outputRoots, callback);
    }

    @NotNull
    private Map<String, Collection<String>> collectGeneratedPaths(ProjectTaskContext context) {
      Collection<String> generatedFilesRoots = context.getGeneratedFilesRoots();
      if (generatedFilesRoots.isEmpty()) return Collections.emptyMap();

      Map<String, Collection<String>> generatedPaths = new HashMap<>();
      for (String outputRoot : generatedFilesRoots) {
        // collect only classes under IDE output roots
        if (!JpsPathUtil.isUnder(myOutputRoots, new File(outputRoot))) continue;
        Collection<String> relativePaths = ContainerUtil.filter(
          context.getGeneratedFilesRelativePaths(outputRoot),
          relativePath -> StringUtil.endsWith(relativePath, ".class")
        );
        if (!relativePaths.isEmpty()) {
          generatedPaths.put(outputRoot, relativePaths);
        }
      }
      return generatedPaths;
    }

    private static boolean hasCompilationResults(@NotNull ProjectTaskManager.Result result) {
      return result.anyTaskMatches(
        (task, state) -> task instanceof ModuleBuildTask && !state.isFailed() && !state.isSkipped()
      );
    }
  }

  public static boolean canHotSwap(@NotNull DebuggerSession debuggerSession) {
    return debuggerSession.isAttached() && debuggerSession.getProcess().canRedefineClasses();
  }

  @NotNull
  private static List<DebuggerSession> getHotSwappableDebugSessions(Project project) {
    return ContainerUtil.filter(DebuggerManagerEx.getInstanceEx(project).getSessions(), HotSwapUIImpl::canHotSwap);
  }

  private static HotSwapStatusListener makeNullSafe(HotSwapStatusListener listener) {
    return new HotSwapStatusListener() {
      @Override
      public void onCancel(List<DebuggerSession> sessions) {
        if (listener != null) listener.onCancel(sessions);
      }

      @Override
      public void onSuccess(List<DebuggerSession> sessions) {
        if (listener != null) listener.onSuccess(sessions);
      }

      @Override
      public void onFailure(List<DebuggerSession> sessions) {
        if (listener != null) listener.onFailure(sessions);
      }
    };
  }

  public static class HotSwapDebuggerManagerListener implements DebuggerManagerListener {
    private @NotNull final Project myProject;
    private MessageBusConnection myConn;

    public HotSwapDebuggerManagerListener(@NotNull Project project) {
      myProject = project;
      myConn = null;
    }

    @Override
    public void sessionAttached(DebuggerSession session) {
      if (myConn == null) {
        myConn = myProject.getMessageBus().connect();
        myConn.subscribe(ProjectTaskListener.TOPIC, new MyCompilationStatusListener(myProject));
      }
    }

    @Override
    public void sessionDetached(DebuggerSession session) {
      if (!getHotSwappableDebugSessions(myProject).isEmpty()) return;

      MessageBusConnection conn = myConn;
      if (conn != null) {
        Disposer.dispose(conn);
        myConn = null;
      }
    }
  }
}
// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

package com.intellij.debugger.ui;

import com.intellij.task.ProjectTaskContext;
import org.jetbrains.annotations.NotNull;

/**
 * Allows plugins to cancel hotswap after a particular compilation session.
 *
 * @see HotSwapUI#addListener(HotSwapVetoableListener)
 */
public interface HotSwapVetoableListener {
  /**
   * Returns {@code false} if Hot Swap shouldn't be invoked after the given compilation session.
   */
  boolean shouldHotSwap(@NotNull ProjectTaskContext context);
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

/*
 * @author Eugene Zhuravlev
 */
package com.intellij.debugger.ui.impl;

import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.DebuggerSession;
import com.intellij.debugger.impl.DebuggerStateManager;
import com.intellij.debugger.ui.impl.watch.DebuggerTree;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.actionSystem.ActionPopupMenu;
import com.intellij.openapi.actionSystem.DataKey;
import com.intellij.openapi.actionSystem.DataProvider;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Disposer;
import com.intellij.openapi.wm.IdeFocusManager;
import com.intellij.openapi.wm.ex.IdeFocusTraversalPolicy;
import com.intellij.ui.PopupHandler;
import com.intellij.util.SingleAlarm;
import com.intellij.xdebugger.impl.actions.XDebuggerActions;
import com.intellij.xdebugger.impl.ui.DebuggerUIUtil;
import com.sun.jdi.VMDisconnectedException;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.awt.*;

public abstract class DebuggerTreePanel extends UpdatableDebuggerView implements DataProvider, Disposable {
  public static final DataKey<DebuggerTreePanel> DATA_KEY = DataKey.create("DebuggerPanel");

  private final SingleAlarm myRebuildAlarm = new SingleAlarm(() -> {
    try {
      final DebuggerContextImpl context = getContext();
      if (context.getDebuggerSession() != null) {
        getTree().rebuild(context);
      }
    }
    catch (VMDisconnectedException ignored) {
    }
  }, 100);

  protected DebuggerTree myTree;

  public DebuggerTreePanel(Project project, DebuggerStateManager stateManager) {
    super(project, stateManager);
    myTree = createTreeView();

    final PopupHandler popupHandler = new PopupHandler() {
      @Override
      public void invokePopup(Component comp, int x, int y) {
        ActionPopupMenu popupMenu = createPopupMenu();
        if (popupMenu != null) {
          popupMenu.getComponent().show(comp, x, y);
        }
      }
    };
    myTree.addMouseListener(popupHandler);

    setFocusTraversalPolicy(new IdeFocusTraversalPolicy() {
      @Nullable
      @Override
      protected Project getProject() {
        return project;
      }

      @Override
      public Component getDefaultComponent(Container focusCycleRoot) {
        return myTree;
      }
    });

    registerDisposable(new Disposable() {
      @Override
      public void dispose() {
        myTree.removeMouseListener(popupHandler);
      }
    });

    DebuggerUIUtil.registerActionOnComponent(XDebuggerActions.MARK_OBJECT, myTree, this);
  }

  protected abstract DebuggerTree createTreeView();

  @Override
  protected void changeEvent(DebuggerContextImpl newContext, DebuggerSession.Event event) {
    super.changeEvent(newContext, event);
    if (event == DebuggerSession.Event.DISPOSE) {
      getTree().getNodeFactory().dispose();
    }
  }

  @Override
  protected void rebuild(DebuggerSession.Event event) {
    myRebuildAlarm.cancelAndRequest();
  }

  @Override
  public void dispose() {
    Disposer.dispose(myRebuildAlarm);
    try {
      super.dispose();
    }
    finally {
      final DebuggerTree tree = myTree;
      if (tree != null) {
        Disposer.dispose(tree);
      }
      // prevent mem leak from inside Swing
      myTree = null;
    }
  }


  protected abstract ActionPopupMenu createPopupMenu();

  public final DebuggerTree getTree() {
    return myTree;
  }

  public void clear() {
    myTree.removeAllChildren();
  }

  @Override
  public Object getData(@NotNull String dataId) {
    if (DATA_KEY.is(dataId)) {
      return this;
    }
    return null;
  }

  @Override
  public void requestFocus() {
    IdeFocusManager.getGlobalInstance().doWhenFocusSettlesDown(() -> IdeFocusManager.getGlobalInstance().requestFocus(getTree(), true));
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.impl;

import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.ui.impl.watch.*;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.render.EnumerationChildrenRenderer;
import com.intellij.icons.AllIcons;
import com.intellij.ide.highlighter.JavaHighlightingColors;
import com.intellij.openapi.editor.colors.EditorColorsScheme;
import com.intellij.openapi.editor.markup.TextAttributes;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.ui.*;
import com.intellij.util.PlatformIcons;
import com.intellij.xdebugger.XDebugSession;
import com.intellij.xdebugger.XDebuggerManager;
import com.intellij.xdebugger.impl.XDebugSessionImpl;
import com.intellij.xdebugger.impl.ui.DebuggerUIUtil;
import com.intellij.xdebugger.impl.ui.XDebugSessionTab;
import com.intellij.xdebugger.impl.ui.XDebuggerUIConstants;
import com.sun.jdi.ObjectReference;
import com.sun.jdi.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.awt.*;

public final class DebuggerTreeRenderer extends ColoredTreeCellRenderer {

  private static final SimpleTextAttributes DEFAULT_ATTRIBUTES =
    new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, null);
  private static final SimpleTextAttributes SPECIAL_NODE_ATTRIBUTES =
    new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, new JBColor(Color.lightGray, Gray._130));
  private static final SimpleTextAttributes OBJECT_ID_HIGHLIGHT_ATTRIBUTES =
    new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, new JBColor(Color.lightGray, Gray._130));

  @Override
  public void customizeCellRenderer(@NotNull JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
    final DebuggerTreeNodeImpl node = (DebuggerTreeNodeImpl)value;

    if (node != null) {
      final SimpleColoredText text = node.getText();
      if (text != null) {
        text.appendToComponent(this);
      }
      setIcon(node.getIcon());
    }
  }

  @Nullable
  public static Icon getDescriptorIcon(NodeDescriptor descriptor) {
    if (descriptor instanceof ThreadGroupDescriptorImpl threadGroupDescriptor) {
      return threadGroupDescriptor.isCurrent() ? AllIcons.Debugger.ThreadGroupCurrent : AllIcons.Debugger.ThreadGroup;
    }
    if (descriptor instanceof ThreadDescriptorImpl threadDescriptor) {
      return threadDescriptor.getIcon();
    }
    if (descriptor instanceof StackFrameDescriptorImpl stackDescriptor) {
      return stackDescriptor.getIcon();
    }
    if (descriptor instanceof ValueDescriptorImpl valueDescriptor) {
      return getValueIcon(valueDescriptor, null);
    }
    if (descriptor instanceof MessageDescriptor messageDescriptor) {
      return switch (messageDescriptor.getKind()) {
        case MessageDescriptor.ERROR -> XDebuggerUIConstants.ERROR_MESSAGE_ICON;
        case MessageDescriptor.INFORMATION -> XDebuggerUIConstants.INFORMATION_MESSAGE_ICON;
        default -> null;
      };
    }
    if (descriptor instanceof StaticDescriptorImpl) {
      return AllIcons.Nodes.Static;
    }

    return null;
  }

  public static Icon getValueIcon(ValueDescriptorImpl valueDescriptor, @Nullable ValueDescriptorImpl parentDescriptor) {
    Icon nodeIcon;
    if (valueDescriptor instanceof FieldDescriptorImpl fieldDescriptor) {
      nodeIcon = IconManager.getInstance().getPlatformIcon(com.intellij.ui.PlatformIcons.Field);
      if (parentDescriptor != null) {
        Value value = valueDescriptor.getValue();
        if (value instanceof ObjectReference && value.equals(parentDescriptor.getValue())) {
          nodeIcon = AllIcons.Debugger.Selfreference;
        }
      }
      if (fieldDescriptor.getField().isFinal()) {
        nodeIcon = new LayeredIcon(nodeIcon, IconManager.getInstance().getPlatformIcon(com.intellij.ui.PlatformIcons.FinalMark));
      }
      if (fieldDescriptor.isStatic()) {
        nodeIcon = new LayeredIcon(nodeIcon, IconManager.getInstance().getPlatformIcon(com.intellij.ui.PlatformIcons.StaticMark));
      }
    }
    else if (valueDescriptor instanceof ThrownExceptionValueDescriptorImpl) {
      nodeIcon = AllIcons.Nodes.ExceptionClass;
    }
    else if (valueDescriptor instanceof MethodReturnValueDescriptorImpl) {
      nodeIcon = AllIcons.Debugger.WatchLastReturnValue;
    }
    else if (isParameter(valueDescriptor)) {
      nodeIcon = IconManager.getInstance().getPlatformIcon(com.intellij.ui.PlatformIcons.Parameter);
    }
    else if (valueDescriptor.isEnumConstant()) {
      nodeIcon = PlatformIcons.ENUM_ICON;
    }
    else if (valueDescriptor.isArray()) {
      nodeIcon = AllIcons.Debugger.Db_array;
    }
    else if (valueDescriptor.isPrimitive()) {
      nodeIcon = AllIcons.Debugger.Db_primitive;
    }
    else if (valueDescriptor instanceof WatchItemDescriptor) {
      nodeIcon = AllIcons.Debugger.Db_watch;
    }
    else {
      nodeIcon = AllIcons.Debugger.Value;
    }

    if (valueDescriptor instanceof UserExpressionDescriptorImpl) {
      EnumerationChildrenRenderer enumerationChildrenRenderer =
        EnumerationChildrenRenderer.getCurrent(((UserExpressionDescriptorImpl)valueDescriptor).getParentDescriptor());
      if (enumerationChildrenRenderer != null && enumerationChildrenRenderer.isAppendDefaultChildren()) {
        nodeIcon = AllIcons.Debugger.Db_watch;
      }
    }

    // if watches in variables enabled, always use watch icon
    if (valueDescriptor instanceof WatchItemDescriptor && nodeIcon != AllIcons.Debugger.Db_watch) {
      XDebugSession session = XDebuggerManager.getInstance(valueDescriptor.getProject()).getCurrentSession();
      if (session != null) {
        XDebugSessionTab tab = ((XDebugSessionImpl)session).getSessionTab();
        if (tab != null && tab.isWatchesInVariables()) {
          nodeIcon = AllIcons.Debugger.Db_watch;
        }
      }
    }

    final Icon valueIcon = valueDescriptor.getValueIcon();
    if (valueIcon != null) {
      nodeIcon = IconManager.getInstance().createRowIcon(nodeIcon, valueIcon);
    }
    return nodeIcon;
  }

  private static boolean isParameter(ValueDescriptorImpl valueDescriptor) {
    if (valueDescriptor instanceof LocalVariableDescriptorImpl) {
      return ((LocalVariableDescriptorImpl)valueDescriptor).isParameter();
    }
    else if (valueDescriptor instanceof ArgumentValueDescriptorImpl) {
      return ((ArgumentValueDescriptorImpl)valueDescriptor).isParameter();
    }
    return false;
  }

  public static SimpleColoredText getDescriptorText(DebuggerContextImpl debuggerContext,
                                                    NodeDescriptorImpl descriptor,
                                                    EditorColorsScheme colorsScheme,
                                                    boolean multiline) {
    return getDescriptorText(descriptor, colorsScheme, multiline, true);
  }

  public static SimpleColoredText getDescriptorText(final DebuggerContextImpl debuggerContext, NodeDescriptorImpl descriptor, boolean multiline) {
    return getDescriptorText(descriptor, DebuggerUIUtil.getColorScheme(null), multiline, true);
  }

  public static SimpleColoredText getDescriptorTitle(final DebuggerContextImpl debuggerContext, NodeDescriptorImpl descriptor) {
    return getDescriptorText(descriptor, DebuggerUIUtil.getColorScheme(null), false, false);
  }

  private static SimpleColoredText getDescriptorText(NodeDescriptorImpl descriptor,
                                                     EditorColorsScheme colorScheme,
                                                     boolean multiline,
                                                     boolean appendValue) {
    SimpleColoredText descriptorText = new SimpleColoredText();

    String text;
    String nodeName;

    if (descriptor == null) {
      text = "";
      nodeName = null;
    }
    else {
      text = descriptor.getLabel();
      nodeName = descriptor.getName();
    }

    if (text.equals(XDebuggerUIConstants.getCollectingDataMessage())) {
      descriptorText.append(XDebuggerUIConstants.getCollectingDataMessage(), XDebuggerUIConstants.COLLECTING_DATA_HIGHLIGHT_ATTRIBUTES);
      return descriptorText;
    }

    String[] strings = breakString(text, nodeName);

    if (strings[0] != null) {
      if (descriptor instanceof MessageDescriptor && ((MessageDescriptor)descriptor).getKind() == MessageDescriptor.SPECIAL) {
        descriptorText.append(strings[0], SPECIAL_NODE_ATTRIBUTES);
      }
      else {
        descriptorText.append(strings[0], DEFAULT_ATTRIBUTES);
      }
    }
    if (strings[1] != null) {
      descriptorText.append(strings[1], XDebuggerUIConstants.VALUE_NAME_ATTRIBUTES);
    }
    if (strings[2] != null) {
      if (descriptor instanceof ValueDescriptorImpl valueDescriptor) {
        if (multiline && strings[2].indexOf('\n') >= 0) {
          strings = breakString(strings[2], "=");
          if (strings[2] != null) {
            strings[2] = strings[0] + strings[1] + "\n" + strings[2];
          }
        }


        String valueLabel = valueDescriptor.getValueLabel();

        strings = breakString(strings[2], valueLabel);
        if (strings[0] != null) {
          descriptorText.append(strings[0], DEFAULT_ATTRIBUTES);
        }
        if (appendValue && strings[1] != null) {
          if (valueLabel != null && StringUtil.startsWithChar(valueLabel, '{') && valueLabel.indexOf('}') > 0 && !StringUtil.endsWithChar(valueLabel, '}')) {
            int idx = valueLabel.indexOf('}');
            String objectId = valueLabel.substring(0, idx + 1);
            valueLabel = valueLabel.substring(idx + 1);
            descriptorText.append(objectId, OBJECT_ID_HIGHLIGHT_ATTRIBUTES);
          }

          valueLabel = DebuggerUtilsEx.truncateString(valueLabel);

          final SimpleTextAttributes valueLabelAttribs;
          if (valueDescriptor.isDirty()) {
            valueLabelAttribs = XDebuggerUIConstants.CHANGED_VALUE_ATTRIBUTES;
          }
          else {
            TextAttributes attributes = null;
            if (valueDescriptor.isNull()) {
              attributes = colorScheme.getAttributes(JavaHighlightingColors.KEYWORD);
            }
            else if (valueDescriptor.isString()) {
              attributes = colorScheme.getAttributes(JavaHighlightingColors.STRING);
            }
            valueLabelAttribs = attributes != null ? SimpleTextAttributes.fromTextAttributes(attributes) : DEFAULT_ATTRIBUTES;
          }

          final EvaluateException exception = descriptor.getEvaluateException();
          if (exception != null) {
            final String errorMessage = exception.getMessage();
            final String valueText;
            if (valueLabel.endsWith(errorMessage)) {
              valueText = valueLabel.substring(0, valueLabel.length() - errorMessage.length());
            }
            else {
              valueText = valueLabel;
            }
            appendValueTextWithEscapesRendering(descriptorText, valueText, valueLabelAttribs, colorScheme);
            descriptorText.append(errorMessage, XDebuggerUIConstants.EXCEPTION_ATTRIBUTES);
          }
          else {
            if (valueLabel.equals(XDebuggerUIConstants.getCollectingDataMessage())) {
              descriptorText.append(XDebuggerUIConstants.getCollectingDataMessage(), XDebuggerUIConstants.COLLECTING_DATA_HIGHLIGHT_ATTRIBUTES);
            }
            else {
              appendValueTextWithEscapesRendering(descriptorText, valueLabel, valueLabelAttribs, colorScheme);
            }
          }
        }
      }
      else {
        descriptorText.append(strings[2], DEFAULT_ATTRIBUTES);
      }
    }

    return descriptorText;
  }

  private static void appendValueTextWithEscapesRendering(SimpleColoredText descriptorText,
                                                          String valueText,
                                                          SimpleTextAttributes attribs,
                                                          EditorColorsScheme colorScheme) {
    SimpleTextAttributes escapeAttribs = null;
    final @NlsSafe StringBuilder buf = new StringBuilder();
    boolean slashFound = false;
    for (int idx = 0; idx < valueText.length(); idx++) {
      final char ch = valueText.charAt(idx);
      if (slashFound) {
        slashFound = false;
        if (ch == '\\' || ch == '\"' || ch == 'b' || ch == 't' || ch == 'n' || ch == 'f' || ch == 'r') {
          if (buf.length() > 0) {
            descriptorText.append(buf.toString(), attribs);
            buf.setLength(0);
          }

          if (escapeAttribs == null) { // lazy init
            TextAttributes fromHighlighter = colorScheme.getAttributes(JavaHighlightingColors.VALID_STRING_ESCAPE);
            if (fromHighlighter != null) {
              escapeAttribs = SimpleTextAttributes.fromTextAttributes(fromHighlighter);
            }
            else {
              escapeAttribs = DEFAULT_ATTRIBUTES.derive(SimpleTextAttributes.STYLE_BOLD, JBColor.GRAY, null, null);
            }
          }

          if (ch != '\\' && ch != '\"') {
            descriptorText.append("\\", escapeAttribs);
          }
          descriptorText.append(String.valueOf(ch), escapeAttribs);
        }
        else {
          buf.append('\\').append(ch);
        }
      }
      else {
        if (ch == '\\') {
          slashFound = true;
        }
        else {
          buf.append(ch);
        }
      }
    }
    if (buf.length() > 0) {
      descriptorText.append(buf.toString(), attribs);
    }
  }

  private static String[] breakString(String source, String substr) {
    if (substr != null && substr.length() > 0) {
      int index = Math.max(source.indexOf(substr), 0);
      String prefix = (index > 0) ? source.substring(0, index) : null;
      index += substr.length();
      String suffix = (index < source.length() - 1) ? source.substring(index) : null;
      return new String[]{prefix, substr, suffix};
    }
    return new String[]{source, null, null};
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

/*
 * Class NodeComparator
 * @author Jeka
 */
package com.intellij.debugger.ui.impl.nodes;

import com.intellij.debugger.ui.tree.DebuggerTreeNode;

import java.util.Comparator;

/**
 * Compares given DebuggerTreeTest by name
 */
public class NodeComparator implements Comparator<DebuggerTreeNode> {
  @Override
  public int compare(final DebuggerTreeNode node1, final DebuggerTreeNode node2) {
    final String name1 = node1.getDescriptor().getName();
    final String name2 = node2.getDescriptor().getName();
    final boolean invalid1 = (name1 == null || (name1.length() > 0 && Character.isDigit(name1.charAt(0))));
    final boolean invalid2 = (name2 == null || (name2.length() > 0 && Character.isDigit(name2.charAt(0))));
    if (invalid1) {
      return invalid2 ? 0 : 1;
    }
    else if (invalid2) {
      return -1;
    }
    if ("this".equals(name1) || "static".equals(name1)) {
      return -1;
    }
    if ("this".equals(name2) || "static".equals(name2)) {
      return 1;
    }
    return name1.compareToIgnoreCase(name2);
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl;

import com.intellij.debugger.DebuggerInvocationUtil;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.SuspendContextImpl;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.events.DebuggerCommandImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.DebuggerSession;
import com.intellij.debugger.jdi.StackFrameProxyImpl;
import com.intellij.debugger.jdi.ThreadGroupReferenceProxyImpl;
import com.intellij.debugger.jdi.ThreadReferenceProxyImpl;
import com.intellij.debugger.jdi.VirtualMachineProxyImpl;
import com.intellij.debugger.settings.ThreadsViewSettings;
import com.intellij.debugger.ui.impl.watch.*;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.util.ui.tree.TreeModelAdapter;
import com.intellij.xdebugger.XDebuggerBundle;

import javax.swing.*;
import javax.swing.event.TreeModelEvent;
import javax.swing.tree.TreePath;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;

public class ThreadsDebuggerTree extends DebuggerTree {
  private static final Logger LOG = Logger.getInstance(ThreadsDebuggerTree.class);

  public ThreadsDebuggerTree(Project project) {
    super(project);
    getEmptyText().setText(XDebuggerBundle.message("debugger.threads.not.available"));
  }

  @Override
  protected NodeManagerImpl createNodeManager(Project project) {
    return new NodeManagerImpl(project, this) {
      @Override
      public String getContextKey(StackFrameProxyImpl frame) {
        return "ThreadsView";
      }
    };
  }

  @Override
  protected boolean isExpandable(DebuggerTreeNodeImpl node) {
    NodeDescriptorImpl descriptor = node.getDescriptor();
    if (descriptor instanceof StackFrameDescriptorImpl) {
      return false;
    }
    return descriptor.isExpandable();
  }

  @Override
  protected void build(DebuggerContextImpl context) {
    DebuggerSession session = context.getDebuggerSession();
    final RefreshThreadsTreeCommand command = new RefreshThreadsTreeCommand(session);

    final DebuggerSession.State state = session != null ? session.getState() : DebuggerSession.State.DISPOSED;
    if (ApplicationManager.getApplication().isUnitTestMode() || state == DebuggerSession.State.PAUSED || state == DebuggerSession.State.RUNNING) {
      showMessage(MessageDescriptor.EVALUATING);
      context.getDebugProcess().getManagerThread().schedule(command);
    }
    else {
      showMessage(session != null ? session.getStateDescription() : JavaDebuggerBundle.message("status.debug.stopped"));
    }
  }

  private class RefreshThreadsTreeCommand extends DebuggerCommandImpl {
    private final DebuggerSession mySession;

    RefreshThreadsTreeCommand(DebuggerSession session) {
      mySession = session;
    }

    @Override
    protected void action() {
      final DebuggerTreeNodeImpl root = getNodeFactory().getDefaultNode();

      final DebugProcessImpl debugProcess = mySession.getProcess();
      if (!debugProcess.isAttached()) {
        return;
      }
      final DebuggerContextImpl context = mySession.getContextManager().getContext();
      final SuspendContextImpl suspendContext = context.getSuspendContext();
      final ThreadReferenceProxyImpl suspendContextThread = suspendContext != null ? suspendContext.getThread() : null;

      final boolean showGroups = ThreadsViewSettings.getInstance().SHOW_THREAD_GROUPS;
      try {
        final ThreadReferenceProxyImpl currentThread = ThreadsViewSettings.getInstance().SHOW_CURRENT_THREAD ? suspendContextThread : null;
        final VirtualMachineProxyImpl vm = debugProcess.getVirtualMachineProxy();

        final EvaluationContextImpl evaluationContext = suspendContext != null ? getDebuggerContext().createEvaluationContext() : null;
        final NodeManagerImpl nodeManager = getNodeFactory();

        if (showGroups) {
          ThreadGroupReferenceProxyImpl topCurrentGroup = null;

          if (currentThread != null) {
            topCurrentGroup = currentThread.threadGroupProxy();
            if (topCurrentGroup != null) {
              for (ThreadGroupReferenceProxyImpl parentGroup = topCurrentGroup.parent(); parentGroup != null; parentGroup = parentGroup.parent()) {
                topCurrentGroup = parentGroup;
              }
            }

            if (topCurrentGroup != null) {
              root.add(nodeManager.createNode(nodeManager.getThreadGroupDescriptor(null, topCurrentGroup), evaluationContext));
            }
            else {
              root.add(nodeManager.createNode(nodeManager.getThreadDescriptor(null, currentThread), evaluationContext));
            }
          }

          for (ThreadGroupReferenceProxyImpl group : vm.topLevelThreadGroups()) {
            if (group != topCurrentGroup) {
              DebuggerTreeNodeImpl threadGroup = nodeManager.createNode(nodeManager.getThreadGroupDescriptor(null, group), evaluationContext);
              root.add(threadGroup);
            }
          }
        }
        else {
          // do not show thread groups
          if (currentThread != null) {
            root.insert(nodeManager.createNode(nodeManager.getThreadDescriptor(null, currentThread), evaluationContext), 0);
          }
          List<ThreadReferenceProxyImpl> allThreads = new ArrayList<>(vm.allThreads());
          allThreads.sort(ThreadReferenceProxyImpl.ourComparator);

          for (ThreadReferenceProxyImpl threadProxy : allThreads) {
            if (threadProxy.equals(currentThread)) {
              continue;
            }
            root.add(nodeManager.createNode(nodeManager.getThreadDescriptor(null, threadProxy), evaluationContext));
          }
        }
      }
      catch (Exception ex) {
        root.add(MessageDescriptor.DEBUG_INFO_UNAVAILABLE);
        LOG.debug(ex);
      }

      final boolean hasThreadToSelect = suspendContextThread != null; // thread can be null if pause was pressed
      final List<ThreadGroupReferenceProxyImpl> groups;
      if (hasThreadToSelect && showGroups) {
        groups = new ArrayList<>();
        for (ThreadGroupReferenceProxyImpl group = suspendContextThread.threadGroupProxy(); group != null; group = group.parent()) {
          groups.add(group);
        }
        Collections.reverse(groups);
      }
      else {
        groups = Collections.emptyList();
      }

      DebuggerInvocationUtil.swingInvokeLater(getProject(), () -> {
        getMutableModel().setRoot(root);
        treeChanged();
        if (hasThreadToSelect) {
          selectThread(groups, suspendContextThread, true);
        }
      });
    }

    private void selectThread(final List<ThreadGroupReferenceProxyImpl> pathToThread, final ThreadReferenceProxyImpl thread, final boolean expand) {
      LOG.assertTrue(SwingUtilities.isEventDispatchThread());
      class MyTreeModelAdapter extends TreeModelAdapter {
        private void structureChanged(DebuggerTreeNodeImpl node) {
          for (Enumeration enumeration = node.children(); enumeration.hasMoreElements(); ) {
            DebuggerTreeNodeImpl child = (DebuggerTreeNodeImpl)enumeration.nextElement();
            nodeChanged(child);
          }
        }

        private void nodeChanged(DebuggerTreeNodeImpl debuggerTreeNode) {
          if (pathToThread.size() == 0) {
            if (debuggerTreeNode.getDescriptor() instanceof ThreadDescriptorImpl && ((ThreadDescriptorImpl)debuggerTreeNode.getDescriptor()).getThreadReference() == thread) {
              removeListener();
              final TreePath treePath = new TreePath(debuggerTreeNode.getPath());
              setSelectionPath(treePath);
              if (expand && !isExpanded(treePath)) {
                expandPath(treePath);
              }
            }
          }
          else {
            if (debuggerTreeNode.getDescriptor() instanceof ThreadGroupDescriptorImpl && ((ThreadGroupDescriptorImpl)debuggerTreeNode.getDescriptor()).getThreadGroupReference() == pathToThread.get(0)) {
              pathToThread.remove(0);
              expandPath(new TreePath(debuggerTreeNode.getPath()));
            }
          }
        }

        private void removeListener() {
          final TreeModelAdapter listener = this;
          SwingUtilities.invokeLater(() -> getModel().removeTreeModelListener(listener));
        }

        @Override
        public void treeStructureChanged(TreeModelEvent event) {
          if (event.getPath().length <= 1) {
            removeListener();
            return;
          }
          structureChanged((DebuggerTreeNodeImpl)event.getTreePath().getLastPathComponent());
        }
      }

      MyTreeModelAdapter listener = new MyTreeModelAdapter();
      listener.structureChanged((DebuggerTreeNodeImpl)getModel().getRoot());
      getModel().addTreeModelListener(listener);
    }
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.impl;

import com.intellij.debugger.actions.DebuggerAction;
import com.intellij.debugger.actions.GotoFrameSourceAction;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.events.DebuggerCommandImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.DebuggerContextListener;
import com.intellij.debugger.impl.DebuggerSession;
import com.intellij.debugger.impl.DebuggerStateManager;
import com.intellij.debugger.ui.impl.watch.DebuggerTree;
import com.intellij.debugger.ui.impl.watch.DebuggerTreeNodeImpl;
import com.intellij.ide.DataManager;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPopupMenu;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import com.intellij.openapi.actionSystem.PlatformCoreDataKeys;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Disposer;
import com.intellij.ui.ScrollPaneFactory;
import com.intellij.util.Alarm;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Enumeration;
import java.util.NoSuchElementException;

public class ThreadsPanel extends DebuggerTreePanel {
  @NonNls private static final String POPUP_ACTION_NAME = "Debugger.ThreadsPanelPopup";
  @NonNls private static final String HELP_ID = "debugging.debugThreads";
  private final Alarm myUpdateLabelsAlarm = new Alarm();
  private static final int LABELS_UPDATE_DELAY_MS = 200;

  public ThreadsPanel(Project project, final DebuggerStateManager stateManager) {
    super(project, stateManager);

    final Disposable disposable = DebuggerAction.installEditAction(getThreadsTree(), "Debugger.EditFrameSource");
    registerDisposable(disposable);

    getThreadsTree().addKeyListener(new KeyAdapter() {
      @Override
      public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_ENTER && getThreadsTree().getSelectionCount() == 1) {
          GotoFrameSourceAction.doAction(DataManager.getInstance().getDataContext(getThreadsTree()));
        }
      }
    });
    add(ScrollPaneFactory.createScrollPane(getThreadsTree()), BorderLayout.CENTER);
    stateManager.addListener(new DebuggerContextListener() {
      @Override
      public void changeEvent(@NotNull DebuggerContextImpl newContext, DebuggerSession.Event event) {
        if (DebuggerSession.Event.ATTACHED == event || DebuggerSession.Event.RESUME == event) {
          startLabelsUpdate();
        }
        else if (DebuggerSession.Event.PAUSE == event || DebuggerSession.Event.DETACHED == event || DebuggerSession.Event.DISPOSE == event) {
          myUpdateLabelsAlarm.cancelAllRequests();
        }
        if (DebuggerSession.Event.DETACHED == event || DebuggerSession.Event.DISPOSE == event) {
          stateManager.removeListener(this);
        }
      }
    });
    startLabelsUpdate();
  }

  private void startLabelsUpdate() {
    if (myUpdateLabelsAlarm.isDisposed()) {
      return;
    }
    myUpdateLabelsAlarm.cancelAllRequests();
    myUpdateLabelsAlarm.addRequest(new Runnable() {
      @Override
      public void run() {
        boolean updateScheduled = false;
        try {
          if (isUpdateEnabled()) {
            final ThreadsDebuggerTree tree = getThreadsTree();
            final DebuggerTreeNodeImpl root = (DebuggerTreeNodeImpl)tree.getModel().getRoot();
            if (root != null) {
              final DebugProcessImpl process = getContext().getDebugProcess();
              if (process != null) {
                process.getManagerThread().invoke(new DebuggerCommandImpl() {
                  @Override
                  protected void action() {
                    try {
                      updateNodeLabels(root);
                    }
                    finally {
                      reschedule();
                    }
                  }

                  @Override
                  protected void commandCancelled() {
                    reschedule();
                  }
                });
                updateScheduled = true;
              }
            }
          }
        }
        finally {
          if (!updateScheduled) {
            reschedule();
          }
        }
      }

      private void reschedule() {
        final DebuggerSession session = getContext().getDebuggerSession();
        if (session != null && session.isAttached() && !session.isPaused() && !myUpdateLabelsAlarm.isDisposed()) {
          myUpdateLabelsAlarm.addRequest(this, LABELS_UPDATE_DELAY_MS, ModalityState.nonModal());
        }
      }
    }, LABELS_UPDATE_DELAY_MS, ModalityState.nonModal());
  }

  @Override
  public void dispose() {
    Disposer.dispose(myUpdateLabelsAlarm);
    super.dispose();
  }

  public JComponent getDefaultFocusedComponent() {
    return getThreadsTree();
  }

  private static void updateNodeLabels(DebuggerTreeNodeImpl from) {
    Enumeration children = from.children();
    try {
      while (children.hasMoreElements()) {
        DebuggerTreeNodeImpl child = (DebuggerTreeNodeImpl)children.nextElement();
        child.getDescriptor().updateRepresentation(null, child::labelChanged);
        updateNodeLabels(child);
      }
    }
    catch (NoSuchElementException ignored) { // children have changed - just skip
    }
  }

  @Override
  protected DebuggerTree createTreeView() {
    return new ThreadsDebuggerTree(getProject());
  }

  @Override
  protected ActionPopupMenu createPopupMenu() {
    DefaultActionGroup group = (DefaultActionGroup)ActionManager.getInstance().getAction(POPUP_ACTION_NAME);
    return ActionManager.getInstance().createActionPopupMenu(POPUP_ACTION_NAME, group);
  }

  @Override
  public Object getData(@NotNull String dataId) {
    if (PlatformCoreDataKeys.HELP_ID.is(dataId)) {
      return HELP_ID;
    }
    return super.getData(dataId);
  }

  public ThreadsDebuggerTree getThreadsTree() {
    return (ThreadsDebuggerTree)getTree();
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl;

import com.intellij.application.Topics;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.actionSystem.ActionUpdateThread;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.actionSystem.CommonShortcuts;
import com.intellij.openapi.application.ApplicationActivationListener;
import com.intellij.openapi.keymap.KeymapUtil;
import com.intellij.openapi.util.Disposer;
import com.intellij.openapi.util.Weighted;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.openapi.wm.IdeFrame;
import com.intellij.openapi.wm.IdeGlassPane;
import com.intellij.openapi.wm.IdeGlassPaneUtil;
import com.intellij.util.Alarm;
import com.intellij.util.ui.UIUtil;
import com.intellij.util.ui.update.Activatable;
import com.intellij.util.ui.update.UiNotifyConnector;
import com.intellij.xdebugger.settings.XDebuggerSettingsManager;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import java.awt.*;
import java.awt.event.*;

@Deprecated
public final class TipManager implements Disposable, PopupMenuListener {
  private volatile boolean myIsDisposed = false;
  private boolean myPopupShown;
  private MyAwtPreprocessor myHideCanceller;

  private MouseEvent myLastMouseEvent;

  public interface TipFactory {
    JComponent createToolTip(MouseEvent e);

    MouseEvent createTooltipEvent(MouseEvent candidateEvent);

    boolean isFocusOwner();
  }

  private boolean isOverTip(MouseEvent e) {
    if (myCurrentTooltip != null) {
      if (!myCurrentTooltip.isShowing()) {
        hideTooltip(true);
        return false;
      }
      final Component eventOriginator = e.getComponent();
      if (eventOriginator == null) {
        return false;
      }
      final Point point = e.getPoint();
      SwingUtilities.convertPointToScreen(point, eventOriginator);

      final Rectangle bounds = myCurrentTooltip.getBounds();
      final Point tooltipLocationOnScreen = myCurrentTooltip.getLocationOnScreen();
      bounds.setLocation(tooltipLocationOnScreen.x, tooltipLocationOnScreen.y);

      return bounds.contains(point);
    }
    return false;
  }

  boolean myInsideComponent;

  private class MyMouseListener extends MouseAdapter implements Weighted {
    @Override
    public void mouseExited(final MouseEvent e) {
      myInsideComponent = false;
    }

    @Override
    public void mousePressed(final MouseEvent e) {
      if (myInsideComponent) {
        hideTooltip(true);
      }
    }

    @Override
    public double getWeight() {
      return 0;
    }

    @Override
    public void mouseEntered(final MouseEvent e) {
      myInsideComponent = true;
    }
  }

  private class MyFrameStateListener implements ApplicationActivationListener {
    @Override
    public void applicationDeactivated(@NotNull IdeFrame ideFrame) {
      hideTooltip(true);
    }
  }

  public JPopupMenu registerPopup(JPopupMenu menu) {
    menu.addPopupMenuListener(this);
    return menu;
  }

  @Override
  public void popupMenuWillBecomeVisible(final PopupMenuEvent e) {
    myPopupShown = true;
  }

  @Override
  public void popupMenuWillBecomeInvisible(final PopupMenuEvent e) {
    onPopupClosed(e);
  }

  @Override
  public void popupMenuCanceled(final PopupMenuEvent e) {
    onPopupClosed(e);
  }

  private void onPopupClosed(final PopupMenuEvent e) {
    myPopupShown = false;
    if (e.getSource() instanceof JPopupMenu) {
      ((JPopupMenu)e.getSource()).removePopupMenuListener(this);
    }
  }

  private class MyMouseMotionListener extends MouseMotionAdapter implements Weighted {
    @Override
    public void mouseMoved(final MouseEvent e) {
      myLastMouseEvent = e;

      if (!myComponent.isShowing()) return;

      myInsideComponent = true;

      if (myCurrentTooltip == null) {
        if (isInsideComponent(e)) {
          tryTooltip(e, true);
        }
      }
      else {
        if (!isOverTip(e)) {
          tryTooltip(e, true);
        }
      }
    }

    @Override
    public double getWeight() {
      return 0;
    }
  }

  private boolean isInsideComponent(final MouseEvent e) {
    final Rectangle compBounds = myComponent.getVisibleRect();
    final Point compPoint = SwingUtilities.convertPoint(e.getComponent(), e.getPoint(), myComponent);

    return compBounds.contains(compPoint);
  }


  private void tryTooltip(final InputEvent e, final boolean auto) {
    myShowAlarm.cancelAllRequests();
    myHideAlarm.cancelAllRequests();
    myShowAlarm.addRequest(() -> {
      if (!myIsDisposed && !myPopupShown) {
        showTooltip(e, auto);
      }
    }, auto ? XDebuggerSettingsManager.getInstance().getDataViewSettings().getValueLookupDelay() : 10);
  }

  private void showTooltip(InputEvent e, boolean auto) {
    if (auto && !Registry.is("debugger.valueTooltipAutoShow")) return;

    MouseEvent sourceEvent = null;
    JComponent newTip = null;

    if (e instanceof MouseEvent) {
      sourceEvent = (MouseEvent)e;
    }
    else if (e instanceof KeyEvent) {
      sourceEvent = myTipFactory.createTooltipEvent(myLastMouseEvent);
    }


    MouseEvent convertedEvent = null;
    if (sourceEvent != null) {
      convertedEvent = SwingUtilities.convertMouseEvent(sourceEvent.getComponent(), sourceEvent, myComponent);
      newTip = myTipFactory.createToolTip(convertedEvent);
    }

    if (newTip == null || (auto && !myTipFactory.isFocusOwner())) {
      hideTooltip(false);
      return;
    }

    if (newTip == myCurrentTooltip) {
      if (!auto) {
        hideTooltip(true);
        return;
      }
      return;
    }

    hideTooltip(true);

    if (myComponent.isShowing()) {
      PopupFactory popupFactory = PopupFactory.getSharedInstance();
      final Point location = convertedEvent.getPoint();
      final Component sourceComponent = convertedEvent.getComponent();
      if (sourceComponent != null) {
        SwingUtilities.convertPointToScreen(location, sourceComponent);
      }

      myTipPopup = popupFactory.getPopup(myComponent, newTip, location.x, location.y);
      myInsideComponent = false;
      myTipPopup.show();
      myCurrentTooltip = newTip;
    }
  }

  public void hideTooltip() {
    hideTooltip(true);
  }

  public void hideTooltip(boolean now) {
    if (myTipPopup == null) return;

    if (now) {
      myHideAlarm.cancelAllRequests();
      myTipPopup.hide();
      myTipPopup = null;
      myCurrentTooltip = null;
    }
    else {
      myHideAlarm.addRequest(() -> {
        if (myInsideComponent) {
          hideTooltip(true);
        }
      }, 100);
    }
  }

  private JComponent myCurrentTooltip;
  private Popup myTipPopup;
  private final TipFactory myTipFactory;
  private final JComponent myComponent;
  private MouseListener myMouseListener = new MyMouseListener();
  private MouseMotionListener myMouseMotionListener = new MyMouseMotionListener();

  private final Alarm myShowAlarm = new Alarm();
  private final Alarm myHideAlarm = new Alarm();

  public TipManager(final JComponent component, TipFactory factory) {
    myTipFactory = factory;
    myComponent = component;

    UiNotifyConnector.Once.installOn(component, new Activatable() {
      @Override
      public void showNotify() {
        installListeners();
      }
    });

    final HideTooltipAction hide = new HideTooltipAction();
    hide.registerCustomShortcutSet(CommonShortcuts.ESCAPE, myComponent);
    Disposer.register(this, new Disposable() {
      @Override
      public void dispose() {
        hide.unregisterCustomShortcutSet(myComponent);
      }
    });
  }


  private class HideTooltipAction extends AnAction {
    @Override
    public void actionPerformed(@NotNull AnActionEvent e) {
      hideTooltip(true);
    }

    @Override
    public void update(@NotNull AnActionEvent e) {
      e.getPresentation().setEnabled(myTipPopup != null);
    }

    @Override
    public @NotNull ActionUpdateThread getActionUpdateThread() {
      return ActionUpdateThread.EDT;
    }
  }

  private void installListeners() {
    if (myIsDisposed) return;

    IdeGlassPane GP = IdeGlassPaneUtil.find(myComponent);
    assert GP != null;

    GP.addMousePreprocessor(myMouseListener, this);
    GP.addMouseMotionPreprocessor(myMouseMotionListener, this);

    myHideCanceller = new MyAwtPreprocessor();
    Toolkit.getDefaultToolkit().addAWTEventListener(myHideCanceller, AWTEvent.MOUSE_MOTION_EVENT_MASK | AWTEvent.KEY_EVENT_MASK | AWTEvent.MOUSE_EVENT_MASK);
    Topics.subscribe(ApplicationActivationListener.TOPIC, this, new MyFrameStateListener());
  }

  @Override
  public void dispose() {
    hideTooltip(true);

    Toolkit.getDefaultToolkit().removeAWTEventListener(myHideCanceller);

    myIsDisposed = true;
    myShowAlarm.cancelAllRequests();
    myMouseListener = null;
    myMouseMotionListener = null;
  }

  private class MyAwtPreprocessor implements AWTEventListener {

    @Override
    public void eventDispatched(AWTEvent event) {
      if (event.getID() == MouseEvent.MOUSE_MOVED) {
        preventFromHideIfInsideTooltip(event);
      }
      else if (event.getID() == MouseEvent.MOUSE_PRESSED || event.getID() == MouseEvent.MOUSE_RELEASED) {
        hideTooltipIfCloseClick((MouseEvent)event);
      }
      else if (event instanceof KeyEvent) {
        tryToShowTooltipIfRequested((KeyEvent)event);
      }
    }

    private void hideTooltipIfCloseClick(MouseEvent me) {
      if (myCurrentTooltip == null) return;

      if (isInsideTooltip(me) && UIUtil.isCloseClick(me)) {
        hideTooltip(true);
      }
    }

    private void tryToShowTooltipIfRequested(KeyEvent event) {
      if (KeymapUtil.isTooltipRequest(event)) {
        tryTooltip(event, false);
      }
      else {
        if (event.getID() == KeyEvent.KEY_PRESSED) {
          myLastMouseEvent = null;
        }
      }
    }

    private void preventFromHideIfInsideTooltip(AWTEvent event) {
      if (myCurrentTooltip == null) return;

      if (event.getID() == MouseEvent.MOUSE_MOVED) {
        final MouseEvent me = (MouseEvent)event;
        if (isInsideTooltip(me)) {
          myHideAlarm.cancelAllRequests();
        }
      }
    }

    private boolean isInsideTooltip(MouseEvent me) {
      return myCurrentTooltip == me.getComponent() || SwingUtilities.isDescendingFrom(me.getComponent(), myCurrentTooltip);
    }
  }
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.impl.tree;

import com.intellij.util.EventDispatcher;

import javax.swing.event.TreeModelEvent;
import javax.swing.event.TreeModelListener;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;

public abstract class TreeBuilder implements TreeModel {
  private final Object userObject;
  private TreeBuilderNode myRoot;
  private final EventDispatcher<TreeModelListener> myDispatcher = EventDispatcher.create(TreeModelListener.class);

  protected TreeBuilder(Object userObject) {
    this.userObject = userObject;
  }

  public Object getUserObject() {
    return userObject;
  }

  public abstract void buildChildren(TreeBuilderNode node);

  public abstract boolean isExpandable(TreeBuilderNode node);

  public void setRoot(TreeBuilderNode root) {
    myRoot = root;
  }

  @Override
  public Object getRoot() {
    return myRoot;
  }

  @Override
  public int getChildCount(Object parent) {
    return ((TreeBuilderNode)parent).getChildCount();
  }

  @Override
  public boolean isLeaf(Object node) {
    return ((TreeBuilderNode)node).isLeaf();
  }

  @Override
  public void addTreeModelListener(TreeModelListener l) {
    myDispatcher.addListener(l);
  }

  @Override
  public void removeTreeModelListener(TreeModelListener l) {
    myDispatcher.removeListener(l);
  }

  @Override
  public Object getChild(Object parent, int index) {
    return ((TreeBuilderNode)parent).getChildAt(index);
  }

  @Override
  public int getIndexOfChild(Object parent, Object child) {
    return ((TreeBuilderNode)parent).getIndex((TreeNode)child);
  }

  @Override
  public void valueForPathChanged(TreePath path, Object newValue) {
    TreeBuilderNode aNode = (TreeBuilderNode)path.getLastPathComponent();

    aNode.setUserObject(newValue);
    nodeChanged(aNode);
  }

  public void nodeChanged(TreeNode node) {
    TreeModelEvent event = null;
    TreeNode parent = node.getParent();
    if (parent != null) {
      int anIndex = parent.getIndex(node);
      event = new TreeModelEvent(this, getPathToRoot(parent, 0), new int[]{anIndex}, new Object[]{node});
    }
    else if (node == getRoot()) {
      event = new TreeModelEvent(this, getPathToRoot(node, 0), null, null);
    }
    if (event != null) {
      myDispatcher.getMulticaster().treeNodesChanged(event);
    }
  }

  public void nodeStructureChanged(TreeNode node) {
    TreeModelEvent event = new TreeModelEvent(this, getPathToRoot(node, 0), null, null);
    myDispatcher.getMulticaster().treeStructureChanged(event);
  }

  protected TreeNode[] getPathToRoot(TreeNode aNode, int depth) {
    TreeNode[] retNodes;
    if (aNode == null) {
      if (depth == 0) {
        return null;
      }
      else {
        retNodes = new TreeNode[depth];
      }
    }
    else {
      depth++;
      if (aNode == myRoot) {
        retNodes = new TreeNode[depth];
      }
      else {
        retNodes = getPathToRoot(aNode.getParent(), depth);
      }
      retNodes[retNodes.length - depth] = aNode;
    }
    return retNodes;
  }

  public void removeNodeFromParent(TreeBuilderNode node) {
    final TreeBuilderNode parent = (TreeBuilderNode)node.getParent();
    if (parent != null) {
      parent.remove(node);
    }
  }
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.impl.tree;

import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import java.util.Enumeration;

public abstract class TreeBuilderNode extends DefaultMutableTreeNode {
  private boolean myChildrenBuilt = false;

  public TreeBuilderNode(Object userObject) {
    super(userObject);
  }

  abstract protected TreeBuilder getTreeBuilder();

  private void checkChildren() {
    synchronized (this) {
      if (myChildrenBuilt) {
        return;
      }
      myChildrenBuilt = true;
    }
    final TreeBuilder treeBuilder = getTreeBuilder();
    if (treeBuilder.isExpandable(this)) {
      treeBuilder.buildChildren(this);
    }
  }

  public void clear() {
    synchronized (this) {
      myChildrenBuilt = false;
    }
  }

  //TreeNode interface
  @Override
  public int getChildCount() {
    checkChildren();
    return super.getChildCount();
  }

  @Override
  public boolean getAllowsChildren() {
    checkChildren();
    return super.getAllowsChildren();
  }

  @Override
  public boolean isLeaf() {
    return !getTreeBuilder().isExpandable(this);
  }

  @Override
  public Enumeration children() {
    checkChildren();
    return super.children();
  }

  public Enumeration rawChildren() {
    return super.children();
  }

  @Override
  public TreeNode getChildAt(int childIndex) {
    checkChildren();
    return super.getChildAt(childIndex);
  }

  @Override
  public int getIndex(TreeNode node) {
    checkChildren();
    return super.getIndex(node);
  }
}
/*
 * Copyright 2000-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.impl;

import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.DebuggerContextListener;
import com.intellij.debugger.impl.DebuggerSession;
import com.intellij.debugger.impl.DebuggerStateManager;
import com.intellij.debugger.ui.DebuggerView;
import com.intellij.openapi.CompositeDisposable;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Disposer;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import java.awt.*;

public abstract class UpdatableDebuggerView extends JPanel implements DebuggerView {
  private final Project myProject;
  private final DebuggerStateManager myStateManager;
  private volatile boolean myRefreshNeeded = true;
  private final CompositeDisposable myDisposables = new CompositeDisposable();
  private volatile boolean myUpdateEnabled;

  protected UpdatableDebuggerView(final Project project, final DebuggerStateManager stateManager) {
    setLayout(new BorderLayout());
    myProject = project;
    myStateManager = stateManager;

    final DebuggerContextListener contextListener = this::changeEvent;
    myStateManager.addListener(contextListener);

    registerDisposable(new Disposable() {
      @Override
      public void dispose() {
        myStateManager.removeListener(contextListener);
      }
    });
  }

  protected void changeEvent(final DebuggerContextImpl newContext, final DebuggerSession.Event event) {
    if (newContext.getDebuggerSession() != null) {
      rebuildIfVisible(event);
    }
  }

  protected final boolean isUpdateEnabled() {
    return myUpdateEnabled || isShowing();
  }

  @Override
  public final void setUpdateEnabled(final boolean enabled) {
    myUpdateEnabled = enabled;
  }

  @Override
  public final boolean isRefreshNeeded() {
    return myRefreshNeeded;
  }

  @Override
  public final void rebuildIfVisible(final DebuggerSession.Event event) {
    if (isUpdateEnabled()) {
      myRefreshNeeded = false;
      rebuild(event);
    }
    else {
      myRefreshNeeded = true;
    }
  }

  protected abstract void rebuild(DebuggerSession.Event event);

  protected final void registerDisposable(Disposable disposable) {
    myDisposables.add(disposable);
  }

  @NotNull
  public DebuggerContextImpl getContext() {
    return myStateManager.getContext();
  }

  protected final Project getProject() {
    return myProject;
  }

  public DebuggerStateManager getContextManager() {
    return myStateManager;
  }

  public void dispose() {
    Disposer.dispose(myDisposables);
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.JavaValue;
import com.intellij.debugger.engine.JavaValueModifier;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.PositionUtil;
import com.intellij.debugger.jdi.DecompiledLocalVariable;
import com.intellij.debugger.jdi.LocalVariablesUtil;
import com.intellij.openapi.project.Project;
import com.intellij.psi.JavaPsiFacade;
import com.intellij.psi.PsiElementFactory;
import com.intellij.psi.PsiExpression;
import com.intellij.util.IncorrectOperationException;
import com.intellij.xdebugger.XExpression;
import com.intellij.xdebugger.frame.XValueModifier;
import com.sun.jdi.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class ArgumentValueDescriptorImpl extends ValueDescriptorImpl {
  private final DecompiledLocalVariable myVariable;

  public ArgumentValueDescriptorImpl(Project project, DecompiledLocalVariable variable, Value value) {
    super(project, value);
    myVariable = variable;
    setLvalue(true);
  }

  @Override
  public boolean canSetValue() {
    return LocalVariablesUtil.canSetValues();
  }

  @Override
  public boolean isPrimitive() {
    return getValue() instanceof PrimitiveValue;
  }

  @Override
  public Value calcValue(final EvaluationContextImpl evaluationContext) throws EvaluateException {
    return getValue();
  }

  public DecompiledLocalVariable getVariable() {
    return myVariable;
  }

  @Override
  public String getName() {
    return myVariable.getDisplayName();
  }

  public boolean isParameter() {
    return myVariable.isParam();
  }

  @Override
  public PsiExpression getDescriptorEvaluation(DebuggerContext context) throws EvaluateException {
    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(myProject);
    try {
      return elementFactory.createExpressionFromText(getName(), PositionUtil.getContextElement(context));
    }
    catch (IncorrectOperationException e) {
      throw new EvaluateException(JavaDebuggerBundle.message("error.invalid.local.variable.name", getName()), e);
    }
  }

  @Override
  public XValueModifier getModifier(JavaValue value) {
    return new JavaValueModifier(value) {
      @Override
      protected void setValueImpl(@NotNull XExpression expression, @NotNull XModificationCallback callback) {
        final DecompiledLocalVariable local = ArgumentValueDescriptorImpl.this.getVariable();
        if (local != null) {
          final DebuggerContextImpl debuggerContext = DebuggerManagerEx.getInstanceEx(getProject()).getContext();
          set(expression, callback, debuggerContext, new SetValueRunnable() {
            @Override
            public void setValue(EvaluationContextImpl evaluationContext, Value newValue) throws ClassNotLoadedException,
                                                                                                 InvalidTypeException,
                                                                                                 EvaluateException {
              LocalVariablesUtil.setValue(debuggerContext.getFrameProxy().getStackFrame(), local, newValue);
              update(debuggerContext);
            }

            @Nullable
            @Override
            public Type getLType() {
              return null;
            }
          });
        }
      }
    };
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.JavaValue;
import com.intellij.debugger.engine.JavaValueModifier;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.jdi.VirtualMachineProxyImpl;
import com.intellij.debugger.ui.tree.ArrayElementDescriptor;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.util.Ref;
import com.intellij.psi.JavaPsiFacade;
import com.intellij.psi.PsiElementFactory;
import com.intellij.psi.PsiExpression;
import com.intellij.util.IncorrectOperationException;
import com.intellij.xdebugger.XExpression;
import com.intellij.xdebugger.frame.XValueModifier;
import com.sun.jdi.*;
import org.jetbrains.annotations.NotNull;

public class ArrayElementDescriptorImpl extends ValueDescriptorImpl implements ArrayElementDescriptor {
  private final int myIndex;
  private final ArrayReference myArray;
  private Ref<Value> myPresetValue;

  public ArrayElementDescriptorImpl(Project project, ArrayReference array, int index) {
    super(project);
    myArray = array;
    myIndex = index;
    setLvalue(true);
  }

  @Override
  public int getIndex() {
    return myIndex;
  }

  @Override
  public ArrayReference getArray() {
    return myArray;
  }

  @Override
  public String getName() {
    return String.valueOf(myIndex);
  }

  public void setValue(Value value) {
    myPresetValue = Ref.create(value);
  }

  @Override
  public Value calcValue(EvaluationContextImpl evaluationContext) throws EvaluateException {
    if (myPresetValue != null) {
      return myPresetValue.get();
    }
    return getArrayElement(myArray, myIndex);
  }

  public static Value getArrayElement(ArrayReference reference, int idx) throws EvaluateException {
    try {
      return reference.getValue(idx);
    }
    catch (ObjectCollectedException e) {
      throw EvaluateExceptionUtil.ARRAY_WAS_COLLECTED;
    }
  }

  @Override
  public PsiExpression getDescriptorEvaluation(DebuggerContext context) throws EvaluateException {
    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(myProject);
    try {
      return elementFactory.createExpressionFromText("this[" + myIndex + "]", null);
    }
    catch (IncorrectOperationException e) {
      throw new EvaluateException(e.getMessage(), e);
    }
  }

  @Override
  public XValueModifier getModifier(JavaValue value) {
    return new JavaValueModifier(value) {
      @Override
      protected void setValueImpl(@NotNull XExpression expression, @NotNull XModificationCallback callback) {
        final ArrayElementDescriptorImpl elementDescriptor = ArrayElementDescriptorImpl.this;
        final ArrayReference array = elementDescriptor.getArray();
        if (array != null) {
          if (VirtualMachineProxyImpl.isCollected(array)) {
            // will only be the case if debugger does not use ObjectReference.disableCollection() because of Patches.IBM_JDK_DISABLE_COLLECTION_BUG
            Messages.showWarningDialog(getProject(), JavaDebuggerBundle.message("evaluation.error.array.collected") + "\n" + JavaDebuggerBundle
              .message("warning.recalculate"), JavaDebuggerBundle.message("title.set.value"));
            //node.getParent().calcValue();
            return;
          }
          final ArrayType arrType = (ArrayType)array.referenceType();
          final DebuggerContextImpl debuggerContext = DebuggerManagerEx.getInstanceEx(getProject()).getContext();
          set(expression, callback, debuggerContext, new SetValueRunnable() {
            @Override
            public void setValue(EvaluationContextImpl evaluationContext, Value newValue)
              throws ClassNotLoadedException, InvalidTypeException, EvaluateException {
              array.setValue(elementDescriptor.getIndex(), preprocessValue(evaluationContext, newValue, getLType()));
              update(debuggerContext);
            }

            @Override
            public ClassLoaderReference getClassLoader(EvaluationContextImpl evaluationContext) {
              return arrType.classLoader();
            }

            @NotNull
            @Override
            public Type getLType() throws ClassNotLoadedException {
              return arrType.componentType();
            }
          });
        }
      }
    };
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.DebuggerInvocationUtil;
import com.intellij.debugger.EvaluatingComputable;
import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.DebugProcess;
import com.intellij.debugger.engine.JVMNameUtil;
import com.intellij.debugger.engine.evaluation.*;
import com.intellij.debugger.engine.evaluation.expression.ExpressionEvaluator;
import com.intellij.debugger.engine.evaluation.expression.Modifier;
import com.intellij.debugger.impl.ClassLoadingUtils;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.jdi.VirtualMachineProxyImpl;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.compiler.ClassObject;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.projectRoots.JavaSdkVersion;
import com.intellij.psi.PsiElement;
import com.intellij.refactoring.extractMethodObject.LightMethodObjectExtractedData;
import com.sun.jdi.ClassLoaderReference;
import com.sun.jdi.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.org.objectweb.asm.ClassReader;
import org.jetbrains.org.objectweb.asm.ClassVisitor;
import org.jetbrains.org.objectweb.asm.ClassWriter;
import org.jetbrains.org.objectweb.asm.Opcodes;

import java.util.Collection;

public abstract class CompilingEvaluator implements ExpressionEvaluator {
  @NotNull protected final Project myProject;
  @NotNull protected final PsiElement myPsiContext;
  @NotNull protected final LightMethodObjectExtractedData myData;

  public CompilingEvaluator(@NotNull Project project, @NotNull PsiElement context, @NotNull LightMethodObjectExtractedData data) {
    myProject = project;
    myPsiContext = context;
    myData = data;
  }

  @Override
  public Modifier getModifier() {
    return null;
  }

  private TextWithImports getCallCode() {
    return new TextWithImportsImpl(CodeFragmentKind.CODE_BLOCK, myData.getGeneratedCallText());
  }

  @Override
  public Value evaluate(final EvaluationContext evaluationContext) throws EvaluateException {
    DebugProcess process = evaluationContext.getDebugProcess();

    EvaluationContextImpl autoLoadContext = ((EvaluationContextImpl)evaluationContext).withAutoLoadClasses(true);

    ClassLoaderReference classLoader = ClassLoadingUtils.getClassLoader(autoLoadContext, process);
    autoLoadContext.setClassLoader(classLoader);

    JavaSdkVersion version = JavaSdkVersion.fromVersionString(((VirtualMachineProxyImpl)process.getVirtualMachineProxy()).version());
    Collection<ClassObject> classes = compile(version);
    defineClasses(classes, autoLoadContext, process, classLoader);

    try {
      // invoke base evaluator on call code
      ExpressionEvaluator evaluator =
        DebuggerInvocationUtil.commitAndRunReadAction(myProject, new EvaluatingComputable<>() {
          @Override
          public ExpressionEvaluator compute() throws EvaluateException {
            TextWithImports callCode = getCallCode();
            PsiElement copyContext = myData.getAnchor();
            CodeFragmentFactory factory = DebuggerUtilsEx.findAppropriateCodeFragmentFactory(callCode, copyContext);
            return factory.getEvaluatorBuilder().build(factory.createCodeFragment(callCode, copyContext, myProject),
                                                       // can not use evaluation position here, it does not match classes then
                                                       SourcePosition.createFromElement(copyContext));
          }
        });
      return evaluator.evaluate(autoLoadContext);
    }
    catch (Exception e) {
      throw new EvaluateException("Error during generated code invocation " + e, e);
    }
  }

  private void defineClasses(Collection<ClassObject> classes,
                             EvaluationContext context,
                             DebugProcess process,
                             ClassLoaderReference classLoader) throws EvaluateException {
    boolean useMagicAccessorImpl = myData.useMagicAccessor();

    for (ClassObject cls : classes) {
      if (cls.getPath().contains(GEN_CLASS_NAME)) {
        byte[] bytes = cls.getContent();
        if (bytes != null) {
          if (useMagicAccessorImpl) {
            bytes = changeSuperToMagicAccessor(bytes);
          }
          ClassLoadingUtils.defineClass(cls.getClassName(), bytes, context, process, classLoader);
        }
      }
    }
    process.findClass(context, getGenClassQName(), classLoader);
  }

  private static byte[] changeSuperToMagicAccessor(byte[] bytes) {
    ClassWriter classWriter = new ClassWriter(0);
    ClassVisitor classVisitor = new ClassVisitor(Opcodes.API_VERSION, classWriter) {
      @Override
      public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
        if ("java/lang/Object".equals(superName)) {
          superName = "sun/reflect/MagicAccessorImpl";
        }
        super.visit(version, access, name, signature, superName, interfaces);
      }
    };
    new ClassReader(bytes).accept(classVisitor, 0);
    return classWriter.toByteArray();
  }

  @NotNull
  public static String getGeneratedClassName() {
    return GEN_CLASS_NAME;
  }

  private static final String GEN_CLASS_NAME = "GeneratedEvaluationClass";
  //private static final String GEN_CLASS_PACKAGE = "dummy";
  //private static final String GEN_CLASS_FULL_NAME = GEN_CLASS_PACKAGE + '.' + GEN_CLASS_NAME;
  //private static final String GEN_METHOD_NAME = "invoke";


  protected String getGenClassQName() {
    return ReadAction.compute(() -> JVMNameUtil.getNonAnonymousClassName(myData.getGeneratedInnerClass()));
  }

  ///////////////// Compiler stuff

  @NotNull
  protected abstract Collection<ClassObject> compile(@Nullable JavaSdkVersion debuggeeVersion) throws EvaluateException;
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.compiler.CompilerConfiguration;
import com.intellij.compiler.server.BuildManager;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.SuspendContextImpl;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.expression.ExpressionEvaluator;
import com.intellij.execution.configurations.JavaParameters;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.compiler.ClassObject;
import com.intellij.openapi.compiler.CompilationException;
import com.intellij.openapi.compiler.CompilerManager;
import com.intellij.openapi.compiler.CompilerMessageCategory;
import com.intellij.openapi.module.LanguageLevelUtil;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.module.ModuleUtilCore;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.projectRoots.JavaSdkVersion;
import com.intellij.openapi.projectRoots.Sdk;
import com.intellij.openapi.roots.ModuleRootManager;
import com.intellij.openapi.util.Pair;
import com.intellij.openapi.util.io.FileUtil;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.pom.java.LanguageLevel;
import com.intellij.psi.PsiCodeFragment;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiFile;
import com.intellij.refactoring.extractMethod.PrepareFailedException;
import com.intellij.refactoring.extractMethodObject.ExtractLightMethodObjectHandler;
import com.intellij.refactoring.extractMethodObject.LightMethodObjectExtractedData;
import com.intellij.xdebugger.XDebugSession;
import com.intellij.xdebugger.XDebuggerManager;
import com.intellij.xdebugger.frame.XSuspendContext;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.jps.incremental.java.JavaBuilder;
import org.jetbrains.jps.model.java.JpsJavaSdkType;
import org.jetbrains.jps.model.java.compiler.AnnotationProcessingConfiguration;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.function.Function;

// todo: consider batching compilations in order not to start a separate process for every class that needs to be compiled
public class CompilingEvaluatorImpl extends CompilingEvaluator {
  private Collection<ClassObject> myCompiledClasses;
  private final @Nullable Module myModule;
  private final @Nullable LanguageLevel myLanguageLevel;

  public CompilingEvaluatorImpl(@NotNull Project project,
                                @NotNull PsiElement context,
                                @NotNull LightMethodObjectExtractedData data) {
    super(project, context, data);
    Module module = ModuleUtilCore.findModuleForPsiElement(context);
    myModule = module;
    myLanguageLevel = module == null ? null : LanguageLevelUtil.getEffectiveLanguageLevel(module);
  }

  @Override
  @NotNull
  protected Collection<ClassObject> compile(@Nullable JavaSdkVersion debuggeeVersion) throws EvaluateException {
    if (myCompiledClasses == null) {
      List<String> options = new ArrayList<>();
      options.add("-encoding");
      options.add("UTF-8");
      List<File> platformClasspath = new ArrayList<>();
      List<File> classpath = new ArrayList<>();
      AnnotationProcessingConfiguration profile = null;
      if (myModule != null) {
        assert myProject.equals(myModule.getProject()) : myModule + " is from another project";
        profile = CompilerConfiguration.getInstance(myProject).getAnnotationProcessingConfiguration(myModule);
        ModuleRootManager rootManager = ModuleRootManager.getInstance(myModule);
        for (String s : rootManager.orderEntries().compileOnly().recursively().exportedOnly().withoutSdk().getPathsList().getPathList()) {
          classpath.add(new File(s));
        }
        for (String s : rootManager.orderEntries().compileOnly().sdkOnly().getPathsList().getPathList()) {
          platformClasspath.add(new File(s));
        }

        if (myLanguageLevel != null && myLanguageLevel.isPreview()) {
          options.add(JavaParameters.JAVA_ENABLE_PREVIEW_PROPERTY);
        }
      }
      JavaBuilder.addAnnotationProcessingOptions(options, profile);

      Pair<Sdk, JavaSdkVersion> runtime = BuildManager.getJavacRuntimeSdk(myProject);
      JavaSdkVersion buildRuntimeVersion = runtime.getSecond();
      // if compiler or debuggee version or both are unknown, let source and target be the compiler's defaults
      if (buildRuntimeVersion != null && debuggeeVersion != null) {
        JavaSdkVersion minVersion = debuggeeVersion.compareTo(buildRuntimeVersion) < 0 ? debuggeeVersion : buildRuntimeVersion;
        String sourceOption = JpsJavaSdkType.complianceOption(minVersion.getMaxLanguageLevel().toJavaVersion());
        options.add("-source");
        options.add(sourceOption);
        options.add("-target");
        options.add(sourceOption);
      }

      CompilerManager compilerManager = CompilerManager.getInstance(myProject);

      File sourceFile = null;
      try {
        sourceFile = generateTempSourceFile(compilerManager.getJavacCompilerWorkingDir());
        File srcDir = sourceFile.getParentFile();
        List<File> sourcePath = Collections.emptyList();
        Set<File> sources = Collections.singleton(sourceFile);

        myCompiledClasses =
          compilerManager.compileJavaCode(options, platformClasspath, classpath, Collections.emptyList(), Collections.emptyList(), sourcePath, sources, srcDir);
      }
      catch (CompilationException e) {
        StringBuilder res = new StringBuilder("Compilation failed:\n");
        for (CompilationException.Message m : e.getMessages()) {
          if (m.getCategory() == CompilerMessageCategory.ERROR) {
            res.append(m.getText()).append("\n");
          }
        }
        throw new EvaluateException(res.toString());
      }
      catch (Exception e) {
        throw new EvaluateException(e.getMessage());
      }
      finally {
        if (sourceFile != null) {
          FileUtil.delete(sourceFile);
        }
      }
    }
    return myCompiledClasses;
  }

  private File generateTempSourceFile(File workingDir) throws IOException {
    Pair<String, String> fileData = ReadAction.compute(() -> {
      PsiFile file = myData.getGeneratedInnerClass().getContainingFile();
      return Pair.create(file.getName(), file.getText());
    });
    if (fileData.first == null) {
      throw new IOException("Class file name not specified");
    }
    if (fileData.second == null) {
      throw new IOException("Class source code not specified");
    }
    File file = new File(workingDir, "debugger/src/" + fileData.first);
    FileUtil.writeToFile(file, fileData.second);
    return file;
  }

  @Nullable
  public static ExpressionEvaluator create(@NotNull Project project,
                                           @Nullable PsiElement psiContext,
                                           @NotNull Function<? super PsiElement, ? extends PsiCodeFragment> fragmentFactory)
    throws EvaluateException {
    if (Registry.is("debugger.compiling.evaluator") && psiContext != null) {
      return ReadAction.compute(() -> {
        try {
          XDebugSession currentSession = XDebuggerManager.getInstance(project).getCurrentSession();
          JavaSdkVersion javaVersion = getJavaVersion(currentSession);
          PsiElement physicalContext = findPhysicalContext(psiContext);
          LightMethodObjectExtractedData data = ExtractLightMethodObjectHandler.extractLightMethodObject(
            project,
            physicalContext != null ? physicalContext : psiContext,
            fragmentFactory.apply(psiContext),
            getGeneratedClassName(),
            javaVersion);
          if (data != null) {
            return new CompilingEvaluatorImpl(project, psiContext, data);
          }
        }
        catch (PrepareFailedException e) {
          NodeDescriptorImpl.LOG.info(e);
        }
        return null;
      });
    }
    return null;
  }

  @Nullable
  private static PsiElement findPhysicalContext(@NotNull PsiElement element) {
    while (element != null && !element.isPhysical()) {
      element = element.getContext();
    }
    return element;
  }

  @Nullable
  public static JavaSdkVersion getJavaVersion(@Nullable XDebugSession session) {
    if (session != null) {
      XSuspendContext suspendContext = session.getSuspendContext();
      if (suspendContext instanceof SuspendContextImpl) {
        DebugProcessImpl debugProcess = ((SuspendContextImpl)suspendContext).getDebugProcess();
        return JavaSdkVersion.fromVersionString(debugProcess.getVirtualMachineProxy().version());
      }
    }

    return null;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

/*
 * Class DebuggerTree
 * @author Jeka
 */
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.DebuggerInvocationUtil;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.SuspendContextImpl;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.events.DebuggerCommandImpl;
import com.intellij.debugger.engine.events.DebuggerContextCommandImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.PrioritizedTask;
import com.intellij.debugger.jdi.StackFrameProxyImpl;
import com.intellij.debugger.jdi.ThreadGroupReferenceProxyImpl;
import com.intellij.debugger.jdi.ThreadReferenceProxyImpl;
import com.intellij.debugger.settings.ThreadsViewSettings;
import com.intellij.debugger.ui.impl.DebuggerTreeRenderer;
import com.intellij.debugger.ui.impl.tree.TreeBuilder;
import com.intellij.debugger.ui.impl.tree.TreeBuilderNode;
import com.intellij.ide.dnd.aware.DnDAwareTree;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.actionSystem.DataKey;
import com.intellij.openapi.actionSystem.DataProvider;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.NlsContexts;
import com.intellij.ui.SpeedSearchComparator;
import com.intellij.ui.TreeSpeedSearch;
import com.intellij.util.ui.tree.TreeUtil;
import com.sun.jdi.ThreadReference;
import org.jetbrains.annotations.NotNull;

import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;

public abstract class DebuggerTree extends DnDAwareTree implements DataProvider, Disposable {
  private static final Logger LOG = Logger.getInstance(DebuggerTree.class);
  protected static final Key<Rectangle> VISIBLE_RECT = Key.create("VISIBLE_RECT");

  public static final DataKey<DebuggerTree> DATA_KEY = DataKey.create("DebuggerTree");

  protected final NodeManagerImpl myNodeManager;

  private DebuggerContextImpl myDebuggerContext = DebuggerContextImpl.EMPTY_CONTEXT;

  private DebuggerTreeNodeImpl myEditedNode;
  private final Project myProject;

  public DebuggerTree(Project project) {
    super((TreeModel)null);

    myProject = project;
    setRootVisible(false);
    setShowsRootHandles(true);
    setCellRenderer(new DebuggerTreeRenderer());
    updateUI();
    TreeUtil.installActions(this);

    setScrollsOnExpand(false);
    myNodeManager = createNodeManager(project);

    final TreeBuilder model = new TreeBuilder(this) {
      @Override
      public void buildChildren(TreeBuilderNode node) {
        final DebuggerTreeNodeImpl debuggerTreeNode = (DebuggerTreeNodeImpl)node;
        if (debuggerTreeNode.getDescriptor() instanceof DefaultNodeDescriptor) {
          return;
        }
        buildNode(debuggerTreeNode);
      }

      @Override
      public boolean isExpandable(TreeBuilderNode builderNode) {
        return DebuggerTree.this.isExpandable((DebuggerTreeNodeImpl)builderNode);
      }
    };
    model.setRoot(getNodeFactory().getDefaultNode());

    setModel(model);

    final TreeSpeedSearch search = TreeSpeedSearch.installOn(this);
    search.setComparator(new SpeedSearchComparator(false));
  }

  protected NodeManagerImpl createNodeManager(Project project) {
    return new NodeManagerImpl(project, this);
  }

  public Project getProject() {
    return myProject;
  }

  @Override
  public void dispose() {
    myNodeManager.dispose();
    myDebuggerContext = DebuggerContextImpl.EMPTY_CONTEXT;
  }

  protected boolean isExpandable(DebuggerTreeNodeImpl node) {
    NodeDescriptorImpl descriptor = node.getDescriptor();
    return descriptor.isExpandable();
  }

  @Override
  public Object getData(@NotNull String dataId) {
    if (DATA_KEY.is(dataId)) {
      return this;
    }
    return null;
  }


  private void buildNode(final DebuggerTreeNodeImpl node) {
    if (node == null || node.getDescriptor() == null) {
      return;
    }
    final DebugProcessImpl debugProcess = getDebuggerContext().getDebugProcess();
    if (debugProcess != null) {
      DebuggerCommandImpl command = getBuildNodeCommand(node);
      if (command != null) {
        node.add(myNodeManager.createMessageNode(MessageDescriptor.EVALUATING));
        debugProcess.getManagerThread().schedule(command);
      }
    }
  }

  // todo: convert "if" into instance method call
  protected DebuggerCommandImpl getBuildNodeCommand(final DebuggerTreeNodeImpl node) {
    if (node.getDescriptor() instanceof ThreadDescriptorImpl) {
      return new BuildThreadCommand(node);
    }
    else if (node.getDescriptor() instanceof ThreadGroupDescriptorImpl) {
      return new BuildThreadGroupCommand(node);
    }
    LOG.assertTrue(false);
    return null;
  }

  public void saveState(DebuggerTreeNodeImpl node) {
    if (node.getDescriptor() != null) {
      TreePath path = new TreePath(node.getPath());
      node.getDescriptor().myIsExpanded = isExpanded(path);
      node.getDescriptor().myIsSelected = getSelectionModel().isPathSelected(path);
      Rectangle rowBounds = getRowBounds(getRowForPath(path));
      if (rowBounds != null && getVisibleRect().contains(rowBounds)) {
        node.getDescriptor().putUserData(VISIBLE_RECT, getVisibleRect());
        node.getDescriptor().myIsVisible = true;
      }
      else {
        node.getDescriptor().putUserData(VISIBLE_RECT, null);
        node.getDescriptor().myIsVisible = false;
      }
    }

    for (Enumeration e = node.rawChildren(); e.hasMoreElements(); ) {
      DebuggerTreeNodeImpl child = (DebuggerTreeNodeImpl)e.nextElement();
      saveState(child);
    }
  }

  public void restoreState(DebuggerTreeNodeImpl node) {
    restoreStateImpl(node);
    scrollToVisible(node);
  }

  protected final void scrollToVisible(DebuggerTreeNodeImpl scopeNode) {
    final TreePath rootPath = new TreePath(scopeNode.getPath());
    final int rowCount = getRowCount();
    for (int idx = rowCount - 1; idx >= 0; idx--) {
      final TreePath treePath = getPathForRow(idx);
      if (treePath != null) {
        if (!rootPath.isDescendant(treePath)) {
          continue;
        }
        final DebuggerTreeNodeImpl pathNode = (DebuggerTreeNodeImpl)treePath.getLastPathComponent();
        final NodeDescriptorImpl descriptor = pathNode.getDescriptor();

        if (descriptor != null && descriptor.myIsVisible) {
          final Rectangle visibleRect = descriptor.getUserData(VISIBLE_RECT);
          if (visibleRect != null) {
            // prefer visible rect
            scrollRectToVisible(visibleRect);
          }
          else {
            scrollPathToVisible(treePath);
          }
          break;
        }
      }
    }
  }

  @Override
  public void scrollRectToVisible(Rectangle aRect) {
    // see IDEADEV-432
    aRect.width += aRect.x;
    aRect.x = 0;
    super.scrollRectToVisible(aRect);
  }

  private void restoreStateImpl(DebuggerTreeNodeImpl node) {
    restoreNodeState(node);
    if (node.getDescriptor().myIsExpanded) {
      for (Enumeration e = node.rawChildren(); e.hasMoreElements(); ) {
        DebuggerTreeNodeImpl child = (DebuggerTreeNodeImpl)e.nextElement();
        restoreStateImpl(child);
      }
    }
  }

  public void restoreState() {
    clearSelection();
    DebuggerTreeNodeImpl root = (DebuggerTreeNodeImpl)getModel().getRoot();
    if (root != null) {
      restoreState(root);
    }
  }

  protected void restoreNodeState(DebuggerTreeNodeImpl node) {
    final NodeDescriptorImpl descriptor = node.getDescriptor();
    if (descriptor != null) {
      if (node.getParent() == null) {
        descriptor.myIsExpanded = true;
      }

      TreePath path = new TreePath(node.getPath());
      if (descriptor.myIsExpanded) {
        expandPath(path);
      }
      if (descriptor.myIsSelected) {
        addSelectionPath(path);
      }
    }
  }

  public NodeManagerImpl getNodeFactory() {
    return myNodeManager;
  }

  public TreeBuilder getMutableModel() {
    return (TreeBuilder)getModel();
  }

  public void removeAllChildren() {
    DebuggerTreeNodeImpl root = (DebuggerTreeNodeImpl)getModel().getRoot();
    root.removeAllChildren();
    treeChanged();
  }

  public void showMessage(MessageDescriptor messageDesc) {
    DebuggerTreeNodeImpl root = getNodeFactory().getDefaultNode();
    getMutableModel().setRoot(root);
    DebuggerTreeNodeImpl message = root.add(messageDesc);
    treeChanged();
    expandPath(new TreePath(message.getPath()));
  }

  public void showMessage(@NlsContexts.Label String messageText) {
    showMessage(new MessageDescriptor(messageText));
  }

  public final void treeChanged() {
    DebuggerTreeNodeImpl node = (DebuggerTreeNodeImpl)getModel().getRoot();
    if (node != null) {
      getMutableModel().nodeStructureChanged(node);
      restoreState();
    }
  }

  protected abstract void build(DebuggerContextImpl context);

  public void rebuild(final DebuggerContextImpl context) {
    ApplicationManager.getApplication().assertIsDispatchThread();
    final DebugProcessImpl process = context.getDebugProcess();
    if (process == null) {
      return; // empty context, no process available yet
    }
    myDebuggerContext = context;
    saveState();
    process.getManagerThread().schedule(PrioritizedTask.Priority.NORMAL, () -> getNodeFactory().setHistoryByContext(context));
    build(context);
  }

  public void saveState() {
    saveState((DebuggerTreeNodeImpl)getModel().getRoot());
  }

  public void onEditorShown(DebuggerTreeNodeImpl node) {
    myEditedNode = node;
  }

  public void onEditorHidden(DebuggerTreeNodeImpl node) {
    if (myEditedNode != null) {
      assert myEditedNode == node;
      myEditedNode = null;
    }
  }

  public DebuggerContextImpl getDebuggerContext() {
    return myDebuggerContext;
  }

  public abstract class BuildNodeCommand extends DebuggerContextCommandImpl {
    protected final DebuggerTreeNodeImpl myNode;

    protected final List<DebuggerTreeNodeImpl> myChildren = new LinkedList<>();

    protected BuildNodeCommand(DebuggerTreeNodeImpl node, ThreadReferenceProxyImpl thread) {
      super(DebuggerTree.this.getDebuggerContext(), thread);
      myNode = node;
    }

    @Override
    public Priority getPriority() {
      return Priority.NORMAL;
    }

    protected void updateUI(final boolean scrollToVisible) {
      DebuggerInvocationUtil.swingInvokeLater(getProject(), () -> {
        myNode.removeAllChildren();
        for (DebuggerTreeNodeImpl debuggerTreeNode : myChildren) {
          myNode.add(debuggerTreeNode);
        }
        myNode.childrenChanged(scrollToVisible);
      });
    }
  }

  private class BuildThreadCommand extends BuildNodeCommand {
    BuildThreadCommand(DebuggerTreeNodeImpl threadNode) {
      super(threadNode, ((ThreadDescriptorImpl)threadNode.getDescriptor()).getThreadReference());
    }

    @Override
    public void threadAction(@NotNull SuspendContextImpl suspendContext) {
      ThreadDescriptorImpl threadDescriptor = ((ThreadDescriptorImpl)myNode.getDescriptor());
      ThreadReferenceProxyImpl threadProxy = threadDescriptor.getThreadReference();
      if (!threadProxy.isCollected() && getDebuggerContext().getDebugProcess().getSuspendManager().isSuspended(threadProxy)) {
        int status = threadProxy.status();
        if (!(status == ThreadReference.THREAD_STATUS_UNKNOWN) &&
            !(status == ThreadReference.THREAD_STATUS_NOT_STARTED) &&
            !(status == ThreadReference.THREAD_STATUS_ZOMBIE)) {
          try {
            for (StackFrameProxyImpl stackFrame : threadProxy.frames()) {
              //Method method = stackFrame.location().method();
              //ToDo :check whether is synthetic if (shouldDisplay(method)) {
              myChildren.add(myNodeManager.createNode(myNodeManager.getStackFrameDescriptor(threadDescriptor, stackFrame),
                                                      getDebuggerContext().createEvaluationContext()));
            }
          }
          catch (EvaluateException e) {
            myChildren.clear();
            myChildren.add(myNodeManager.createMessageNode(e.getMessage()));
            LOG.debug(e);
            //LOG.assertTrue(false);
            // if we pause during evaluation of this method the exception is thrown
            //  private static void longMethod() {
            //    try {
            //      Thread.sleep(100000);
            //    } catch (InterruptedException e) {
            //      e.printStackTrace();
            //    }
            //  }
          }
        }
      }
      updateUI(true);
    }
  }

  private class BuildThreadGroupCommand extends DebuggerCommandImpl {
    private final DebuggerTreeNodeImpl myNode;
    protected final List<DebuggerTreeNodeImpl> myChildren = new LinkedList<>();

    BuildThreadGroupCommand(DebuggerTreeNodeImpl node) {
      myNode = node;
    }

    @Override
    protected void action() {
      ThreadGroupDescriptorImpl groupDescriptor = (ThreadGroupDescriptorImpl)myNode.getDescriptor();
      ThreadGroupReferenceProxyImpl threadGroup = groupDescriptor.getThreadGroupReference();

      List<ThreadReferenceProxyImpl> threads = new ArrayList<>(threadGroup.threads());
      threads.sort(ThreadReferenceProxyImpl.ourComparator);

      final DebuggerContextImpl debuggerContext = getDebuggerContext();
      final SuspendContextImpl suspendContext = debuggerContext.getSuspendContext();
      final EvaluationContextImpl evaluationContext = suspendContext != null && !suspendContext.isResumed() ? debuggerContext.createEvaluationContext() : null;

      boolean showCurrent = ThreadsViewSettings.getInstance().SHOW_CURRENT_THREAD;

      for (final ThreadGroupReferenceProxyImpl group : threadGroup.threadGroups()) {
        if (group != null) {
          DebuggerTreeNodeImpl threadNode =
            myNodeManager.createNode(myNodeManager.getThreadGroupDescriptor(groupDescriptor, group), evaluationContext);

          if (showCurrent && ((ThreadGroupDescriptorImpl)threadNode.getDescriptor()).isCurrent()) {
            myChildren.add(0, threadNode);
          }
          else {
            myChildren.add(threadNode);
          }
        }
      }

      ArrayList<DebuggerTreeNodeImpl> threadNodes = new ArrayList<>();

      for (ThreadReferenceProxyImpl thread : threads) {
        if (thread != null) {
          final DebuggerTreeNodeImpl threadNode = myNodeManager.createNode(myNodeManager.getThreadDescriptor(groupDescriptor, thread), evaluationContext);
          if (showCurrent && ((ThreadDescriptorImpl)threadNode.getDescriptor()).isCurrent()) {
            threadNodes.add(0, threadNode);
          }
          else {
            threadNodes.add(threadNode);
          }
        }
      }

      myChildren.addAll(threadNodes);

      updateUI(true);
    }

    protected void updateUI(final boolean scrollToVisible) {
      DebuggerInvocationUtil.swingInvokeLater(getProject(), () -> {
        myNode.removeAllChildren();
        for (DebuggerTreeNodeImpl debuggerTreeNode : myChildren) {
          myNode.add(debuggerTreeNode);
        }
        myNode.childrenChanged(scrollToVisible);
      });
    }
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.codeInsight.ChangeContextUtil;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.codeinsight.RuntimeTypeEvaluator;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Key;
import com.intellij.psi.*;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.psi.util.PsiUtil;
import com.intellij.util.IncorrectOperationException;
import com.sun.jdi.ObjectReference;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.Value;
import org.jetbrains.annotations.Nullable;

import java.util.HashSet;
import java.util.Set;

public final class DebuggerTreeNodeExpression {
  @Nullable
  public static PsiExpression substituteThis(@Nullable PsiElement expressionWithThis, PsiExpression howToEvaluateThis, Value howToEvaluateThisValue)
    throws EvaluateException {
    if (!(expressionWithThis instanceof PsiExpression)) return null;
    PsiExpression result = (PsiExpression)expressionWithThis.copy();

    PsiClass thisClass = PsiTreeUtil.getContextOfType(result, PsiClass.class, true);

    boolean castNeeded = true;

    if (thisClass != null) {
      PsiType type = howToEvaluateThis.getType();
      if (type != null) {
        if (type instanceof PsiClassType) {
          PsiClass psiClass = ((PsiClassType)type).resolve();
          if (psiClass != null && (psiClass == thisClass || psiClass.isInheritor(thisClass, true))) {
            castNeeded = false;
          }
        }
        else if (type instanceof PsiArrayType && PsiUtil.isArrayClass(thisClass)) {
          castNeeded = false;
        }
      }
    }

    if (castNeeded) {
      howToEvaluateThis = castToRuntimeType(howToEvaluateThis, howToEvaluateThisValue);
    }

    ChangeContextUtil.encodeContextInfo(result, false);
    PsiExpression psiExpression;
    try {
      psiExpression = (PsiExpression)ChangeContextUtil.decodeContextInfo(result, thisClass, howToEvaluateThis);
    }
    catch (IncorrectOperationException e) {
      throw new EvaluateException(
        JavaDebuggerBundle.message("evaluation.error.invalid.this.expression", result.getText(), howToEvaluateThis.getText()), null);
    }

    try {
      PsiExpression res = JavaPsiFacade.getElementFactory(howToEvaluateThis.getProject())
        .createExpressionFromText(psiExpression.getText(), howToEvaluateThis.getContext());
      res.putUserData(ADDITIONAL_IMPORTS_KEY, howToEvaluateThis.getUserData(ADDITIONAL_IMPORTS_KEY));
      return res;
    }
    catch (IncorrectOperationException e) {
      throw new EvaluateException(e.getMessage(), e);
    }
  }

  public static final Key<Set<String>> ADDITIONAL_IMPORTS_KEY = Key.create("ADDITIONAL_IMPORTS");

  public static PsiExpression castToRuntimeType(PsiExpression expression, Value value) throws EvaluateException {
    if (!(value instanceof ObjectReference)) {
      return expression;
    }

    ReferenceType valueType = ((ObjectReference)value).referenceType();
    if (valueType == null) {
      return expression;
    }

    Project project = expression.getProject();

    PsiType type = RuntimeTypeEvaluator.getCastableRuntimeType(project, value);
    if (type == null) {
      return expression;
    }

    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);
    String typeName = type.getCanonicalText();
    try {
      PsiParenthesizedExpression parenthExpression = (PsiParenthesizedExpression)elementFactory.createExpressionFromText(
        "((" + typeName + ")expression)", null);
      //noinspection ConstantConditions
      ((PsiTypeCastExpression)parenthExpression.getExpression()).getOperand().replace(expression);
      Set<String> imports = expression.getUserData(ADDITIONAL_IMPORTS_KEY);
      if (imports == null) {
        imports = new HashSet<>();
      }
      imports.add(typeName);
      parenthExpression.putUserData(ADDITIONAL_IMPORTS_KEY, imports);
      return parenthExpression;
    }
    catch (IncorrectOperationException e) {
      throw new EvaluateException(JavaDebuggerBundle.message("error.invalid.type.name", typeName), e);
    }
  }

  /**
   * @param qualifiedName the class qualified name to be resolved against the current execution context
   * @return short name if the class could be resolved using short name,
   * otherwise returns qualifiedName
   */
  public static String normalize(final String qualifiedName, PsiElement contextElement, Project project) {
    if (contextElement == null) {
      return qualifiedName;
    }

    final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);
    PsiClass aClass = facade.findClass(qualifiedName, GlobalSearchScope.allScope(project));
    if (aClass != null) {
      return normalizePsiClass(aClass, contextElement, facade.getResolveHelper());
    }
    return qualifiedName;
  }

  private static String normalizePsiClass(PsiClass psiClass, PsiElement contextElement, PsiResolveHelper helper) {
    String name = psiClass.getName();
    PsiClass aClass = helper.resolveReferencedClass(name, contextElement);
    if (psiClass.equals(aClass)) {
      return name;
    }
    PsiClass parentClass = psiClass.getContainingClass();
    if (parentClass != null) {
      return normalizePsiClass(parentClass, contextElement, helper) + "." + name;
    }
    return psiClass.getQualifiedName();
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

/*
 * Class DebuggerTreeNodeImpl
 * @author Jeka
 */
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.engine.SuspendContextImpl;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.events.DebuggerContextCommandImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.ui.impl.DebuggerTreeRenderer;
import com.intellij.debugger.ui.impl.tree.TreeBuilder;
import com.intellij.debugger.ui.impl.tree.TreeBuilderNode;
import com.intellij.debugger.ui.tree.DebuggerTreeNode;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.render.DescriptorLabelListener;
import com.intellij.debugger.ui.tree.render.NodeRenderer;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Key;
import com.intellij.ui.SimpleColoredText;
import com.intellij.xdebugger.impl.ui.DebuggerUIUtil;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.tree.MutableTreeNode;
import java.util.HashMap;
import java.util.Map;

public class DebuggerTreeNodeImpl extends TreeBuilderNode implements DebuggerTreeNode, NodeDescriptorProvider, MutableTreeNode {
  private Icon myIcon;
  private SimpleColoredText myText;
  private final DebuggerTree myTree;
  private final Map myProperties = new HashMap();

  public DebuggerTreeNodeImpl(DebuggerTree tree, NodeDescriptor descriptor) {
    super(descriptor);
    myTree = tree;
  }

  @Override
  public DebuggerTreeNodeImpl getParent() {
    return (DebuggerTreeNodeImpl)super.getParent();
  }

  @Override
  protected TreeBuilder getTreeBuilder() {
    return myTree.getMutableModel();
  }

  public DebuggerTree getTree() {
    return myTree;
  }

  public String toString() {
    return myText != null ? myText.toString() : "";
  }

  @Override
  public NodeDescriptorImpl getDescriptor() {
    return (NodeDescriptorImpl)getUserObject();
  }

  @Override
  public Project getProject() {
    return getTree().getProject();
  }

  @Override
  public void setRenderer(NodeRenderer renderer) {
    ((ValueDescriptorImpl)getDescriptor()).setRenderer(renderer);
    calcRepresentation();
  }

  private void updateCaches() {
    final NodeDescriptorImpl descriptor = getDescriptor();
    myIcon = DebuggerTreeRenderer.getDescriptorIcon(descriptor);
    final DebuggerContextImpl context = getTree().getDebuggerContext();
    myText = DebuggerTreeRenderer.getDescriptorText(context, descriptor, DebuggerUIUtil.getColorScheme(myTree), false);
  }

  public Icon getIcon() {
    return myIcon;
  }

  public SimpleColoredText getText() {
    return myText;
  }

  @Override
  public void clear() {
    removeAllChildren();
    myIcon = null;
    myText = null;
    super.clear();
  }

  private void update(final DebuggerContextImpl context, final Runnable runnable, boolean labelOnly) {
    if (!labelOnly) {
      clear();
    }

    if (context != null && context.getDebugProcess() != null) {
      getTree().saveState(this);

      myIcon = DebuggerTreeRenderer.getDescriptorIcon(MessageDescriptor.EVALUATING);
      myText = DebuggerTreeRenderer.getDescriptorText(context, MessageDescriptor.EVALUATING, false);

      context.getDebugProcess().getManagerThread().invoke(new DebuggerContextCommandImpl(context) {
        @Override
        public void threadAction(@NotNull SuspendContextImpl suspendContext) {
          runnable.run();
        }

        @Override
        protected void commandCancelled() {
          clear();
          getDescriptor().clear();
          updateCaches();

          labelChanged();
          childrenChanged(true);
        }

        @Override
        public Priority getPriority() {
          return Priority.NORMAL;
        }
      });
    }

    labelChanged();
    if (!labelOnly) {
      childrenChanged(true);
    }
  }

  public void calcLabel() {
    final DebuggerContextImpl context = getTree().getDebuggerContext();
    update(context, () -> getDescriptor().updateRepresentation(context.createEvaluationContext(), new DescriptorLabelListener() {
      @Override
      public void labelChanged() {
        updateCaches();
        DebuggerTreeNodeImpl.this.labelChanged();
      }
    }), true);
  }

  public void calcRepresentation() {
    final DebuggerContextImpl context = getTree().getDebuggerContext();
    update(context, () -> getDescriptor().updateRepresentation(context.createEvaluationContext(), new DescriptorLabelListener() {
      @Override
      public void labelChanged() {
        updateCaches();
        DebuggerTreeNodeImpl.this.labelChanged();
      }
    }), false);
  }

  public void calcValue() {
    final DebuggerContextImpl context = getTree().getDebuggerContext();
    update(
      context,
      () -> {
        EvaluationContextImpl evaluationContext = context.createEvaluationContext();
        getDescriptor().setContext(evaluationContext);
        getDescriptor().updateRepresentation(evaluationContext, new DescriptorLabelListener() {
          @Override
          public void labelChanged() {
            updateCaches();
            DebuggerTreeNodeImpl.this.labelChanged();
          }
        });
        childrenChanged(true);
      }, false);
  }

  private static void invoke(Runnable r) {
    if (ApplicationManager.getApplication().isDispatchThread()) {
      r.run();
    }
    else {
      SwingUtilities.invokeLater(r);
    }
  }

  public void labelChanged() {
    invoke(() -> {
      updateCaches();
      getTree().getMutableModel().nodeChanged(this);
    });
  }

  public void childrenChanged(final boolean scrollToVisible) {
    invoke(() -> {
      getTree().getMutableModel().nodeStructureChanged(this);
      getTree().restoreState(this);
    });
  }

  public DebuggerTreeNodeImpl add(MessageDescriptor message) {
    DebuggerTreeNodeImpl node = getNodeFactory().createMessageNode(message);
    add(node);
    return node;
  }

  public NodeManagerImpl getNodeFactory() {
    return myTree.getNodeFactory();
  }

  public Object getProperty(Key key) {
    return myProperties.get(key);
  }

  public void putProperty(Key key, Object data) {
    myProperties.put(key, data);
  }

  @NotNull
  public static DebuggerTreeNodeImpl createNodeNoUpdate(DebuggerTree tree, NodeDescriptor descriptor) {
    DebuggerTreeNodeImpl node = new DebuggerTreeNodeImpl(tree, descriptor);
    node.updateCaches();
    return node;
  }

  @NotNull
  protected static DebuggerTreeNodeImpl createNode(DebuggerTree tree, NodeDescriptorImpl descriptor, EvaluationContextImpl evaluationContext) {
    final DebuggerTreeNodeImpl node = new DebuggerTreeNodeImpl(tree, descriptor);
    descriptor.updateRepresentationNoNotify(evaluationContext, new DescriptorLabelListener() {
      @Override
      public void labelChanged() {
        node.updateCaches();
        node.labelChanged();
      }
    });
    node.updateCaches();
    return node;
  }
}
/*
 * Copyright 2000-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * @author Eugene Zhuravlev
 */
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.ui.tree.render.DescriptorLabelListener;
import com.intellij.openapi.diagnostic.Logger;


public final class DefaultNodeDescriptor extends NodeDescriptorImpl {
  private static final Logger LOG = Logger.getInstance(DefaultNodeDescriptor.class);

  public boolean equals(Object obj) {
    return obj instanceof DefaultNodeDescriptor;
  }

  public int hashCode() {
    return 0;
  }

  @Override
  public boolean isExpandable() {
    return true;
  }

  @Override
  public void setContext(EvaluationContextImpl context) {
  }

  @Override
  protected String calcRepresentation(EvaluationContextImpl context, DescriptorLabelListener labelListener) {
    LOG.assertTrue(false);
    return null;
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.openapi.util.Pair;
import com.intellij.util.containers.ContainerUtil;
import one.util.streamex.StreamEx;

import java.util.*;

import static com.intellij.util.containers.ContainerUtil.iterateBackward;

public class DescriptorTree {
  private final HashMap<NodeDescriptor, List<NodeDescriptor>> myChildrenMap = new HashMap<>();
  private final List<NodeDescriptor> myRootChildren = new ArrayList<>();
  private final boolean myInitial;
  private int myFrameCount = -1;
  private int myFrameIndex = -1;

  public DescriptorTree() {
    this(false);
  }

  public DescriptorTree(boolean isInitial) {
    myInitial = isInitial;
  }

  public void clear() {
    myChildrenMap.clear();
    myRootChildren.clear();
  }

  public boolean frameIdEquals(final int frameCount, final int frameIndex) {
    return myFrameCount == frameCount && myFrameIndex == frameIndex;
  }

  public void setFrameId(final int frameCount, final int frameIndex) {
    myFrameIndex = frameIndex;
    myFrameCount = frameCount;
  }

  public void addChild(NodeDescriptor parent, NodeDescriptor child) {
    List<NodeDescriptor> children;

    if (parent == null) {
      children = myRootChildren;
    }
    else {
      children = myChildrenMap.computeIfAbsent(parent, c -> new ArrayList<>());
    }
    children.add(child);
    if (myInitial && child instanceof LocalVariableDescriptorImpl) {
      ((LocalVariableDescriptorImpl)child).setNewLocal(false);
    }
  }

  public List<NodeDescriptor> getChildren(NodeDescriptor parent) {
    if (parent == null) {
      return myRootChildren;
    }

    List<NodeDescriptor> children = myChildrenMap.get(parent);
    return children != null ? children : Collections.emptyList();
  }

  public void dfst(DFSTWalker walker) {
    ArrayDeque<Pair<NodeDescriptor, NodeDescriptor>> stack =
      StreamEx.of(myRootChildren).map(e -> new Pair<NodeDescriptor, NodeDescriptor>(null, e)).toCollection(ArrayDeque::new);
    while (!stack.isEmpty()) {
      Pair<NodeDescriptor, NodeDescriptor> nodeInfo = stack.pop();
      NodeDescriptor child = nodeInfo.second;
      walker.visit(nodeInfo.first, child);
      List<NodeDescriptor> list = myChildrenMap.get(child);
      if (list != null) {
        iterateBackward(ContainerUtil.map(list, e -> new Pair<>(child, e))).forEach(stack::push);
      }
    }
  }

  public interface DFSTWalker {
    void visit(NodeDescriptor parent, NodeDescriptor child);
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.ContextUtil;
import com.intellij.debugger.engine.JavaValue;
import com.intellij.debugger.engine.JavaValueModifier;
import com.intellij.debugger.engine.StackFrameContext;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.evaluation.TextWithImports;
import com.intellij.debugger.engine.evaluation.expression.ExpressionEvaluator;
import com.intellij.debugger.engine.evaluation.expression.Modifier;
import com.intellij.debugger.engine.evaluation.expression.UnsupportedExpressionException;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.jdi.StackFrameProxyImpl;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.project.IndexNotReadyException;
import com.intellij.openapi.project.Project;
import com.intellij.psi.*;
import com.intellij.xdebugger.XExpression;
import com.intellij.xdebugger.frame.XValueModifier;
import com.sun.jdi.*;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public abstract class EvaluationDescriptor extends ValueDescriptorImpl {
  private Modifier myModifier;
  protected TextWithImports myText;

  protected EvaluationDescriptor(TextWithImports text, Project project, Value value) {
    super(project, value);
    myText = text;
  }

  protected EvaluationDescriptor(TextWithImports text, Project project) {
    super(project);
    setLvalue(false);
    myText = text;
  }

  protected abstract EvaluationContextImpl getEvaluationContext(EvaluationContextImpl evaluationContext);

  protected abstract PsiCodeFragment getEvaluationCode(StackFrameContext context) throws EvaluateException;

  public PsiCodeFragment createCodeFragment(PsiElement context) {
    TextWithImports text = getEvaluationText();
    return DebuggerUtilsEx.findAppropriateCodeFragmentFactory(text, context).createCodeFragment(text, context, myProject);
  }

  @ApiStatus.Experimental
  protected @NotNull ExpressionEvaluator getEvaluator(EvaluationContextImpl evaluationContext) throws EvaluateException {
    SourcePosition position = ContextUtil.getSourcePosition(evaluationContext);
    return ReadAction.compute(() -> {
      PsiCodeFragment code = getEvaluationCode(evaluationContext);
      PsiElement psiContext = ContextUtil.getContextElement(evaluationContext, position);
      try {
        return DebuggerUtilsEx.findAppropriateCodeFragmentFactory(getEvaluationText(), psiContext).getEvaluatorBuilder().build(code, position);
      }
      catch (UnsupportedExpressionException ex) {
        ExpressionEvaluator eval = CompilingEvaluatorImpl.create(myProject, code.getContext(), element -> code);
        if (eval != null) {
          return eval;
        }
        throw ex;
      }
    });
  }

  @Override
  public final Value calcValue(EvaluationContextImpl evaluationContext) throws EvaluateException {
    try {
      PsiDocumentManager.getInstance(myProject).commitAndRunReadAction(() -> {});

      EvaluationContextImpl thisEvaluationContext = getEvaluationContext(evaluationContext);

      ExpressionEvaluator evaluator = getEvaluator(thisEvaluationContext);

      if (!thisEvaluationContext.getDebugProcess().isAttached()) {
        throw EvaluateExceptionUtil.PROCESS_EXITED;
      }
      StackFrameProxyImpl frameProxy = thisEvaluationContext.getFrameProxy();
      if (frameProxy == null) {
        throw EvaluateExceptionUtil.NULL_STACK_FRAME;
      }

      Value value = evaluator.evaluate(thisEvaluationContext);
      thisEvaluationContext.keep(value);

      myModifier = evaluator.getModifier();
      setLvalue(myModifier != null);

      return value;
    }
    catch (IndexNotReadyException ex) {
      throw new EvaluateException(JavaDebuggerBundle.message("evaluation.error.during.indexing"), ex);
    }
    catch (final EvaluateException ex) {
      throw new EvaluateException(ex.getLocalizedMessage(), ex);
    }
    catch (ObjectCollectedException ex) {
      throw EvaluateExceptionUtil.OBJECT_WAS_COLLECTED;
    }
  }

  @Override
  public PsiExpression getDescriptorEvaluation(DebuggerContext context) throws EvaluateException {
    PsiElement evaluationCode = getEvaluationCode(context);
    if (evaluationCode instanceof PsiExpressionCodeFragment) {
      return ((PsiExpressionCodeFragment)evaluationCode).getExpression();
    }
    else {
      throw new EvaluateException(JavaDebuggerBundle.message("error.cannot.create.expression.from.code.fragment"), null);
    }
  }

  @Override
  protected boolean isPrintExceptionToConsole() {
    return false;
  }

  @Nullable
  public Modifier getModifier() {
    return myModifier;
  }

  @Override
  public boolean canSetValue() {
    return super.canSetValue() && myModifier != null && myModifier.canSetValue();
  }

  public TextWithImports getEvaluationText() {
    return myText;
  }

  @Override
  public XValueModifier getModifier(JavaValue value) {
    return new JavaValueModifier(value) {
      @Override
      protected void setValueImpl(@NotNull XExpression expression, @NotNull XModificationCallback callback) {
        final EvaluationDescriptor evaluationDescriptor = EvaluationDescriptor.this;
        if (evaluationDescriptor.canSetValue()) {
          final DebuggerContextImpl debuggerContext = DebuggerManagerEx.getInstanceEx(getProject()).getContext();
          set(expression, callback, debuggerContext, new SetValueRunnable() {
            @Override
            public void setValue(EvaluationContextImpl evaluationContext, Value newValue)
              throws ClassNotLoadedException, InvalidTypeException, EvaluateException {
              //noinspection ConstantConditions
              evaluationDescriptor.getModifier().setValue(preprocessValue(evaluationContext, newValue, getLType()));
              update(debuggerContext);
            }

            @NotNull
            @Override
            public Type getLType() throws EvaluateException, ClassNotLoadedException {
              //noinspection ConstantConditions
              return evaluationDescriptor.getModifier().getExpectedType();
            }
          });
        }
      }
    };
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebuggerManagerThreadImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.JavaValue;
import com.intellij.debugger.engine.JavaValueModifier;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.PositionUtil;
import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.debugger.settings.ViewsGeneralSettings;
import com.intellij.debugger.ui.tree.FieldDescriptor;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Ref;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.CommonClassNames;
import com.intellij.psi.JavaPsiFacade;
import com.intellij.psi.PsiElementFactory;
import com.intellij.psi.PsiExpression;
import com.intellij.util.IncorrectOperationException;
import com.intellij.xdebugger.XExpression;
import com.intellij.xdebugger.frame.XValueModifier;
import com.sun.jdi.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class FieldDescriptorImpl extends ValueDescriptorImpl implements FieldDescriptor {
  public static final String OUTER_LOCAL_VAR_FIELD_PREFIX = "val$";
  private final Field myField;
  private final ObjectReference myObject;
  private Boolean myIsPrimitive = null;
  private final boolean myIsStatic;
  private Ref<Value> myPresetValue;

  public FieldDescriptorImpl(Project project, ObjectReference objRef, @NotNull Field field) {
    super(project);
    myObject = objRef;
    myField = field;
    myIsStatic = field.isStatic();
    setLvalue(!field.isFinal());
  }

  @Override
  public Field getField() {
    return myField;
  }

  @Override
  public ObjectReference getObject() {
    return myObject;
  }

  @Override
  public void setAncestor(NodeDescriptor oldDescriptor) {
    super.setAncestor(oldDescriptor);
    final Boolean isPrimitive = ((FieldDescriptorImpl)oldDescriptor).myIsPrimitive;
    if (isPrimitive != null) { // was cached
      // do not loose cached info
      myIsPrimitive = isPrimitive;
    }
  }


  @Override
  public boolean isPrimitive() {
    if (myIsPrimitive == null) {
      final Value value = getValue();
      if (value != null) {
        myIsPrimitive = super.isPrimitive();
      }
      else {
        myIsPrimitive = DebuggerUtils.isPrimitiveType(myField.typeName());
      }
    }
    return myIsPrimitive.booleanValue();
  }

  public void setValue(Value value) {
    myPresetValue = Ref.create(value);
  }

  @Override
  public Value calcValue(EvaluationContextImpl evaluationContext) throws EvaluateException {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    try {
      Value fieldValue;
      if (myPresetValue != null) {
        fieldValue = myPresetValue.get();
      }
      else if (myObject != null) {
        fieldValue = myObject.getValue(myField);
      }
      else {
        fieldValue = myField.declaringType().getValue(myField);
      }

      if (myObject != null && populateExceptionStackTraceIfNeeded(fieldValue, evaluationContext)) {
        // re-read stacktrace value
        fieldValue = myObject.getValue(myField);
      }

      return fieldValue;
    }
    catch (InternalException e) {
      if (evaluationContext.getDebugProcess().getVirtualMachineProxy().canBeModified()) { // do not care in read only vms
        LOG.debug(e);
      }
      else {
        LOG.warn(e);
      }
      throw new EvaluateException(JavaDebuggerBundle.message("internal.debugger.error"));
    }
    catch (ObjectCollectedException ignored) {
      throw EvaluateExceptionUtil.OBJECT_WAS_COLLECTED;
    }
  }

  private boolean populateExceptionStackTraceIfNeeded(Value value, EvaluationContextImpl evaluationContext) {
    if ("stackTrace".equals(getName()) &&
        ViewsGeneralSettings.getInstance().POPULATE_THROWABLE_STACKTRACE &&
        value instanceof ArrayReference &&
        ((ArrayReference)value).length() == 0 &&
        DebuggerUtils.instanceOf(myObject.type(), CommonClassNames.JAVA_LANG_THROWABLE)) {
      try {
        invokeExceptionGetStackTrace(myObject, evaluationContext);
        return true;
      }
      catch (Throwable e) {
        LOG.info(e); // catch all exceptions to ensure the method returns gracefully
      }
    }
    return false;
  }

  public boolean isStatic() {
    return myIsStatic;
  }

  @Override
  public String getName() {
    return myField.name();
  }

  @Override
  public String calcValueName() {
    String res = super.calcValueName();
    if (Boolean.TRUE.equals(getUserData(SHOW_DECLARING_TYPE))) {
      return NodeRendererSettings.getInstance().getClassRenderer().renderTypeName(myField.declaringType().name()) + "." + res;
    }
    return res;
  }

  public boolean isOuterLocalVariableValue() {
    try {
      return DebuggerUtils.isSynthetic(myField) && myField.name().startsWith(OUTER_LOCAL_VAR_FIELD_PREFIX);
    }
    catch (UnsupportedOperationException ignored) {
      return false;
    }
  }

  @Nullable
  @Override
  public String getDeclaredType() {
    return myField.typeName();
  }

  @Override
  public PsiExpression getDescriptorEvaluation(DebuggerContext context) throws EvaluateException {
    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(myProject);
    String fieldName;
    if (isStatic()) {
      String typeName = myField.declaringType().name().replace('$', '.');
      typeName = DebuggerTreeNodeExpression.normalize(typeName, PositionUtil.getContextElement(context), myProject);
      fieldName = typeName + "." + getName();
    }
    else {
      fieldName = isOuterLocalVariableValue() ? StringUtil.trimStart(getName(), OUTER_LOCAL_VAR_FIELD_PREFIX) : "this." + getName();
    }
    try {
      return elementFactory.createExpressionFromText(fieldName, null);
    }
    catch (IncorrectOperationException e) {
      throw new EvaluateException(JavaDebuggerBundle.message("error.invalid.field.name", getName()), e);
    }
  }

  @Override
  public XValueModifier getModifier(JavaValue value) {
    return new JavaValueModifier(value) {
      @Override
      protected void setValueImpl(@NotNull XExpression expression, @NotNull XModificationCallback callback) {
        final DebuggerContextImpl debuggerContext = DebuggerManagerEx.getInstanceEx(getProject()).getContext();
        Field field = getField();
        FieldValueSetter setter = null;

        if (!field.isStatic()) {
          ObjectReference object = getObject();
          if (object != null) {
            setter = v -> object.setValue(field, v);
          }
        }
        else if (field.declaringType() instanceof ClassType classType) {
          setter = v -> classType.setValue(field, v);
        }

        if (setter != null) {
          FieldValueSetter finalSetter = setter;
          set(expression, callback, debuggerContext, new SetValueRunnable() {
            @Override
            public void setValue(EvaluationContextImpl evaluationContext, Value newValue)
              throws ClassNotLoadedException, InvalidTypeException, EvaluateException {
              finalSetter.setValue(preprocessValue(evaluationContext, newValue, getLType()));
              update(debuggerContext);
            }

            @Override
            public ClassLoaderReference getClassLoader(EvaluationContextImpl evaluationContext) {
              return field.declaringType().classLoader();
            }

            @NotNull
            @Override
            public Type getLType() throws ClassNotLoadedException {
              return field.type();
            }
          });
        }
      }
    };
  }

  private interface FieldValueSetter {
    void setValue(Value value) throws InvalidTypeException, ClassNotLoadedException;
  }
}
/*
 * Copyright 2000-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.NodeDescriptorNameAdjuster;
import com.intellij.openapi.util.text.StringUtil;
import org.jetbrains.annotations.NotNull;

/**
 * @author Nikolay.Tropin
 */
public class FieldOuterLocalNameAdjuster extends NodeDescriptorNameAdjuster {

  @Override
  public boolean isApplicable(@NotNull NodeDescriptor descriptor) {
    if (descriptor instanceof FieldDescriptorImpl && NodeRendererSettings.getInstance().getClassRenderer().SHOW_VAL_FIELDS_AS_LOCAL_VARIABLES) {
      return ((FieldDescriptorImpl)descriptor).isOuterLocalVariableValue();
    }
    return false;
  }

  @Override
  public String fixName(String name, @NotNull NodeDescriptor descriptor) {
    return StringUtil.trimStart(name, FieldDescriptorImpl.OUTER_LOCAL_VAR_FIELD_PREFIX);
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.JavaValue;
import com.intellij.debugger.engine.JavaValueModifier;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.PositionUtil;
import com.intellij.debugger.jdi.LocalVariableProxyImpl;
import com.intellij.debugger.jdi.StackFrameProxyImpl;
import com.intellij.debugger.ui.tree.LocalVariableDescriptor;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.openapi.project.Project;
import com.intellij.psi.JavaPsiFacade;
import com.intellij.psi.PsiElementFactory;
import com.intellij.psi.PsiExpression;
import com.intellij.util.IncorrectOperationException;
import com.intellij.xdebugger.XExpression;
import com.intellij.xdebugger.frame.XValueModifier;
import com.sun.jdi.ClassNotLoadedException;
import com.sun.jdi.InvalidTypeException;
import com.sun.jdi.Type;
import com.sun.jdi.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class LocalVariableDescriptorImpl extends ValueDescriptorImpl implements LocalVariableDescriptor {
  private final StackFrameProxyImpl myFrameProxy;
  private final LocalVariableProxyImpl myLocalVariable;

  private String myTypeName = JavaDebuggerBundle.message("label.unknown.value");
  private boolean myIsPrimitive;
  private boolean myIsParameter;

  private boolean myIsNewLocal = true;

  public LocalVariableDescriptorImpl(Project project,
                                     @NotNull LocalVariableProxyImpl local) {
    super(project);
    setLvalue(true);
    myFrameProxy = local.getFrame();
    myLocalVariable = local;
  }

  @Override
  public LocalVariableProxyImpl getLocalVariable() {
    return myLocalVariable;
  }

  public boolean isNewLocal() {
    return myIsNewLocal;
  }

  @Override
  public boolean isPrimitive() {
    return myIsPrimitive;
  }

  @Override
  public Value calcValue(EvaluationContextImpl evaluationContext) throws EvaluateException {
    LocalVariableProxyImpl variable = getLocalVariable();
    boolean isVisible = myFrameProxy.isLocalVariableVisible(variable);
    if (isVisible) {
      final String typeName = variable.typeName();
      myTypeName = typeName;
      myIsPrimitive = DebuggerUtils.isPrimitiveType(typeName);
      myIsParameter = variable.getVariable().isArgument();
      return myFrameProxy.getValue(variable);
    }

    return null;
  }

  public void setNewLocal(boolean aNew) {
    myIsNewLocal = aNew;
  }

  @Override
  public void displayAs(NodeDescriptor descriptor) {
    super.displayAs(descriptor);
    if (descriptor instanceof LocalVariableDescriptorImpl) {
      myIsNewLocal = ((LocalVariableDescriptorImpl)descriptor).myIsNewLocal;
    }
  }

  @Override
  public String getName() {
    return myLocalVariable.name();
  }

  @Nullable
  @Override
  public String getDeclaredType() {
    return myTypeName;
  }

  @Override
  public PsiExpression getDescriptorEvaluation(DebuggerContext context) throws EvaluateException {
    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(myProject);
    try {
      return elementFactory.createExpressionFromText(getName(), PositionUtil.getContextElement(context));
    }
    catch (IncorrectOperationException e) {
      throw new EvaluateException(JavaDebuggerBundle.message("error.invalid.local.variable.name", getName()), e);
    }
  }

  @Override
  public XValueModifier getModifier(JavaValue value) {
    return new JavaValueModifier(value) {
      @Override
      protected void setValueImpl(@NotNull XExpression expression, @NotNull XModificationCallback callback) {
        final LocalVariableProxyImpl local = LocalVariableDescriptorImpl.this.getLocalVariable();
        if (local != null) {
          final DebuggerContextImpl debuggerContext = DebuggerManagerEx.getInstanceEx(getProject()).getContext();
          set(expression, callback, debuggerContext, new SetValueRunnable() {
            @Override
            public void setValue(EvaluationContextImpl evaluationContext, Value newValue) throws ClassNotLoadedException,
                                                                                                 InvalidTypeException,
                                                                                                 EvaluateException {
              debuggerContext.getFrameProxy().setValue(local, preprocessValue(evaluationContext, newValue, getLType()));
              update(debuggerContext);
            }

            @NotNull
            @Override
            public Type getLType() throws EvaluateException, ClassNotLoadedException {
              return local.getType();
            }
          });
        }
      }
    };
  }

  public boolean isParameter() {
    return myIsParameter;
  }
}
/*
 * Copyright 2000-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.impl.descriptors.data.DescriptorKey;
import com.intellij.debugger.ui.tree.NodeDescriptor;

import java.util.HashMap;
import java.util.Map;

public class MarkedDescriptorTree {
  private final HashMap<NodeDescriptor, Map<DescriptorKey<? extends NodeDescriptor>, NodeDescriptor>> myChildrenMap = new HashMap<>();
  private final Map<DescriptorKey<? extends NodeDescriptor>, NodeDescriptor> myRootChildren = new HashMap<>();

  public <T extends NodeDescriptor> void addChild(NodeDescriptor parent, T child, DescriptorKey<T> key) {
    Map<DescriptorKey<? extends NodeDescriptor>, NodeDescriptor> children;

    if (parent == null) {
      children = myRootChildren;
    }
    else {
      children = myChildrenMap.get(parent);
      if (children == null) {
        children = new HashMap<>();
        myChildrenMap.put(parent, children);
      }
    }
    children.put(key, child);
  }

  public <T extends NodeDescriptor> T getChild(NodeDescriptor parent, DescriptorKey<T> key) {
    if (parent == null) {
      return (T)myRootChildren.get(key);
    }
    final Map<DescriptorKey<? extends NodeDescriptor>, NodeDescriptor> map = myChildrenMap.get(parent);
    return (T)(map != null ? map.get(key) : null);
  }

  public void clear() {
    myChildrenMap.clear();
    myRootChildren.clear();
  }
}
/*
 * Copyright 2000-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebuggerManagerThreadImpl;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.ui.tree.render.DescriptorLabelListener;
import com.intellij.openapi.util.NlsContexts;
import com.intellij.xdebugger.XDebuggerBundle;

import java.util.function.Supplier;

public class MessageDescriptor extends NodeDescriptorImpl {
  public static final int ERROR = 0;
  public static final int WARNING = 1;
  public static final int INFORMATION = 2;
  public static final int SPECIAL = 3;
  private final int myKind;
  private final Supplier<@NlsContexts.Label String> myMessage;

  public static final MessageDescriptor DEBUG_INFO_UNAVAILABLE =
    new MessageDescriptor(JavaDebuggerBundle.messagePointer("message.node.debug.info.not.available"));
  public static final MessageDescriptor LOCAL_VARIABLES_INFO_UNAVAILABLE =
    new MessageDescriptor(JavaDebuggerBundle.messagePointer("message.node.local.variables.debug.info.not.available"));
  public static final MessageDescriptor ARRAY_IS_EMPTY =
    new MessageDescriptor(JavaDebuggerBundle.messagePointer("message.node.empty.array"));
  public static final MessageDescriptor CLASS_HAS_NO_FIELDS =
    new MessageDescriptor(JavaDebuggerBundle.messagePointer("message.node.class.has.no.fields"));
  public static final MessageDescriptor OBJECT_COLLECTED =
    new MessageDescriptor(JavaDebuggerBundle.messagePointer("message.node.object.collected"));
  public static final MessageDescriptor EVALUATING =
    new MessageDescriptor(XDebuggerBundle.messagePointer("xdebugger.building.tree.node.message"));
  public static final MessageDescriptor THREAD_IS_RUNNING =
    new MessageDescriptor(JavaDebuggerBundle.messagePointer("message.node.thread.running"));
  public static final MessageDescriptor THREAD_IS_EMPTY =
    new MessageDescriptor(JavaDebuggerBundle.messagePointer("message.node.thread.has.no.frames"));
  public static final MessageDescriptor EVALUATION_NOT_POSSIBLE =
    new MessageDescriptor(JavaDebuggerBundle.messagePointer("message.node.evaluation.not.possible", WARNING));

  public MessageDescriptor(Supplier<@NlsContexts.Label String> message) {
    this(message, INFORMATION);
  }

  public MessageDescriptor(Supplier<@NlsContexts.Label String> message, int kind) {
    myKind = kind;
    myMessage = message;
  }

  public MessageDescriptor(@NlsContexts.Label String message) {
    this(message, INFORMATION);
  }

  public MessageDescriptor(@NlsContexts.Label String message, int kind) {
    this(() -> message, kind);
  }

  public int getKind() {
    return myKind;
  }

  @Override
  public String getLabel() {
    return myMessage.get();
  }

  @Override
  public boolean isExpandable() {
    return false;
  }

  @Override
  public void setContext(EvaluationContextImpl context) {
  }

  @Override
  protected String calcRepresentation(EvaluationContextImpl context, DescriptorLabelListener labelListener) throws EvaluateException {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    return myMessage.get();
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.openapi.project.Project;
import com.intellij.psi.PsiExpression;
import com.sun.jdi.*;
import org.jetbrains.annotations.NotNull;

public class MethodReturnValueDescriptorImpl extends ValueDescriptorImpl {
  private final Method myMethod;

  public MethodReturnValueDescriptorImpl(Project project, @NotNull Method method, Value value) {
    super(project, value);
    myMethod = method;
  }

  @Override
  public Value calcValue(EvaluationContextImpl evaluationContext) throws EvaluateException {
    return getValue();
  }

  @NotNull
  public Method getMethod() {
    return myMethod;
  }

  @Override
  public String getName() {
    return NodeRendererSettings.getInstance().getClassRenderer().renderTypeName(myMethod.declaringType().name()) + "." +
           DebuggerUtilsEx.methodNameWithArguments(myMethod);
  }

  @Override
  public Type getType() {
    Type type = super.getType();
    if (type == null) {
      try {
        type = myMethod.returnType();
      }
      catch (ClassNotLoadedException ignored) {
      }
    }
    return type;
  }

  @Override
  public PsiExpression getDescriptorEvaluation(DebuggerContext context) throws EvaluateException {
    Value value = getValue();
    if (value instanceof ObjectReference) {
      throw new NeedMarkException((ObjectReference)value);
    }
    return null;
  }

  @Override
  public boolean canSetValue() {
    return false;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.impl.watch;

import com.sun.jdi.Method;
import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
import org.jetbrains.annotations.Nullable;

/**
 * @author Eugene Zhuravlev
 */
public class MethodsTracker {
  @SuppressWarnings("SSBasedInspection") private final Object2IntOpenHashMap<Method> myMethodCounter = new Object2IntOpenHashMap<>();
  private final Int2ObjectMap<MethodOccurrence> myCache = new Int2ObjectOpenHashMap<>();

  public final class MethodOccurrence {
    private final @Nullable Method myMethod;
    private final int myIndex;
    private final int myFrameIndex;

    private MethodOccurrence(@Nullable Method method, int index, int frameIndex) {
      myMethod = method;
      myIndex = index;
      myFrameIndex = frameIndex;
    }

    public @Nullable Method getMethod() {
      return myMethod;
    }

    public int getIndex() {
      return getOccurrenceCount(myMethod) - myIndex;
    }

    public boolean isRecursive() {
      return myMethod != null && getOccurrenceCount(myMethod) > 1;
    }

    // check that all methods are not native to be able to drop a frame
    public boolean canDrop() {
      for (int i = 0; i <= myFrameIndex + 1; i++) {
        MethodOccurrence occurrence = myCache.get(i);
        Method method = occurrence != null ? occurrence.myMethod : null;
        if (method == null || method.isNative()) {
          return false;
        }
      }
      return true;
    }
  }

  public MethodOccurrence getMethodOccurrence(int frameIndex, @Nullable Method method) {
    return myCache.computeIfAbsent(frameIndex, __ -> {
      synchronized (myMethodCounter) {
        int occurrence = method != null ? myMethodCounter.addTo(method, 1) : 0;
        return new MethodOccurrence(method, occurrence, frameIndex);
      }
    });
  }

  private int getOccurrenceCount(@Nullable Method method) {
    synchronized (myMethodCounter) {
      return myMethodCounter.getInt(method);
    }
  }
}
/*
 * Copyright 2000-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.engine.StackFrameContext;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.TextWithImports;
import com.intellij.debugger.engine.jdi.LocalVariableProxy;
import com.intellij.debugger.engine.jdi.StackFrameProxy;
import com.intellij.debugger.engine.jdi.ThreadReferenceProxy;
import com.intellij.debugger.impl.descriptors.data.*;
import com.intellij.debugger.jdi.*;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.NodeDescriptorFactory;
import com.intellij.debugger.ui.tree.UserExpressionDescriptor;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.sun.jdi.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.HashMap;

public class NodeDescriptorFactoryImpl implements NodeDescriptorFactory {
  private static final Logger LOG = Logger.getInstance(NodeDescriptorFactoryImpl.class);
  private DescriptorTree myCurrentHistoryTree = new DescriptorTree(true);

  private DescriptorTreeSearcher myDescriptorSearcher;
  private DescriptorTreeSearcher myDisplayDescriptorSearcher;

  protected final Project myProject;

  public NodeDescriptorFactoryImpl(Project project) {
    myProject = project;
    myDescriptorSearcher = new DescriptorTreeSearcher(new MarkedDescriptorTree());
    myDisplayDescriptorSearcher = new DisplayDescriptorTreeSearcher(new MarkedDescriptorTree());
  }

  public void dispose() {
    myCurrentHistoryTree.clear();
    myDescriptorSearcher.clear();
    myDisplayDescriptorSearcher.clear();
  }

  @NotNull
  public <T extends NodeDescriptor> T getDescriptor(NodeDescriptor parent, DescriptorData<T> key) {
    final T descriptor = key.createDescriptor(myProject);

    final T oldDescriptor = findDescriptor(parent, descriptor, key);

    if (oldDescriptor != null && oldDescriptor.getClass() == descriptor.getClass()) {
      descriptor.setAncestor(oldDescriptor);
    }
    else {
      T displayDescriptor = findDisplayDescriptor(parent, descriptor, key.getDisplayKey());
      if (displayDescriptor != null) {
        descriptor.displayAs(displayDescriptor);
      }
    }

    myCurrentHistoryTree.addChild(parent, descriptor);

    return descriptor;
  }

  @Nullable
  protected <T extends NodeDescriptor> T findDisplayDescriptor(NodeDescriptor parent, T descriptor, DisplayKey<T> key) {
    return myDisplayDescriptorSearcher.search(parent, descriptor, key);
  }

  @Nullable
  protected <T extends NodeDescriptor> T findDescriptor(NodeDescriptor parent, T descriptor, DescriptorData<T> key) {
    return myDescriptorSearcher.search(parent, descriptor, key);
  }

  public DescriptorTree getCurrentHistoryTree() {
    return myCurrentHistoryTree;
  }

  public void deriveHistoryTree(DescriptorTree tree, final StackFrameContext context) {
    deriveHistoryTree(tree, context.getFrameProxy());
  }

  public void deriveHistoryTree(DescriptorTree tree, final StackFrameProxy frameProxy) {

    final MarkedDescriptorTree descriptorTree = new MarkedDescriptorTree();
    final MarkedDescriptorTree displayDescriptorTree = new MarkedDescriptorTree();

    tree.dfst(new DescriptorTree.DFSTWalker() {
      @Override
      public void visit(NodeDescriptor parent, NodeDescriptor child) {
        final DescriptorData<NodeDescriptor> descriptorData = DescriptorData.getDescriptorData(child);
        descriptorTree.addChild(parent, child, descriptorData);
        displayDescriptorTree.addChild(parent, child, descriptorData.getDisplayKey());
      }
    });

    myDescriptorSearcher = new DescriptorTreeSearcher(descriptorTree);
    myDisplayDescriptorSearcher = new DisplayDescriptorTreeSearcher(displayDescriptorTree);

    myCurrentHistoryTree = createDescriptorTree(frameProxy, tree);
  }

  private static DescriptorTree createDescriptorTree(final StackFrameProxy frameProxy, final DescriptorTree fromTree) {
    int frameCount = -1;
    int frameIndex = -1;
    if (frameProxy != null) {
      try {
        final ThreadReferenceProxy threadReferenceProxy = frameProxy.threadProxy();
        frameCount = threadReferenceProxy.frameCount();
        frameIndex = frameProxy.getFrameIndex();
      }
      catch (EvaluateException e) {
        // ignored
      }
    }
    final boolean isInitial = !fromTree.frameIdEquals(frameCount, frameIndex);
    DescriptorTree descriptorTree = new DescriptorTree(isInitial);
    descriptorTree.setFrameId(frameCount, frameIndex);
    return descriptorTree;
  }

  @Override
  public ArrayElementDescriptorImpl getArrayItemDescriptor(NodeDescriptor parent, ArrayReference array, int index) {
    return getDescriptor(parent, new ArrayItemData(array, index));
  }

  @NotNull
  @Override
  public FieldDescriptorImpl getFieldDescriptor(NodeDescriptor parent, ObjectReference objRef, Field field) {
    final DescriptorData<FieldDescriptorImpl> descriptorData;
    if (objRef == null) {
      if (!field.isStatic()) {
        LOG.error("Object reference is null for non-static field: " + field);
      }
      descriptorData = new StaticFieldData(field);
    }
    else {
      descriptorData = new FieldData(objRef, field);
    }
    return getDescriptor(parent, descriptorData);
  }

  @Override
  public LocalVariableDescriptorImpl getLocalVariableDescriptor(NodeDescriptor parent, LocalVariableProxy local) {
    return getDescriptor(parent, new LocalData((LocalVariableProxyImpl)local));
  }

  public ArgumentValueDescriptorImpl getArgumentValueDescriptor(NodeDescriptor parent, DecompiledLocalVariable variable, Value value) {
    return getDescriptor(parent, new ArgValueData(variable, value));
  }

  public StackFrameDescriptorImpl getStackFrameDescriptor(@Nullable NodeDescriptorImpl parent, @NotNull StackFrameProxyImpl frameProxy) {
    return getDescriptor(parent, new StackFrameData(frameProxy));
  }

  public StaticDescriptorImpl getStaticDescriptor(NodeDescriptorImpl parent, ReferenceType refType) {//static is unique
    return getDescriptor(parent, new StaticData(refType));
  }

  public ValueDescriptorImpl getThisDescriptor(NodeDescriptorImpl parent, Value value) {
    return getDescriptor(parent, new ThisData());
  }

  public ValueDescriptorImpl getMethodReturnValueDescriptor(NodeDescriptorImpl parent, Method method, Value value) {
    return getDescriptor(parent, new MethodReturnValueData(method, value));
  }

  public ValueDescriptorImpl getThrownExceptionObjectDescriptor(NodeDescriptorImpl parent, ObjectReference exceptionObject) {
    return getDescriptor(parent, new ThrownExceptionValueData(exceptionObject));
  }

  public ThreadDescriptorImpl getThreadDescriptor(NodeDescriptorImpl parent, ThreadReferenceProxyImpl thread) {
    return getDescriptor(parent, new ThreadData(thread));
  }

  public ThreadGroupDescriptorImpl getThreadGroupDescriptor(NodeDescriptorImpl parent, ThreadGroupReferenceProxyImpl group) {
    return getDescriptor(parent, new ThreadGroupData(group));
  }

  @Override
  public UserExpressionDescriptor getUserExpressionDescriptor(NodeDescriptor parent, final DescriptorData<UserExpressionDescriptor> data) {
    return getDescriptor(parent, data);
  }

  public WatchItemDescriptor getWatchItemDescriptor(NodeDescriptor parent, TextWithImports text, @Nullable Value value) {
    return getDescriptor(parent, new WatchItemData(text, value));
  }

  private static class DescriptorTreeSearcher {
    private final MarkedDescriptorTree myDescriptorTree;

    private final HashMap<NodeDescriptor, NodeDescriptor> mySearchedDescriptors = new HashMap<>();

    DescriptorTreeSearcher(MarkedDescriptorTree descriptorTree) {
      myDescriptorTree = descriptorTree;
    }

    @Nullable
    public <T extends NodeDescriptor> T search(NodeDescriptor parent, T descriptor, DescriptorKey<T> key) {
      final T result;
      if (parent == null) {
        result = myDescriptorTree.getChild(null, key);
      }
      else {
        final NodeDescriptor parentDescriptor = getSearched(parent);
        result = parentDescriptor != null ? myDescriptorTree.getChild(parentDescriptor, key) : null;
      }
      if (result != null) {
        mySearchedDescriptors.put(descriptor, result);
      }
      return result;
    }

    protected NodeDescriptor getSearched(NodeDescriptor parent) {
      return mySearchedDescriptors.get(parent);
    }

    public void clear() {
      mySearchedDescriptors.clear();
      myDescriptorTree.clear();
    }
  }

  private class DisplayDescriptorTreeSearcher extends DescriptorTreeSearcher {
    DisplayDescriptorTreeSearcher(MarkedDescriptorTree descriptorTree) {
      super(descriptorTree);
    }

    @Override
    protected NodeDescriptor getSearched(NodeDescriptor parent) {
      NodeDescriptor searched = super.getSearched(parent);
      if (searched == null) {
        return myDescriptorSearcher.getSearched(parent);
      }
      return searched;
    }
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.render.DescriptorLabelListener;
import com.intellij.debugger.ui.tree.render.OnDemandRenderer;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.NlsContexts;
import com.sun.jdi.InconsistentDebugInfoException;
import com.sun.jdi.InvalidStackFrameException;
import com.sun.jdi.ObjectCollectedException;
import com.sun.jdi.VMDisconnectedException;
import org.jetbrains.annotations.NotNull;

import java.util.HashMap;
import java.util.Map;

public abstract class NodeDescriptorImpl implements NodeDescriptor {
  protected static final Logger LOG = Logger.getInstance(NodeDescriptorImpl.class);

  public static final String UNKNOWN_VALUE_MESSAGE = "";
  public boolean myIsExpanded = false;
  public boolean myIsSelected = false;
  public boolean myIsVisible = false;

  private EvaluateException myEvaluateException;
  private @NlsContexts.Label String myLabel = UNKNOWN_VALUE_MESSAGE;

  private Map<Key, Object> myUserData;

  @Override
  public String getName() {
    return null;
  }

  @Override
  public <T> T getUserData(@NotNull Key<T> key) {
    if (myUserData == null) {
      return null;
    }
    //noinspection unchecked
    return (T)myUserData.get(key);
  }

  @Override
  public <T> void putUserData(@NotNull Key<T> key, T value) {
    if (myUserData == null) {
      myUserData = new HashMap<>();
    }
    myUserData.put(key, value);
  }

  public void updateRepresentation(EvaluationContextImpl context, DescriptorLabelListener labelListener) {
    updateRepresentationNoNotify(context, labelListener);
    labelListener.labelChanged();
  }

  public void updateRepresentationNoNotify(EvaluationContextImpl context, DescriptorLabelListener labelListener) {
    try {
      try {
        myEvaluateException = null;
        myLabel = calcRepresentation(context, labelListener);
      }
      catch (InconsistentDebugInfoException e) {
        throw new EvaluateException(JavaDebuggerBundle.message("error.inconsistent.debug.info"));
      }
      catch (InvalidStackFrameException e) {
        throw new EvaluateException(JavaDebuggerBundle.message("error.invalid.stackframe"));
      }
      catch (ObjectCollectedException e) {
        throw EvaluateExceptionUtil.OBJECT_WAS_COLLECTED;
      }
      catch (VMDisconnectedException e) {
        throw e;
      }
      catch (RuntimeException e) {
        if (e.getCause() instanceof InterruptedException) {
          throw e;
        }
        if (context != null && context.getDebugProcess().getVirtualMachineProxy().canBeModified()) { // do not care in read only vms
          LOG.debug(e);
        }
        else {
          LOG.warn(e);
        }
        throw new EvaluateException(JavaDebuggerBundle.message("internal.debugger.error"));
      }
    }
    catch (EvaluateException e) {
      setFailed(e);
    }
  }

  protected abstract @NlsContexts.Label String calcRepresentation(EvaluationContextImpl context, DescriptorLabelListener labelListener) throws EvaluateException;

  @Override
  public void displayAs(NodeDescriptor descriptor) {
    if (descriptor instanceof NodeDescriptorImpl that) {
      myIsExpanded = that.myIsExpanded;
      myIsSelected = that.myIsSelected;
      myIsVisible = that.myIsVisible;
      myUserData = that.myUserData != null ? new HashMap<>(that.myUserData) : null;

      // TODO introduce unified way to handle this
      if (myUserData != null) {
        myUserData.remove(OnDemandRenderer.ON_DEMAND_CALCULATED); // calculated flag should not be inherited
      }
    }
  }

  public abstract boolean isExpandable();

  public abstract void setContext(EvaluationContextImpl context);

  public EvaluateException getEvaluateException() {
    return myEvaluateException;
  }

  @Override
  public @NlsContexts.Label String getLabel() {
    return myLabel;
  }

  public String toString() {
    return getLabel();
  }

  protected String setFailed(EvaluateException e) {
    myEvaluateException = e;
    return e.getMessage();
  }

  protected String setLabel(@NlsContexts.Label String customLabel) {
    return myLabel = customLabel;
  }

  //Context is set to null
  public void clear() {
    myEvaluateException = null;
    myLabel = "";
  }

  @Override
  public void setAncestor(NodeDescriptor oldDescriptor) {
    displayAs(oldDescriptor);
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl.watch;

public interface NodeDescriptorProvider {
  NodeDescriptorImpl getDescriptor();
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.impl.DebuggerContextImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.jdi.JvmtiError;
import com.intellij.debugger.jdi.StackFrameProxyImpl;
import com.intellij.debugger.ui.impl.nodes.NodeComparator;
import com.intellij.debugger.ui.tree.DebuggerTreeNode;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.NodeManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.NlsContexts;
import com.sun.jdi.InternalException;
import com.sun.jdi.Location;
import com.sun.jdi.Method;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

/**
 * <ul>
 * <li>finds correspondence between new descriptor and one created on the previous steps
 * <li>stores maximum CACHED_STEPS steps
 * <li>call saveState function to start new step
 * </ul>
 */
public class NodeManagerImpl extends NodeDescriptorFactoryImpl implements NodeManager {
  private static final Comparator<DebuggerTreeNode> ourNodeComparator = new NodeComparator();

  private final DebuggerTree myDebuggerTree;
  private String myHistoryKey = null;
  private final Map<String, DescriptorTree> myHistories = new HashMap<>();

  public NodeManagerImpl(Project project, DebuggerTree tree) {
    super(project);
    myDebuggerTree = tree;
  }

  public static Comparator<DebuggerTreeNode> getNodeComparator() {
    return ourNodeComparator;
  }

  @Override
  @NotNull
  public DebuggerTreeNodeImpl createNode(NodeDescriptor descriptor, EvaluationContext evaluationContext) {
    ((NodeDescriptorImpl)descriptor).setContext((EvaluationContextImpl)evaluationContext);
    return DebuggerTreeNodeImpl.createNode(getTree(), (NodeDescriptorImpl)descriptor, (EvaluationContextImpl)evaluationContext);
  }

  public DebuggerTreeNodeImpl getDefaultNode() {
    return DebuggerTreeNodeImpl.createNodeNoUpdate(getTree(), new DefaultNodeDescriptor());
  }

  public DebuggerTreeNodeImpl createMessageNode(MessageDescriptor descriptor) {
    return DebuggerTreeNodeImpl.createNodeNoUpdate(getTree(), descriptor);
  }

  @Override
  @NotNull
  public DebuggerTreeNodeImpl createMessageNode(@NlsContexts.Label String message) {
    return DebuggerTreeNodeImpl.createNodeNoUpdate(getTree(), new MessageDescriptor(message));
  }

  public void setHistoryByContext(final DebuggerContextImpl context) {
    setHistoryByContext(context.getFrameProxy());
  }

  public void setHistoryByContext(StackFrameProxyImpl frameProxy) {
    if (myHistoryKey != null) {
      myHistories.put(myHistoryKey, getCurrentHistoryTree());
    }

    final String historyKey = getContextKey(frameProxy);
    final DescriptorTree descriptorTree;
    if (historyKey != null) {
      final DescriptorTree historyTree = myHistories.get(historyKey);
      descriptorTree = (historyTree != null) ? historyTree : new DescriptorTree(true);
    }
    else {
      descriptorTree = new DescriptorTree(true);
    }

    deriveHistoryTree(descriptorTree, frameProxy);
    myHistoryKey = historyKey;
  }


  @Nullable
  public String getContextKey(final StackFrameProxyImpl frame) {
    return getContextKeyForFrame(frame);
  }

  @Nullable
  public static String getContextKeyForFrame(final StackFrameProxyImpl frame) {
    if (frame == null) {
      return null;
    }
    try {
      final Location location = frame.location();
      final Method method = DebuggerUtilsEx.getMethod(location);
      if (method == null) {
        return null;
      }
      return location.declaringType().signature() + "#" + method.name() + method.signature();
    }
    catch (EvaluateException ignored) {
    }
    catch (InternalException ie) {
      if (ie.errorCode() != JvmtiError.INVALID_METHODID) {
        throw ie;
      }
    }
    return null;
  }

  @Override
  public void dispose() {
    myHistories.clear();
    super.dispose();
  }

  private DebuggerTree getTree() {
    return myDebuggerTree;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.ContextUtil;
import com.intellij.debugger.engine.DebugProcess;
import com.intellij.debugger.engine.DebuggerManagerThreadImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.impl.DebuggerUtilsAsync;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.impl.DebuggerUtilsImpl;
import com.intellij.debugger.jdi.StackFrameProxyImpl;
import com.intellij.debugger.settings.ThreadsViewSettings;
import com.intellij.debugger.ui.breakpoints.BreakpointIntentionAction;
import com.intellij.debugger.ui.tree.StackFrameDescriptor;
import com.intellij.debugger.ui.tree.render.DescriptorLabelListener;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.psi.PsiFile;
import com.intellij.util.ui.EmptyIcon;
import com.intellij.xdebugger.impl.frame.XValueMarkers;
import com.intellij.xdebugger.impl.ui.tree.ValueMarkup;
import com.sun.jdi.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Nodes of this type cannot be updated, because StackFrame objects become invalid as soon as VM has been resumed
 */
public class StackFrameDescriptorImpl extends NodeDescriptorImpl implements StackFrameDescriptor {
  private final StackFrameProxyImpl myFrame;
  private int myUiIndex;
  private String myName = null;
  private Location myLocation;
  private MethodsTracker.MethodOccurrence myMethodOccurrence;
  private boolean myIsSynthetic;
  private boolean myIsInLibraryContent;
  private ObjectReference myThisObject;
  private SourcePosition mySourcePosition;

  private Icon myIcon = EmptyIcon.ICON_16;

  public StackFrameDescriptorImpl(@NotNull StackFrameProxyImpl frame, @NotNull MethodsTracker tracker) {
    myFrame = frame;

    try {
      myUiIndex = frame.getFrameIndex();
      myLocation = frame.location();
      if (!getValueMarkers().isEmpty()) {
        getThisObject(); // init this object for markup
      }
      myMethodOccurrence = tracker.getMethodOccurrence(myUiIndex, DebuggerUtilsEx.getMethod(myLocation));
      myIsSynthetic = DebuggerUtils.isSynthetic(myMethodOccurrence.getMethod());
      mySourcePosition = ContextUtil.getSourcePosition(this);
      PsiFile psiFile = mySourcePosition != null ? mySourcePosition.getFile() : null;
      myIsInLibraryContent = DebuggerUtilsEx.isInLibraryContent(psiFile != null ? psiFile.getVirtualFile() : null, getDebugProcess().getProject());
    }
    catch (InternalException | EvaluateException e) {
      LOG.info(e);
      myLocation = null;
      myMethodOccurrence = tracker.getMethodOccurrence(0, null);
      myIsSynthetic = false;
      myIsInLibraryContent = false;
    }
  }

  private StackFrameDescriptorImpl(@NotNull StackFrameProxyImpl frame,
                                   @Nullable Method method,
                                   @NotNull MethodsTracker tracker) {
    myFrame = frame;

    try {
      myUiIndex = frame.getFrameIndex();
      myLocation = frame.location();
      if (!getValueMarkers().isEmpty()) {
        getThisObject(); // init this object for markup
      }
      myMethodOccurrence = tracker.getMethodOccurrence(myUiIndex, method);
      myIsSynthetic = DebuggerUtils.isSynthetic(method);
      mySourcePosition = ContextUtil.getSourcePosition(this);
      PsiFile psiFile = mySourcePosition != null ? mySourcePosition.getFile() : null;
      myIsInLibraryContent =
        DebuggerUtilsEx.isInLibraryContent(psiFile != null ? psiFile.getVirtualFile() : null, getDebugProcess().getProject());
    }
    catch (InternalException | EvaluateException e) {
      LOG.info(e);
      myLocation = null;
      myMethodOccurrence = tracker.getMethodOccurrence(0, null);
      myIsSynthetic = false;
      myIsInLibraryContent = false;
    }
  }

  public static CompletableFuture<StackFrameDescriptorImpl> createAsync(@NotNull StackFrameProxyImpl frame,
                                                                        @NotNull MethodsTracker tracker) {
    return frame.locationAsync()
      .thenCompose(DebuggerUtilsAsync::method)
      .thenApply(method -> new StackFrameDescriptorImpl(frame, method, tracker))
      .exceptionally(throwable -> {
        Throwable exception = DebuggerUtilsAsync.unwrap(throwable);
        if (exception instanceof EvaluateException) {
          // TODO: simplify when only async method left
          if (!(exception.getCause() instanceof InvalidStackFrameException)) {
            LOG.error(exception);
          }
          return new StackFrameDescriptorImpl(frame, tracker); // fallback to sync
        }
        throw (RuntimeException)throwable;
      });
  }

  public int getUiIndex() {
    return myUiIndex;
  }

  @Override
  @NotNull
  public StackFrameProxyImpl getFrameProxy() {
    return myFrame;
  }

  @NotNull
  @Override
  public DebugProcess getDebugProcess() {
    return myFrame.getVirtualMachine().getDebugProcess();
  }

  @Nullable
  public Method getMethod() {
    return myMethodOccurrence.getMethod();
  }

  public int getOccurrenceIndex() {
    return myMethodOccurrence.getIndex();
  }

  public boolean isRecursiveCall() {
    return myMethodOccurrence.isRecursive();
  }

  public boolean canDrop() {
    return !myFrame.isBottom() && myMethodOccurrence.canDrop();
  }

  @Nullable
  public ValueMarkup getValueMarkup() {
    Map<?, ValueMarkup> markers = getValueMarkers();
    if (!markers.isEmpty() && myThisObject != null) {
      return markers.get(myThisObject);
    }
    return null;
  }

  private Map<?, ValueMarkup> getValueMarkers() {
    XValueMarkers<?, ?> markers = DebuggerUtilsImpl.getValueMarkers(getDebugProcess());
    return markers != null ? markers.getAllMarkers() : Collections.emptyMap();
  }

  @Override
  public String getName() {
    return myName;
  }

  public void setName(@NotNull String name) {
    myName = name;
  }

  @Override
  protected String calcRepresentation(EvaluationContextImpl context, DescriptorLabelListener descriptorLabelListener) throws EvaluateException {
    DebuggerManagerThreadImpl.assertIsManagerThread();

    calcIconLater(descriptorLabelListener);

    if (myLocation == null) {
      return "";
    }
    ThreadsViewSettings settings = ThreadsViewSettings.getInstance();
    @NlsSafe StringBuilder label = new StringBuilder();
    Method method = myMethodOccurrence.getMethod();
    if (method != null) {
      if (myName == null) {
        myName = method.name();
      }
      label.append(settings.SHOW_ARGUMENTS_TYPES ? DebuggerUtilsEx.methodNameWithArguments(method) : myName);
    }
    if (settings.SHOW_LINE_NUMBER) {
      label.append(':').append(DebuggerUtilsEx.getLineNumber(myLocation, false));
      if (Registry.is("debugger.stack.frame.show.code.index")) {
        label.append(':').append(DebuggerUtilsEx.getCodeIndex(myLocation));
      }
    }
    if (settings.SHOW_CLASS_NAME) {
      String name;
      try {
        ReferenceType refType = myLocation.declaringType();
        name = refType != null ? refType.name() : null;
      }
      catch (InternalError e) {
        name = e.toString();
      }
      if (name != null) {
        label.append(", ");
        int dotIndex = name.lastIndexOf('.');
        if (dotIndex < 0) {
          label.append(name);
        }
        else {
          label.append(name.substring(dotIndex + 1));
          if (settings.SHOW_PACKAGE_NAME) {
            label.append(" {");
            label.append(name, 0, dotIndex);
            label.append("}");
          }
        }
      }
    }
    if (settings.SHOW_SOURCE_NAME) {
      label.append(", ").append(DebuggerUtilsEx.getSourceName(myLocation, e -> "Unknown Source"));
    }
    return label.toString();
  }

  @Override
  public boolean isExpandable() {
    return true;
  }

  @Override
  public final void setContext(EvaluationContextImpl context) {
  }

  public boolean isSynthetic() {
    return myIsSynthetic;
  }

  public boolean isInLibraryContent() {
    return myIsInLibraryContent;
  }

  @Nullable
  public Location getLocation() {
    return myLocation;
  }

  public SourcePosition getSourcePosition() {
    return mySourcePosition;
  }

  private void calcIconLater(DescriptorLabelListener descriptorLabelListener) {
    try {
      myFrame.isObsolete()
        .thenAccept(res -> {
          if (res) {
            myIcon = AllIcons.Debugger.Db_obsolete;
            descriptorLabelListener.labelChanged();
          }
        })
        .exceptionally(throwable -> DebuggerUtilsAsync.logError(throwable));
    }
    catch (EvaluateException ignored) {
    }
  }

  public Icon getIcon() {
    return myIcon;
  }

  @Nullable
  public ObjectReference getThisObject() {
    if (myThisObject == null) {
      try {
        myThisObject = myFrame.thisObject();
      }
      catch (EvaluateException e) {
        LOG.info(e);
      }
      if (myThisObject != null) {
        putUserData(BreakpointIntentionAction.THIS_ID_KEY, myThisObject.uniqueID());
        putUserData(BreakpointIntentionAction.THIS_TYPE_KEY, myThisObject.type().name());
      }
    }
    return myThisObject;
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

/*
 * Class StaticDescriptorImpl
 * @author Jeka
 */
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.engine.DebuggerManagerThreadImpl;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.debugger.ui.tree.StaticDescriptor;
import com.intellij.debugger.ui.tree.render.ClassRenderer;
import com.intellij.debugger.ui.tree.render.DescriptorLabelListener;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.util.containers.ContainerUtil;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.TypeComponent;

public class StaticDescriptorImpl extends NodeDescriptorImpl implements StaticDescriptor {

  private final ReferenceType myType;
  private final boolean myHasStaticFields;

  public StaticDescriptorImpl(ReferenceType refType) {
    myType = refType;
    myHasStaticFields = ContainerUtil.exists(myType.allFields(), TypeComponent::isStatic);
  }

  @Override
  public ReferenceType getType() {
    return myType;
  }

  @Override
  public String getName() {
    return "static";
  }

  @Override
  public boolean isExpandable() {
    return myHasStaticFields;
  }

  @Override
  public void setContext(EvaluationContextImpl context) {
  }

  @Override
  protected String calcRepresentation(EvaluationContextImpl context, DescriptorLabelListener descriptorLabelListener) throws EvaluateException {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    final ClassRenderer classRenderer = NodeRendererSettings.getInstance().getClassRenderer();
    @NlsSafe String representation = getName() + " = " + classRenderer.renderTypeName(myType.name());
    return representation;
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
indexing folder 2,11 %, passed time:0 minutes 19 seconds 19154 milliseconds, indexed more 363 files, last file: C:\Users\user\programming\personal\intellij-community\java\debugger\impl\src\com\intellij\debugger\ui\impl\watch\StaticDescriptorImpl.java
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.openapi.project.Project;
import com.intellij.psi.JavaPsiFacade;
import com.intellij.psi.PsiElementFactory;
import com.intellij.psi.PsiExpression;
import com.intellij.util.IncorrectOperationException;
import com.sun.jdi.Value;

public class ThisDescriptorImpl extends ValueDescriptorImpl {

  public ThisDescriptorImpl(Project project) {
    super(project);
  }

  @Override
  public Value calcValue(EvaluationContextImpl evaluationContext) throws EvaluateException {
    return evaluationContext != null ? evaluationContext.computeThisObject() : null;
  }

  @Override
  public String getName() {
    return "this";
  }

  @Override
  public PsiExpression getDescriptorEvaluation(DebuggerContext context) throws EvaluateException {
    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(myProject);
    try {
      return elementFactory.createExpressionFromText("this", null);
    }
    catch (IncorrectOperationException e) {
      throw new EvaluateException(e.getMessage(), e);
    }
  }

  @Override
  public boolean canSetValue() {
    return false;
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebuggerManagerThreadImpl;
import com.intellij.debugger.engine.SuspendContextImpl;
import com.intellij.debugger.engine.SuspendManager;
import com.intellij.debugger.engine.SuspendManagerUtil;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.jdi.ThreadGroupReferenceProxyImpl;
import com.intellij.debugger.jdi.ThreadReferenceProxyImpl;
import com.intellij.debugger.ui.tree.ThreadDescriptor;
import com.intellij.debugger.ui.tree.render.DescriptorLabelListener;
import com.intellij.icons.AllIcons;
import com.sun.jdi.ObjectCollectedException;
import com.sun.jdi.ThreadReference;

import javax.swing.*;

public class ThreadDescriptorImpl extends NodeDescriptorImpl implements ThreadDescriptor {
  private final ThreadReferenceProxyImpl myThread;
  private String myName = null;
  private boolean myIsExpandable = true;
  private boolean myIsSuspended = false;
  private boolean myIsCurrent;
  private boolean myIsFrozen;

  private boolean myIsAtBreakpoint;
  private SuspendContextImpl mySuspendContext;

  public ThreadDescriptorImpl(ThreadReferenceProxyImpl thread) {
    myThread = thread;
  }

  @Override
  public String getName() {
    return myName;
  }

  @Override
  protected String calcRepresentation(EvaluationContextImpl context, DescriptorLabelListener labelListener) throws EvaluateException {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    ThreadReferenceProxyImpl thread = getThreadReference();
    try {
      myName = thread.name();
      ThreadGroupReferenceProxyImpl gr = getThreadReference().threadGroupProxy();
      final String grname = (gr != null) ? gr.name() : null;
      final String threadStatusText = DebuggerUtilsEx.getThreadStatusText(getThreadReference().status());
      if (grname != null && !"SYSTEM".equalsIgnoreCase(grname)) {
        return JavaDebuggerBundle.message("label.thread.node.in.group", myName, thread.uniqueID(), threadStatusText, grname);
      }
      return JavaDebuggerBundle.message("label.thread.node", myName, thread.uniqueID(), threadStatusText);
    }
    catch (ObjectCollectedException e) {
      return myName != null ? JavaDebuggerBundle.message("label.thread.node.thread.collected", myName) : "";
    }
  }

  @Override
  public ThreadReferenceProxyImpl getThreadReference() {
    return myThread;
  }

  public boolean isCurrent() {
    return myIsCurrent;
  }

  public boolean isFrozen() {
    return myIsFrozen;
  }

  @Override
  public boolean isExpandable() {
    return myIsExpandable;
  }

  @Override
  public void setContext(EvaluationContextImpl context) {
    final ThreadReferenceProxyImpl thread = getThreadReference();
    final SuspendManager suspendManager = context != null ? context.getDebugProcess().getSuspendManager() : null;
    final SuspendContextImpl suspendContext = context != null ? context.getSuspendContext() : null;

    try {
      myIsSuspended = suspendManager != null ? suspendManager.isSuspended(thread) : thread.isSuspended();
    }
    catch (ObjectCollectedException e) {
      myIsSuspended = false;
    }
    myIsExpandable = calcExpandable(myIsSuspended);
    mySuspendContext = suspendManager != null ? SuspendManagerUtil.findContextByThread(suspendManager, thread) : suspendContext;
    myIsAtBreakpoint = thread.isAtBreakpoint();
    myIsCurrent = suspendContext != null ? suspendContext.getThread() == thread : false;
    myIsFrozen = suspendManager != null ? suspendManager.isFrozen(thread) : myIsSuspended;
  }

  private boolean calcExpandable(final boolean isSuspended) {
    if (!isSuspended) {
      return false;
    }
    final int status = getThreadReference().status();
    if (status == ThreadReference.THREAD_STATUS_UNKNOWN ||
        status == ThreadReference.THREAD_STATUS_NOT_STARTED ||
        status == ThreadReference.THREAD_STATUS_ZOMBIE) {
      return false;
    }
    return true;
    /*
    // [jeka] with lots of threads calling threadProxy.frameCount() in advance while setting context can be costly....
    // see IDEADEV-2020
    try {
      return threadProxy.frameCount() > 0;
    }
    catch (EvaluateException e) {
      //LOG.assertTrue(false);
      // if we pause during evaluation of this method the exception is thrown
      //  private static void longMethod() {
      //    try {
      //      Thread.sleep(100000);
      //    } catch (InterruptedException e) {
      //      e.printStackTrace();
      //    }
      //  }
      return false;
    }
    */
  }

  public SuspendContextImpl getSuspendContext() {
    return mySuspendContext;
  }

  public boolean isAtBreakpoint() {
    return myIsAtBreakpoint;
  }

  public boolean isSuspended() {
    return myIsSuspended;
  }

  public Icon getIcon() {
    if (isCurrent()) {
      return AllIcons.Debugger.ThreadCurrent;
    }
    if (isAtBreakpoint()) {
      return AllIcons.Debugger.ThreadAtBreakpoint;
    }
    if (isFrozen()) {
      return AllIcons.Debugger.ThreadFrozen;
    }
    if (isSuspended()) {
      return AllIcons.Debugger.ThreadSuspended;
    }
    return AllIcons.Debugger.ThreadRunning;
  }
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebuggerManagerThreadImpl;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.jdi.ThreadGroupReferenceProxyImpl;
import com.intellij.debugger.jdi.ThreadReferenceProxyImpl;
import com.intellij.debugger.ui.tree.ThreadGroupDescriptor;
import com.intellij.debugger.ui.tree.render.DescriptorLabelListener;
import com.sun.jdi.ObjectCollectedException;

public class ThreadGroupDescriptorImpl extends NodeDescriptorImpl implements ThreadGroupDescriptor {
  private final ThreadGroupReferenceProxyImpl myThreadGroup;
  private boolean myIsCurrent;
  private String myName = null;
  private boolean myIsExpandable = true;

  public ThreadGroupDescriptorImpl(ThreadGroupReferenceProxyImpl threadGroup) {
    myThreadGroup = threadGroup;
  }

  @Override
  public ThreadGroupReferenceProxyImpl getThreadGroupReference() {
    return myThreadGroup;
  }

  public boolean isCurrent() {
    return myIsCurrent;
  }

  @Override
  public String getName() {
    return myName;
  }

  @Override
  protected String calcRepresentation(EvaluationContextImpl context, DescriptorLabelListener labelListener) throws EvaluateException {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    ThreadGroupReferenceProxyImpl group = getThreadGroupReference();
    try {
      myName = group.name();
      return JavaDebuggerBundle.message("label.thread.group.node", myName, group.uniqueID());
    }
    catch (ObjectCollectedException e) {
      return myName != null ? JavaDebuggerBundle.message("label.thread.group.node.group.collected", myName) : "";
    }
  }

  @Override
  public boolean isExpandable() {
    return myIsExpandable;
  }

  @Override
  public void setContext(EvaluationContextImpl context) {
    ThreadReferenceProxyImpl threadProxy = context != null ? context.getSuspendContext().getThread() : null;
    myIsCurrent = threadProxy != null && isDescendantGroup(threadProxy.threadGroupProxy());
    myIsExpandable = calcExpandable();
  }

  private boolean isDescendantGroup(ThreadGroupReferenceProxyImpl group) {
    if (group == null) return false;

    if (getThreadGroupReference() == group) return true;

    return isDescendantGroup(group.parent());
  }

  private boolean calcExpandable() {
    ThreadGroupReferenceProxyImpl group = getThreadGroupReference();
    return group.threads().size() > 0 || group.threadGroups().size() > 0;
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.openapi.project.Project;
import com.intellij.psi.PsiExpression;
import com.sun.jdi.ObjectReference;
import com.sun.jdi.Value;
import org.jetbrains.annotations.NotNull;

public class ThrownExceptionValueDescriptorImpl extends ValueDescriptorImpl {
  public ThrownExceptionValueDescriptorImpl(Project project, @NotNull ObjectReference exceptionObj) {
    super(project, exceptionObj);
    // deliberately force default renderer as it does not invoke methods for rendering
    // calling methods on exception object at this moment may lead to VM hang
    setRenderer(DebugProcessImpl.getDefaultRenderer(exceptionObj));
  }

  @Override
  public Value calcValue(EvaluationContextImpl evaluationContext) throws EvaluateException {
    return getValue();
  }

  @Override
  public String getName() {
    return "Exception";
  }

  @Override
  public PsiExpression getDescriptorEvaluation(DebuggerContext context) throws EvaluateException {
    throw new NeedMarkException((ObjectReference)getValue());
  }

  @Override
  public boolean canSetValue() {
    return false;
  }
}
/*
 * Copyright 2000-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Class StaticDescriptorImpl
 * @author Jeka
 */
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.StackFrameContext;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.evaluation.TextWithImports;
import com.intellij.debugger.impl.DebuggerUtilsImpl;
import com.intellij.debugger.ui.tree.UserExpressionDescriptor;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Pair;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.JavaCodeFragment;
import com.intellij.psi.PsiCodeFragment;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiType;
import com.sun.jdi.Type;
import org.jetbrains.annotations.Nullable;

public class UserExpressionDescriptorImpl extends EvaluationDescriptor implements UserExpressionDescriptor {
  private final ValueDescriptorImpl myParentDescriptor;
  private final String myTypeName;
  private final String myName;
  private final int myEnumerationIndex;

  public UserExpressionDescriptorImpl(Project project,
                                      ValueDescriptorImpl parent,
                                      String typeName,
                                      String name,
                                      TextWithImports text,
                                      int enumerationIndex) {
    super(text, project);
    myParentDescriptor = parent;
    myTypeName = typeName;
    myName = name;
    myEnumerationIndex = enumerationIndex;
  }

  @Override
  public String getName() {
    return StringUtil.isEmpty(myName) ? myText.getText() : myName;
  }

  @Nullable
  @Override
  public String getDeclaredType() {
    Type type = getType();
    return type != null ? type.name() : null;
  }

  @Override
  protected PsiCodeFragment getEvaluationCode(final StackFrameContext context) throws EvaluateException {
    Pair<PsiElement, PsiType> psiClassAndType = DebuggerUtilsImpl.getPsiClassAndType(myTypeName, myProject);
    if (psiClassAndType.first == null) {
      throw EvaluateExceptionUtil.createEvaluateException(JavaDebuggerBundle.message("evaluation.error.invalid.type.name", myTypeName));
    }
    PsiCodeFragment fragment = createCodeFragment(psiClassAndType.first);
    if (fragment instanceof JavaCodeFragment) {
      ((JavaCodeFragment)fragment).setThisType(psiClassAndType.second);
    }
    return fragment;
  }

  public ValueDescriptorImpl getParentDescriptor() {
    return myParentDescriptor;
  }

  @Override
  protected EvaluationContextImpl getEvaluationContext(final EvaluationContextImpl evaluationContext) {
    return evaluationContext.createEvaluationContext(myParentDescriptor.getValue());
  }

  public int getEnumerationIndex() {
    return myEnumerationIndex;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.impl.watch;

import com.intellij.Patches;
import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.*;
import com.intellij.debugger.engine.evaluation.CodeFragmentFactoryContextWrapper;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.events.SuspendContextCommandImpl;
import com.intellij.debugger.impl.*;
import com.intellij.debugger.jdi.VirtualMachineProxyImpl;
import com.intellij.debugger.memory.utils.NamesUtils;
import com.intellij.debugger.settings.DebuggerSettings;
import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.debugger.ui.overhead.OverheadTimings;
import com.intellij.debugger.ui.tree.DebuggerTreeNode;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.NodeDescriptorNameAdjuster;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.debugger.ui.tree.render.Renderer;
import com.intellij.debugger.ui.tree.render.*;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.JavaPsiFacade;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiExpression;
import com.intellij.ui.JBColor;
import com.intellij.util.concurrency.Semaphore;
import com.intellij.xdebugger.frame.XValueModifier;
import com.intellij.xdebugger.frame.XValueNode;
import com.intellij.xdebugger.frame.presentation.XRegularValuePresentation;
import com.intellij.xdebugger.impl.frame.XValueMarkers;
import com.intellij.xdebugger.impl.ui.tree.ValueMarkup;
import com.sun.jdi.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.concurrency.Promise;
import org.jetbrains.concurrency.Promises;

import javax.swing.*;
import java.util.Collections;
import java.util.Objects;
import java.util.concurrent.CancellationException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

public abstract class ValueDescriptorImpl extends NodeDescriptorImpl implements ValueDescriptor {
  protected final Project myProject;

  NodeRenderer myRenderer = null;

  NodeRenderer myAutoRenderer = null;

  private Value myValue;
  private volatile boolean myValueReady;

  private EvaluateException myValueException;
  protected EvaluationContextImpl myStoredEvaluationContext = null;

  private String myIdLabel;
  private String myValueText;
  private String myCompactValueText;
  private boolean myFullValue = false;

  @Nullable
  private Icon myValueIcon;

  protected boolean myIsNew = true;
  private boolean myIsDirty = false;
  private boolean myIsLvalue = false;
  private boolean myIsExpandable;

  private boolean myShowIdLabel = true;

  private static final OnDemandPresentationProvider ourDefaultOnDemandPresentationProvider = node -> {
    node.setFullValueEvaluator(OnDemandRenderer.createFullValueEvaluator(JavaDebuggerBundle.message("message.node.evaluate")));
    node.setPresentation(AllIcons.Debugger.Db_watch, new XRegularValuePresentation("", null, ""), false);
  };

  private OnDemandPresentationProvider myOnDemandPresentationProvider = ourDefaultOnDemandPresentationProvider;

  protected ValueDescriptorImpl(Project project, Value value) {
    myProject = project;
    myValue = value;
    myValueReady = true;
  }

  protected ValueDescriptorImpl(Project project) {
    myProject = project;
  }

  private void assertValueReady() {
    if (!myValueReady) {
      LOG.error("Value is not yet calculated for " + getClass());
    }
  }

  @Override
  public boolean isArray() {
    assertValueReady();
    return myValue instanceof ArrayReference;
  }


  public boolean isDirty() {
    assertValueReady();
    return myIsDirty;
  }

  @Override
  public boolean isLvalue() {
    assertValueReady();
    return myIsLvalue;
  }

  @Override
  public boolean isNull() {
    assertValueReady();
    return myValue == null;
  }

  @Override
  public boolean isString() {
    assertValueReady();
    return myValue instanceof StringReference;
  }

  @Override
  public boolean isPrimitive() {
    assertValueReady();
    return myValue instanceof PrimitiveValue;
  }

  public boolean isEnumConstant() {
    assertValueReady();
    return myValue instanceof ObjectReference && isEnumConstant(((ObjectReference)myValue));
  }

  public boolean isValueValid() {
    return myValueException == null;
  }

  public boolean isShowIdLabel() {
    return myShowIdLabel && DebuggerSettings.getInstance().SHOW_TYPES;
  }

  public void setShowIdLabel(boolean showIdLabel) {
    myShowIdLabel = showIdLabel;
  }

  public boolean isValueReady() {
    return myValueReady;
  }

  @Override
  public Value getValue() {
    // the following code makes sense only if we do not use ObjectReference.enableCollection() / disableCollection()
    // to keep temporary objects
    if (Patches.IBM_JDK_DISABLE_COLLECTION_BUG) {
      final EvaluationContextImpl evalContext = myStoredEvaluationContext;
      if (evalContext != null && !evalContext.getSuspendContext().isResumed() &&
          myValue instanceof ObjectReference && VirtualMachineProxyImpl.isCollected((ObjectReference)myValue)) {

        final Semaphore semaphore = new Semaphore();
        semaphore.down();
        evalContext.getDebugProcess().getManagerThread().invoke(new SuspendContextCommandImpl(evalContext.getSuspendContext()) {
          @Override
          public void contextAction(@NotNull SuspendContextImpl suspendContext) {
            // re-setting the context will cause value recalculation
            try {
              setContext(myStoredEvaluationContext);
            }
            finally {
              semaphore.up();
            }
          }

          @Override
          protected void commandCancelled() {
            semaphore.up();
          }
        });
        semaphore.waitFor();
      }
    }

    assertValueReady();
    return myValue;
  }

  @Override
  public boolean isExpandable() {
    return myIsExpandable;
  }

  public abstract Value calcValue(EvaluationContextImpl evaluationContext) throws EvaluateException;

  @Override
  public final void setContext(EvaluationContextImpl evaluationContext) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    myStoredEvaluationContext = evaluationContext;
    Value value;
    try {
      value = calcValue(evaluationContext);

      if (!myIsNew) {
        try {
          if (myValue instanceof DoubleValue && Double.isNaN(((DoubleValue)myValue).doubleValue())) {
            myIsDirty = !(value instanceof DoubleValue);
          }
          else if (myValue instanceof FloatValue && Float.isNaN(((FloatValue)myValue).floatValue())) {
            myIsDirty = !(value instanceof FloatValue);
          }
          else {
            myIsDirty = !Objects.equals(value, myValue);
          }
        }
        catch (ObjectCollectedException ignored) {
          myIsDirty = true;
        }
      }
      myValue = value;
      myValueException = null;
    }
    catch (EvaluateException e) {
      myValueException = e;
      setFailed(e);
      myValue = getTargetExceptionWithStackTraceFilled(evaluationContext, e,
                                                       isPrintExceptionToConsole() || ApplicationManager.getApplication().isUnitTestMode());
      myIsExpandable = false;
    }
    finally {
      myValueReady = true;
    }

    myIsNew = false;
  }

  protected boolean isPrintExceptionToConsole() {
    return true;
  }

  public void applyOnDemandPresentation(@NotNull XValueNode node) {
    myOnDemandPresentationProvider.setPresentation(node);
  }

  public void setOnDemandPresentationProvider(@NotNull OnDemandPresentationProvider onDemandPresentationProvider) {
    myOnDemandPresentationProvider = onDemandPresentationProvider;
  }

  @Nullable
  protected static Value invokeExceptionGetStackTrace(ObjectReference exceptionObj, EvaluationContextImpl evaluationContext)
    throws EvaluateException {
    Method method = DebuggerUtils.findMethod(exceptionObj.referenceType(), "getStackTrace", "()[Ljava/lang/StackTraceElement;");
    if (method != null) {
      return evaluationContext.getDebugProcess().invokeInstanceMethod(
        evaluationContext, exceptionObj, method, Collections.emptyList(), 0, true);
    }
    return null;
  }

  @Nullable
  private static ObjectReference getTargetExceptionWithStackTraceFilled(@Nullable EvaluationContextImpl evaluationContext,
                                                                        EvaluateException ex,
                                                                        boolean printToConsole) {
    final ObjectReference exceptionObj = ex.getExceptionFromTargetVM();
    if (exceptionObj != null && evaluationContext != null) {
      try {
        Value trace = invokeExceptionGetStackTrace(exceptionObj, evaluationContext);

        // print to console as well
        if (printToConsole && trace instanceof ArrayReference traceArray) {
          DebugProcessImpl process = evaluationContext.getDebugProcess();
          process.printToConsole(DebuggerUtils.getValueAsString(evaluationContext, exceptionObj) + "\n");
          for (Value stackElement : traceArray.getValues()) {
            process.printToConsole("\tat " + DebuggerUtils.getValueAsString(evaluationContext, stackElement) + "\n");
          }
        }
      }
      catch (EvaluateException ignored) {
      }
      catch (Throwable e) {
        LOG.info(e); // catch all exceptions to ensure the method returns gracefully
      }
    }
    return exceptionObj;
  }

  @Override
  public void setAncestor(NodeDescriptor oldDescriptor) {
    super.setAncestor(oldDescriptor);
    myIsNew = false;
    if (!myValueReady) {
      ValueDescriptorImpl other = (ValueDescriptorImpl)oldDescriptor;
      if (other.myValueReady) {
        myValue = other.getValue();
        myValueReady = true;
      }
    }
  }

  protected void setLvalue(boolean value) {
    myIsLvalue = value;
  }

  @Override
  protected String calcRepresentation(EvaluationContextImpl context, DescriptorLabelListener labelListener) {
    DebuggerManagerThreadImpl.assertIsManagerThread();

    DebugProcessImpl debugProcess = context.getDebugProcess();
    getRenderer(debugProcess)
      .thenAccept(renderer -> calcRepresentation(context, labelListener, debugProcess, renderer))
      .exceptionally(throwable -> {
        throwable = DebuggerUtilsAsync.unwrap(throwable);
        if (throwable instanceof EvaluateException) {
          setValueLabelFailed((EvaluateException)throwable);
        }
        else {
          String message;
          if (throwable instanceof CancellationException) {
            message = JavaDebuggerBundle.message("error.context.has.changed");
          }
          else if (throwable instanceof VMDisconnectedException) {
            message = JavaDebuggerBundle.message("error.vm.disconnected");
          }
          else {
            message = JavaDebuggerBundle.message("internal.debugger.error");
            LOG.error(new Throwable(throwable));
          }
          setValueLabelFailed(new EvaluateException(message));
        }
        labelListener.labelChanged();
        return null;
      });

    return "";
  }

  @NotNull
  private String calcRepresentation(EvaluationContextImpl context,
                                    DescriptorLabelListener labelListener,
                                    DebugProcessImpl debugProcess,
                                    NodeRenderer renderer) {
    DebuggerManagerThreadImpl.assertIsManagerThread();

    EvaluateException valueException = myValueException;
    CompletableFuture<Boolean> expandableFuture;
    if (valueException == null || valueException.getExceptionFromTargetVM() != null) {
      expandableFuture = getChildrenRenderer(debugProcess)
        .thenCompose(r -> r.isExpandableAsync(getValue(), context, this));
    }
    else {
      expandableFuture = CompletableFuture.completedFuture(false);
    }

    if (!OnDemandRenderer.isOnDemandForced(debugProcess)) {
      try {
        setValueIcon(renderer.calcValueIcon(this, context, labelListener));
      }
      catch (EvaluateException e) {
        LOG.info(e);
        setValueIcon(null);
      }
    }

    //set label id
    if (isShowIdLabel() && renderer instanceof NodeRendererImpl) {
      setIdLabel(((NodeRendererImpl)renderer).calcIdLabel(this, debugProcess, labelListener));
    }

    if (valueException == null) {
      long start = renderer instanceof NodeRendererImpl && ((NodeRendererImpl)renderer).hasOverhead() ? System.currentTimeMillis() : 0;
      try {
        setValueLabel(renderer.calcLabel(this, context, labelListener));
      }
      catch (EvaluateException e) {
        setValueLabelFailed(e);
      }
      finally {
        if (start > 0) {
          OverheadTimings.add(debugProcess, new NodeRendererImpl.Overhead((NodeRendererImpl)renderer), 1, System.currentTimeMillis() - start);
        }
      }
    }
    else {
      setValueLabelFailed(valueException);
    }

    // only call labelChanged when we have expandable value
    expandableFuture.whenComplete((res, ex) -> {
      if (ex == null) {
        myIsExpandable = res;
      }
      else {
        ex = DebuggerUtilsAsync.unwrap(ex);
        if (ex instanceof EvaluateException) {
          LOG.warn(new Throwable(ex));
        }
        else if (!(ex instanceof CancellationException) && !(ex instanceof VMDisconnectedException)) {
          LOG.error(new Throwable(ex));
        }
      }
      labelListener.labelChanged();
    });

    return ""; // we have overridden getLabel
  }

  @Override
  public String getLabel() {
    @NlsSafe String label = calcValueName() + getDeclaredTypeLabel() + " = " + getValueLabel();
    return label;
  }

  public ValueDescriptorImpl getFullValueDescriptor() {
    ValueDescriptorImpl descriptor = new ValueDescriptorImpl(myProject, myValue) {
      @Override
      public Value calcValue(EvaluationContextImpl evaluationContext) throws EvaluateException {
        return myValue;
      }

      @Override
      public PsiExpression getDescriptorEvaluation(DebuggerContext context) throws EvaluateException {
        return null;
      }

      @Override
      public CompletableFuture<NodeRenderer> getRenderer(DebugProcessImpl debugProcess) {
        return ValueDescriptorImpl.this.getRenderer(debugProcess);
      }

      @Override
      public <T> T getUserData(@NotNull Key<T> key) {
        return ValueDescriptorImpl.this.getUserData(key);
      }
    };
    descriptor.myFullValue = true;
    return descriptor;
  }

  @Override
  public void setValueLabel(@NotNull String label) {
    myValueText = myFullValue ? label : DebuggerUtilsEx.truncateString(label);
  }

  public void setCompactValueLabel(String label) {
    myCompactValueText = label;
  }

  @Nullable
  public String getCompactValueText() {
    return myCompactValueText;
  }

  @Override
  public String setValueLabelFailed(EvaluateException e) {
    final String label = setFailed(e);
    setValueLabel(label);
    return label;
  }

  @Override
  public Icon setValueIcon(Icon icon) {
    return myValueIcon = icon;
  }

  @Nullable
  public Icon getValueIcon() {
    return myValueIcon;
  }

  public String calcValueName() {
    String name = getName();
    NodeDescriptorNameAdjuster nameAdjuster = NodeDescriptorNameAdjuster.findFor(this);
    if (nameAdjuster != null) {
      return nameAdjuster.fixName(name, this);
    }
    return name;
  }

  @Nullable
  public String getDeclaredType() {
    return null;
  }

  @Override
  public void displayAs(NodeDescriptor descriptor) {
    if (descriptor instanceof ValueDescriptorImpl valueDescriptor) {
      myRenderer = valueDescriptor.myRenderer;
    }
    super.displayAs(descriptor);
  }

  public Renderer getLastRenderer() {
    return myRenderer != null ? myRenderer : myAutoRenderer;
  }

  public Renderer getLastLabelRenderer() {
    Renderer lastRenderer = getLastRenderer();
    if (lastRenderer instanceof CompoundReferenceRenderer) {
      lastRenderer = ((CompoundReferenceRenderer)lastRenderer).getLabelRenderer();
    }
    return lastRenderer;
  }

  public CompletableFuture<NodeRenderer> getChildrenRenderer(DebugProcessImpl debugProcess) {
    if (OnDemandRenderer.isOnDemandForced(debugProcess)) {
      return CompletableFuture.completedFuture(DebugProcessImpl.getDefaultRenderer(getValue()));
    }
    return getRenderer(debugProcess);
  }

  public CompletableFuture<NodeRenderer> getRenderer(DebugProcessImpl debugProcess) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    return DebuggerUtilsAsync.type(getValue())
      .thenCompose(type -> getRenderer(type, debugProcess));
  }

  protected final CompletableFuture<NodeRenderer> getRenderer(Type type, DebugProcessImpl debugProcess) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    CompletableFuture<Boolean> customCheck = CompletableFuture.completedFuture(false);
    if (type != null && myRenderer != null) {
      customCheck = myRenderer.isApplicableAsync(type);
    }
    return customCheck.thenCompose(custom -> {
      if (custom) {
        return CompletableFuture.completedFuture(myRenderer);
      }
      else {
        return debugProcess.getAutoRendererAsync(type).thenApply(r -> myAutoRenderer = r);
      }
    });
  }

  public void setRenderer(NodeRenderer renderer) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    myRenderer = renderer;
    myAutoRenderer = null;
  }


  //returns expression that evaluates tree to this descriptor
  @NotNull
  public CompletableFuture<PsiElement> getTreeEvaluation(JavaValue value, DebuggerContextImpl context) throws EvaluateException {
    JavaValue parent = value.getParent();
    if (parent != null) {
      ValueDescriptorImpl vDescriptor = parent.getDescriptor();

      return vDescriptor.getTreeEvaluation(parent, context).thenCompose(parentEvaluation -> {
        if (!(parentEvaluation instanceof PsiExpression)) {
          return CompletableFuture.completedFuture(null);
        }

        return vDescriptor.getChildrenRenderer(context.getDebugProcess())
          .thenApply(childrenRenderer -> {
            try {
              return ReadAction.compute(() -> DebuggerTreeNodeExpression.substituteThis(
                childrenRenderer.getChildValueExpression(new DebuggerTreeNodeMock(value), context),
                ((PsiExpression)parentEvaluation), vDescriptor.getValue()
              ));
            }
            catch (EvaluateException e) {
              throw new CompletionException(e);
            }
          });
      });
    }

    Promise<PsiElement> res;
    try {
      PsiElement result = ReadAction.nonBlocking(() -> getDescriptorEvaluation(context)).executeSynchronously();
      res = Promises.resolvedPromise(result);
    }
    catch (Exception wrapper) {
      if (!(wrapper.getCause() instanceof EvaluateException)) throw wrapper;
      if (!(wrapper.getCause() instanceof NeedMarkException e)) throw (EvaluateException)wrapper.getCause();

      XValueMarkers<?, ?> markers = DebuggerUtilsImpl.getValueMarkers(context.getDebugProcess());
      if (markers != null) {
        ValueMarkup existing = markers.getMarkup(value);
        String markName;
        Promise<Object> promise;
        if (existing != null) {
          markName = existing.getText();
          promise = Promises.resolvedPromise();
        }
        else {
          markName = e.getMarkName();
          promise = markers.markValue(value, new ValueMarkup(markName, new JBColor(0, 0), null));
        }
        res = promise.then(__ -> ReadAction.nonBlocking(() -> JavaPsiFacade.getElementFactory(myProject)
          .createExpressionFromText(markName + CodeFragmentFactoryContextWrapper.DEBUG_LABEL_SUFFIX,
                                    PositionUtil.getContextElement(context))).executeSynchronously());
      }
      else {
        res = Promises.resolvedPromise(null);
      }
    }
    return Promises.asCompletableFuture(res);
  }

  protected static class NeedMarkException extends EvaluateException {
    private final String myMarkName;

    public NeedMarkException(ObjectReference reference) {
      super(null);
      myMarkName = NamesUtils.getUniqueName(reference).replace("@", "");
    }

    @Override
    public Throwable fillInStackTrace() {
      return this;
    }

    public String getMarkName() {
      return myMarkName;
    }
  }

  private static class DebuggerTreeNodeMock implements DebuggerTreeNode {
    private final JavaValue value;

    DebuggerTreeNodeMock(JavaValue value) {
      this.value = value;
    }

    @Override
    public DebuggerTreeNode getParent() {
      return new DebuggerTreeNodeMock(value.getParent());
    }

    @Override
    public ValueDescriptorImpl getDescriptor() {
      return value.getDescriptor();
    }

    @Override
    public Project getProject() {
      return value.getProject();
    }

    @Override
    public void setRenderer(NodeRenderer renderer) {
    }
  }

  //returns expression that evaluates descriptor value
  //use 'this' to reference parent node
  //for ex. FieldDescriptorImpl should return
  //this.fieldName
  @Override
  public abstract PsiExpression getDescriptorEvaluation(DebuggerContext context) throws EvaluateException;

  public static String getIdLabel(ObjectReference objRef) {
    return calcIdLabel(objRef, null, null);
  }

  @Nullable
  public static String calcIdLabel(ValueDescriptor descriptor, @NotNull DescriptorLabelListener labelListener) {
    Value value = descriptor.getValue();
    if (!(value instanceof ObjectReference)) {
      return null;
    }
    return calcIdLabel((ObjectReference)value, descriptor, labelListener);
  }

  @Nullable
  private static String calcIdLabel(ObjectReference objRef,
                                    @Nullable ValueDescriptor descriptor,
                                    @Nullable DescriptorLabelListener labelListener) {
    final ClassRenderer classRenderer = NodeRendererSettings.getInstance().getClassRenderer();
    if (objRef instanceof StringReference && !classRenderer.SHOW_STRINGS_TYPE) {
      return null;
    }
    StringBuilder buf = new StringBuilder();
    final boolean showConcreteType =
      !classRenderer.SHOW_DECLARED_TYPE ||
      (!(objRef instanceof StringReference) && !(objRef instanceof ClassObjectReference) && !isEnumConstant(objRef));
    if (showConcreteType || classRenderer.SHOW_OBJECT_ID) {
      //buf.append('{');
      if (showConcreteType) {
        buf.append(classRenderer.renderTypeName(objRef.type().name()));
      }
      if (classRenderer.SHOW_OBJECT_ID) {
        buf.append('@');
        if (ApplicationManager.getApplication().isUnitTestMode()) {
          buf.append("uniqueID");
        }
        else {
          buf.append(objRef.uniqueID());
        }
      }
      //buf.append('}');
    }

    if (objRef instanceof ArrayReference) {
      int idx = buf.indexOf("[");
      if (idx >= 0) {
        if (labelListener == null || descriptor == null) {
          buf.insert(idx + 1, ((ArrayReference)objRef).length());
        }
        else {
          CompletableFuture<String> asyncId = DebuggerUtilsAsync.length((ArrayReference)objRef)
            .thenApply(length -> buf.insert(idx + 1, length).toString());
          if (asyncId.isDone()) {
            return asyncId.join();
          }
          else {
            asyncId.thenAccept(res -> {
              descriptor.setIdLabel(res);
              labelListener.labelChanged();
            });
          }
        }
      }
    }

    return buf.toString();
  }

  private static boolean isEnumConstant(final ObjectReference objRef) {
    try {
      Type type = objRef.type();
      return type instanceof ClassType && ((ClassType)type).isEnum();
    }
    catch (ObjectCollectedException ignored) {
    }
    return false;
  }

  public boolean canSetValue() {
    return myValueReady && isLvalue();
  }

  public XValueModifier getModifier(JavaValue value) {
    return null;
  }

  public String getIdLabel() {
    return myIdLabel;
  }

  @Override
  public void setIdLabel(String idLabel) {
    myIdLabel = idLabel;
  }

  public String getValueLabel() {
    String label = getIdLabel();
    if (!StringUtil.isEmpty(label)) {
      return '{' + label + '}' + getValueText();
    }
    return getValueText();
  }

  @NotNull
  public String getValueText() {
    return StringUtil.notNullize(myValueText);
  }

  //Context is set to null
  @Override
  public void clear() {
    super.clear();
    setValueLabel("");
    myIsExpandable = false;
  }

  public boolean canMark() {
    if (!myValueReady) {
      return false;
    }
    return getValue() instanceof ObjectReference;
  }

  public Project getProject() {
    return myProject;
  }

  @NotNull
  public String getDeclaredTypeLabel() {
    ClassRenderer classRenderer = NodeRendererSettings.getInstance().getClassRenderer();
    if (classRenderer.SHOW_DECLARED_TYPE) {
      String declaredType = getDeclaredType();
      if (!StringUtil.isEmpty(declaredType)) {
        return ": " + classRenderer.renderTypeName(declaredType);
      }
    }
    return "";
  }

  public EvaluationContextImpl getStoredEvaluationContext() {
    return myStoredEvaluationContext;
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

/*
 * Class WatchItemDescriptor
 * @author Jeka
 */
package com.intellij.debugger.ui.impl.watch;

import com.intellij.debugger.engine.StackFrameContext;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.evaluation.TextWithImports;
import com.intellij.debugger.impl.PositionUtil;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Comparing;
import com.intellij.psi.PsiCodeFragment;
import com.sun.jdi.Value;

public class WatchItemDescriptor extends EvaluationDescriptor {
  public WatchItemDescriptor(Project project, TextWithImports text) {
    super(text, project);
    setValueLabel("");
  }

  public WatchItemDescriptor(Project project, TextWithImports text, Value value) {
    super(text, project, value);
    setValueLabel("");
  }

  public WatchItemDescriptor(Project project, TextWithImports text, Value value, EvaluationContextImpl evaluationContext) {
    super(text, project, value);
    setValueLabel("");
    myStoredEvaluationContext = evaluationContext;
  }

  @Override
  public String getName() {
    return getEvaluationText().getText();
  }

  public void setNew() {
    myIsNew = true;
  }

  public void setEvaluationText(TextWithImports evaluationText) {
    if (!Comparing.equal(getEvaluationText(), evaluationText)) {
      setLvalue(false);
    }
    myText = evaluationText;
    myIsNew = true;
    setValueLabel("");
  }

  @Override
  protected EvaluationContextImpl getEvaluationContext(EvaluationContextImpl evaluationContext) {
    return evaluationContext;
  }

  @Override
  protected PsiCodeFragment getEvaluationCode(StackFrameContext context) {
    return createCodeFragment(PositionUtil.getContextElement(context));
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.InputValidatorEx;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.wm.IdeFocusManager;
import com.intellij.ui.classFilter.ClassFilter;
import org.jetbrains.annotations.Nullable;

public class InstanceFilterEditor extends PatternFilterEditor {
  public InstanceFilterEditor(Project project) {
    super(project);
  }

  @Override
  protected void addClassFilter() {
    String idString = Messages.showInputDialog(myProject,
                                               JavaDebuggerBundle.message("add.instance.filter.dialog.prompt"),
                                               JavaDebuggerBundle.message("add.instance.filter.dialog.title"),
                                               Messages.getQuestionIcon(),
                                               null,
                                               new InputValidatorEx() {
                                                 @Nullable
                                                 @Override
                                                 public String getErrorText(String inputString) {
                                                   try {
                                                     Long.parseLong(inputString);
                                                     return null;
                                                   }
                                                   catch (NumberFormatException e) {
                                                     return JavaDebuggerBundle
                                                       .message("add.instance.filter.dialog.error.numeric.value.expected");
                                                   }
                                                 }

                                                 @Override
                                                 public boolean canClose(String inputString) {
                                                   return getErrorText(inputString) == null;
                                                 }
                                               });
    if (idString != null) {
      ClassFilter filter = createFilter(idString);
      myTableModel.addRow(filter);
      int row = myTableModel.getRowCount() - 1;
      myTable.getSelectionModel().setSelectionInterval(row, row);
      myTable.scrollRectToVisible(myTable.getCellRect(row, 0, true));

      IdeFocusManager.getGlobalInstance().doWhenFocusSettlesDown(() -> IdeFocusManager.getGlobalInstance().requestFocus(myTable, true));
    }
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui;

import com.intellij.openapi.project.Project;
import com.intellij.openapi.project.ProjectManager;
import com.intellij.openapi.wm.IdeFocusManager;
import com.intellij.openapi.wm.IdeFrame;

import static com.intellij.openapi.project.ProjectCoreUtil.theOnlyOpenProject;

public final class JavaDebuggerSupport {
  /** @deprecated This method is an unreliable hack, find another way to locate a project instance. */
  @Deprecated(forRemoval = true)
  public static Project getContextProjectForEditorFieldsInDebuggerConfigurables() {
    //todo[nik] improve
    IdeFrame frame = IdeFocusManager.getGlobalInstance().getLastFocusedFrame();
    if (frame != null) {
      Project project = frame.getProject();
      if (project != null) {
        return project;
      }
    }
    Project project = theOnlyOpenProject();
    return project != null ? project : ProjectManager.getInstance().getDefaultProject();
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.overhead;

import com.intellij.ui.SimpleColoredComponent;

public interface OverheadProducer {
  boolean isEnabled();

  void setEnabled(boolean enabled);

  void customizeRenderer(SimpleColoredComponent renderer);

  default boolean isObsolete() {
    return false;
  }

  default boolean track() {
    return true;
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.overhead;

import com.intellij.debugger.engine.DebugProcess;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.Pair;
import com.intellij.util.EventDispatcher;
import com.intellij.util.ObjectUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class OverheadTimings {
  public static final Key<OverheadTimings> KEY = Key.create("OVERHEAD_TIMINGS");

  private final EventDispatcher<OverheadTimingsListener> myEventDispatcher = EventDispatcher.create(OverheadTimingsListener.class);
  private final Map<OverheadProducer, Timings> myMap = new ConcurrentHashMap<>();

  @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
  private final List<Pair<Long, Timings>> myLast10Elements = new LinkedList<>() {
    private long totalTime = 0;

    @Override
    public synchronized boolean add(Pair<Long, Timings> o) {
      if (size() > 10) {
        if (isExcessive()) {
          myEventDispatcher.getMulticaster().excessiveOverheadDetected();
        }
        Pair<Long, Timings> first = removeFirst();
        if (first != null) {
          totalTime -= ObjectUtils.notNull(first.getSecond().myTime, 0L);
        }
      }
      totalTime += ObjectUtils.notNull(o.getSecond().myTime, 0L);
      return super.add(o);
    }

    private boolean isExcessive() {
      long timeframe = getLast().first - getFirst().first;
      return totalTime > timeframe || timeframe < 5;
    }
  };

  public static Long getTime(DebugProcess process, OverheadProducer producer) {
    Timings timings = getTimings(process).myMap.get(producer);
    return timings != null ? timings.myTime : null;
  }

  public static long getHits(DebugProcess process, OverheadProducer producer) {
    Timings timings = getTimings(process).myMap.get(producer);
    return timings != null ? timings.myHits : 0;
  }

  public static Set<OverheadProducer> getProducers(DebugProcess process) {
    return getTimings(process).myMap.keySet();
  }

  public static void add(DebugProcess process, OverheadProducer producer, long hits, @Nullable Long overhead) {
    OverheadTimings timings = getTimings(process);
    Timings newTiming = new Timings(hits, overhead);
    timings.myLast10Elements.add(Pair.create(System.currentTimeMillis(), newTiming));
    timings.myMap.merge(producer, newTiming, (old, value) -> {
      Long newTime = old.myTime;
      if (value.myTime != null) {
        newTime += value.myTime;
      }
      return new Timings(old.myHits + value.myHits, newTime);
    });
    timings.myEventDispatcher.getMulticaster().timingAdded(producer);
  }

  @NotNull
  private static OverheadTimings getTimings(DebugProcess process) {
    OverheadTimings data = process.getUserData(KEY);
    if (data == null) {
      data = new OverheadTimings();
      process.putUserData(KEY, data);
    }
    return data;
  }

  private static class Timings {
    final long myHits;
    final Long myTime;

    Timings(long hits, Long time) {
      myHits = hits;
      myTime = time;
    }
  }

  static void addListener(OverheadTimingsListener listener, DebugProcess process) {
    getTimings(process).myEventDispatcher.addListener(listener);
  }

  public interface OverheadTimingsListener extends EventListener {
    void timingAdded(OverheadProducer producer);

    void excessiveOverheadDetected();
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.overhead;

import com.intellij.CommonBundle;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.ui.breakpoints.Breakpoint;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.actionSystem.*;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.project.DumbAwareAction;
import com.intellij.openapi.util.NlsContexts;
import com.intellij.pom.Navigatable;
import com.intellij.ui.*;
import com.intellij.ui.table.TableView;
import com.intellij.util.concurrency.AppExecutorUtil;
import com.intellij.util.ui.ColumnInfo;
import com.intellij.util.ui.ListTableModel;
import com.intellij.util.ui.components.BorderLayoutPanel;
import com.intellij.util.ui.update.MergingUpdateQueue;
import com.intellij.util.ui.update.Update;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.impl.ui.DebuggerUIUtil;
import one.util.streamex.StreamEx;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import javax.swing.table.TableCellRenderer;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.function.Function;

import static com.intellij.util.containers.ContainerUtil.getFirstItem;
import static com.intellij.util.containers.ContainerUtil.mapNotNull;

public class OverheadView extends BorderLayoutPanel implements Disposable, DataProvider {
  @NotNull private final DebugProcessImpl myProcess;

  static final EnabledColumnInfo ENABLED_COLUMN = new EnabledColumnInfo();
  static final NameColumnInfo NAME_COLUMN = new NameColumnInfo();

  private final TableView<OverheadProducer> myTable;
  private final ListTableModel<OverheadProducer> myModel;

  private final MergingUpdateQueue myUpdateQueue;
  private Runnable myBouncer;

  private static final SimpleTextAttributes STRIKEOUT_ATTRIBUTES = new SimpleTextAttributes(SimpleTextAttributes.STYLE_STRIKEOUT, null);

  public OverheadView(@NotNull DebugProcessImpl process) {
    myProcess = process;

    myModel = new ListTableModel<>(new ColumnInfo[]{
      ENABLED_COLUMN,
      NAME_COLUMN,
      new TimingColumnInfo(JavaDebuggerBundle.message("column.name.hits"), s -> OverheadTimings.getHits(myProcess, s)),
      new TimingColumnInfo(JavaDebuggerBundle.message("column.name.time.ms"), s -> OverheadTimings.getTime(myProcess, s))},
                                   new ArrayList<>(OverheadTimings.getProducers(process)),
                                   3, SortOrder.DESCENDING);
    myModel.setSortable(true);
    myTable = new TableView<>(myModel);
    addToCenter(ScrollPaneFactory.createScrollPane(myTable));
    TableUtil.setupCheckboxColumn(myTable.getColumnModel().getColumn(0));

    myUpdateQueue = new MergingUpdateQueue("OverheadView", 500, true, null, this);

    OverheadTimings.addListener(new OverheadTimings.OverheadTimingsListener() {
                                  @Override
                                  public void timingAdded(OverheadProducer o) {
                                    myUpdateQueue.queue(new Update(o) {
                                      @Override
                                      public void run() {
                                        int idx = myModel.indexOf(o);
                                        if (idx != -1) {
                                          myModel.fireTableRowsUpdated(idx, idx);
                                          return;
                                        }
                                        myModel.setItems(new ArrayList<>(OverheadTimings.getProducers(process)));
                                      }
                                    });
                                  }

                                  @Override
                                  public void excessiveOverheadDetected() {
                                    if (myBouncer != null) {
                                      DebuggerUIUtil.invokeLater(myBouncer);
                                    }
                                  }
                                }
      , process);

    new DumbAwareAction(CommonBundle.message("action.text.toggle")) {
      @Override
      public void update(@NotNull AnActionEvent e) {
        e.getPresentation().setEnabled(myTable.getSelectedRowCount() == 1);
      }

      @Override
      public @NotNull ActionUpdateThread getActionUpdateThread() {
        return ActionUpdateThread.EDT;
      }

      @Override
      public void actionPerformed(@NotNull final AnActionEvent e) {
        myTable.getSelection().forEach(c -> c.setEnabled(!c.isEnabled()));
        myTable.repaint();
      }
    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0)), myTable);

    new DoubleClickListener() {
      @Override
      protected boolean onDoubleClick(@NotNull MouseEvent e) {
        ReadAction.nonBlocking(
            () -> getFirstItem(mapNotNull(getSelectedBreakpoints(), XBreakpoint::getNavigatable)))
          .expireWith(OverheadView.this)
          .finishOnUiThread(ModalityState.nonModal(), navigatable -> {
            if (navigatable != null) {
              navigatable.navigate(true);
            }
          })
          .submit(AppExecutorUtil.getAppExecutorService());
        return true;
      }
    }.installOn(myTable);
  }


  private List<XBreakpoint> getSelectedBreakpoints() {
    return StreamEx.of(myTable.getSelection())
      .select(Breakpoint.class)
      .map(Breakpoint::getXBreakpoint).nonNull()
      .toList();
  }


  public JComponent getDefaultFocusedComponent() {
    return myTable;
  }

  @Nullable
  @Override
  public Object getData(@NotNull String dataId) {
    if (PlatformCoreDataKeys.BGT_DATA_PROVIDER.is(dataId)) {
      var selectedBreakpoints = getSelectedBreakpoints(); // gather in EDT
      return (DataProvider)realDataId -> getSlowData(selectedBreakpoints, realDataId);
    }
    return null;
  }

  @Nullable
  private static Object getSlowData(@NotNull List<XBreakpoint> selected, @NonNls String dataId) {
    if (CommonDataKeys.NAVIGATABLE_ARRAY.is(dataId)) {
      List<Navigatable> navigatables = mapNotNull(selected, XBreakpoint::getNavigatable);
      if (!navigatables.isEmpty()) {
        return navigatables.toArray(Navigatable.EMPTY_NAVIGATABLE_ARRAY);
      }
    }
    return null;
  }

  private static class EnabledColumnInfo extends ColumnInfo<OverheadProducer, Boolean> {
    EnabledColumnInfo() {
      super("");
    }

    @Override
    public Class<?> getColumnClass() {
      return Boolean.class;
    }

    @Nullable
    @Override
    public Boolean valueOf(OverheadProducer item) {
      return item.isEnabled();
    }

    @Override
    public boolean isCellEditable(OverheadProducer item) {
      return true;
    }

    @Override
    public void setValue(OverheadProducer item, Boolean value) {
      item.setEnabled(value);
    }
  }

  private static class NameColumnInfo extends ColumnInfo<OverheadProducer, OverheadProducer> {
    NameColumnInfo() {
      super(CommonBundle.message("title.name"));
    }

    @Nullable
    @Override
    public OverheadProducer valueOf(OverheadProducer aspects) {
      return aspects;
    }

    @Override
    public Class<?> getColumnClass() {
      return OverheadProducer.class;
    }

    @Nullable
    @Override
    public TableCellRenderer getRenderer(OverheadProducer producer) {
      return new ColoredTableCellRenderer() {
        @Override
        protected void customizeCellRenderer(@NotNull JTable table, @Nullable Object value, boolean selected, boolean hasFocus, int row, int column) {
          if (value instanceof OverheadProducer overheadProducer) {
            if (overheadProducer.isObsolete()) {
              overrideAttributes(overheadProducer, STRIKEOUT_ATTRIBUTES);
            }
            else if (!overheadProducer.isEnabled()) {
              overrideAttributes(overheadProducer, SimpleTextAttributes.GRAYED_ATTRIBUTES);
            }
            else {
              overheadProducer.customizeRenderer(this);
            }
          }
          setTransparentIconBackground(true);
        }

        private void overrideAttributes(OverheadProducer overhead, SimpleTextAttributes attributes) {
          SimpleColoredComponent component = new SimpleColoredComponent();
          overhead.customizeRenderer(component);
          component.iterator().forEachRemaining(f -> append(f, attributes));
          setIcon(component.getIcon());
        }
      };
    }
  }

  private static class TimingColumnInfo extends ColumnInfo<OverheadProducer, OverheadProducer> {
    private final Function<? super OverheadProducer, Long> myGetter;

    TimingColumnInfo(@NotNull @NlsContexts.ColumnName String name, Function<? super OverheadProducer, Long> getter) {
      super(name);
      myGetter = getter;
    }

    @Nullable
    @Override
    public OverheadProducer valueOf(OverheadProducer aspects) {
      return aspects;
    }

    @Override
    public Class<?> getColumnClass() {
      return OverheadProducer.class;
    }

    @Nullable
    @Override
    public TableCellRenderer getRenderer(OverheadProducer producer) {
      return new ColoredTableCellRenderer() {
        @Override
        protected void customizeCellRenderer(@NotNull JTable table,
                                             @Nullable Object value,
                                             boolean selected,
                                             boolean hasFocus,
                                             int row,
                                             int column) {
          if (value instanceof OverheadProducer overheadProducer) {
            Long val = myGetter.apply(overheadProducer);
            append(val != null ? String.valueOf((long)val) : "",
                   overheadProducer.isEnabled() ? SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES : SimpleTextAttributes.GRAYED_ATTRIBUTES);
          }
        }
      };
    }

    @Nullable
    @Override
    public Comparator<OverheadProducer> getComparator() {
      return Comparator.comparing(c -> {
        Long value = myGetter.apply(c);
        return value != null ? value : Long.MAX_VALUE;
      });
    }
  }

  @Override
  public void dispose() {
  }

  public void setBouncer(Runnable bouncer) {
    myBouncer = bouncer;
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.openapi.project.Project;
import com.intellij.ui.classFilter.ClassFilterEditor;
import com.intellij.util.IconUtil;

import javax.swing.*;

public class PatternFilterEditor extends ClassFilterEditor {
  public PatternFilterEditor(Project project) {
    super(project);
    getEmptyText().setText(JavaDebuggerBundle.message("filters.not.configured"));
  }

  @Override
  protected void addClassFilter() {
    addPatternFilter();
  }

  @Override
  protected String getAddButtonText() {
    return JavaDebuggerBundle.message("button.add");
  }

  @Override
  protected Icon getAddButtonIcon() {
    return IconUtil.getAddIcon();
  }

  @Override
  protected boolean addPatternButtonVisible() {
    return false;
  }
}
// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.impl.DebuggerSession;
import com.intellij.debugger.settings.DebuggerSettings;
import com.intellij.ide.util.ElementsChooser;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.MultiLineLabelUI;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.ui.JBUI;
import com.intellij.util.ui.OptionsDialog;
import com.intellij.util.ui.UIUtil;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;

public class RunHotswapDialog extends OptionsDialog {
  private final JPanel myPanel;
  private final ElementsChooser<SessionItem> myElementsChooser;
  private final boolean myDisplayHangWarning;

  public RunHotswapDialog(Project project, List<DebuggerSession> sessions, boolean displayHangWarning) {
    super(project);
    myDisplayHangWarning = displayHangWarning;
    myPanel = new JPanel(new BorderLayout());
    final List<SessionItem> items = new ArrayList<>(sessions.size());
    for (DebuggerSession session : sessions) {
      items.add(new SessionItem(session));
    }
    items.sort(Comparator.comparing(debuggerSession -> debuggerSession.getSession().getSessionName()));
    myElementsChooser = new ElementsChooser<>(items, true);
    myPanel.setBorder(JBUI.Borders.empty(10, 0, 5, 0));
    //myElementsChooser.setBorder(IdeBorderFactory.createEmptyBorder(5, 0, 0, 0));
    if (sessions.size() > 0) {
      myElementsChooser.selectElements(items.subList(0, 1));
    }
    myPanel.add(myElementsChooser, BorderLayout.CENTER);
    //myPanel.add(new JLabel("Choose debug sessions to reload classes:"), BorderLayout.NORTH);
    if (sessions.size() == 1) {
      setTitle(JavaDebuggerBundle.message("hotswap.dialog.title.with.session", sessions.get(0).getSessionName()));
      myPanel.setVisible(false);
    }
    else {
      setTitle(JavaDebuggerBundle.message("hotswap.dialog.title"));
    }
    this.init();
  }

  @Override
  protected boolean isToBeShown() {
    return DebuggerSettings.RUN_HOTSWAP_ASK.equals(DebuggerSettings.getInstance().RUN_HOTSWAP_AFTER_COMPILE);
  }

  @Override
  protected void setToBeShown(boolean value, boolean onOk) {
    if (value) {
      DebuggerSettings.getInstance().RUN_HOTSWAP_AFTER_COMPILE = DebuggerSettings.RUN_HOTSWAP_ASK;
    }
    else {
      if (onOk) {
        DebuggerSettings.getInstance().RUN_HOTSWAP_AFTER_COMPILE = DebuggerSettings.RUN_HOTSWAP_ALWAYS;
      }
      else {
        DebuggerSettings.getInstance().RUN_HOTSWAP_AFTER_COMPILE = DebuggerSettings.RUN_HOTSWAP_NEVER;
      }
    }
  }

  @Override
  protected boolean shouldSaveOptionsOnCancel() {
    return true;
  }

  @Override
  protected Action @NotNull [] createActions() {
    setOKButtonText(JavaDebuggerBundle.message("hotswap.dialog.reload.action.text"));
    return new Action[]{getOKAction(), getCancelAction()};
  }

  @Override
  protected JComponent createNorthPanel() {
    JLabel label = new JLabel(JavaDebuggerBundle.message("hotswap.dialog.run.prompt"));
    JPanel panel = new JPanel(new BorderLayout());
    panel.add(label, BorderLayout.CENTER);
    Icon icon = UIUtil.getQuestionIcon();
    label.setIcon(icon);
    label.setIconTextGap(7);
    if (myDisplayHangWarning) {
      final JLabel warningLabel = new JLabel(
        JavaDebuggerBundle.message("warning.0", JavaDebuggerBundle.message("hotswap.dialog.hang.warning")));
      warningLabel.setUI(new MultiLineLabelUI());
      panel.add(warningLabel, BorderLayout.SOUTH);
    }
    return panel;
  }

  @Override
  protected JComponent createCenterPanel() {
    return myPanel;
  }

  public Collection<DebuggerSession> getSessionsToReload() {
    return ContainerUtil.map(myElementsChooser.getMarkedElements(), SessionItem::getSession);
  }

  private static class SessionItem {
    private final DebuggerSession mySession;

    SessionItem(DebuggerSession session) {
      mySession = session;
    }

    public DebuggerSession getSession() {
      return mySession;
    }

    public String toString() {
      return mySession.getSessionName();
    }
  }
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.sun.jdi.ArrayReference;

public interface ArrayElementDescriptor extends NodeDescriptor {
  ArrayReference getArray();

  int getIndex();
}
/*
 * Copyright 2000-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.intellij.debugger.ui.tree.render.NodeRenderer;
import com.intellij.openapi.project.Project;

public interface DebuggerTreeNode {
  DebuggerTreeNode getParent();

  NodeDescriptor getDescriptor();

  Project getProject();

  void setRenderer(NodeRenderer renderer);
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree;

import com.sun.jdi.ObjectReference;

public interface DescriptorWithParentObject extends NodeDescriptor {
  ObjectReference getObject();
}
/*
 * Copyright 2000-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.intellij.openapi.util.Key;
import com.sun.jdi.Field;

public interface FieldDescriptor extends DescriptorWithParentObject {
  Key<Boolean> SHOW_DECLARING_TYPE = Key.create("SHOW_TYPE_IN_NAME");

  Field getField();
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.intellij.debugger.engine.jdi.LocalVariableProxy;

public interface LocalVariableDescriptor extends ValueDescriptor {
  LocalVariableProxy getLocalVariable();
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.intellij.debugger.engine.jdi.LocalVariableProxy;
import com.intellij.debugger.impl.descriptors.data.DescriptorData;
import com.sun.jdi.ArrayReference;
import com.sun.jdi.Field;
import com.sun.jdi.ObjectReference;
import org.jetbrains.annotations.NotNull;

/**
 * creates descriptors
 * if descriptor was already created in current context (that is location in debugee code) returns that descriptor
 * else creates new descriptor and restores it's representation properties from history
 */

public interface NodeDescriptorFactory {
  ArrayElementDescriptor getArrayItemDescriptor(NodeDescriptor parent, ArrayReference array, int index);

  @NotNull
  FieldDescriptor getFieldDescriptor(NodeDescriptor parent, ObjectReference objRef, Field field);

  LocalVariableDescriptor getLocalVariableDescriptor(NodeDescriptor parent, LocalVariableProxy local);

  UserExpressionDescriptor getUserExpressionDescriptor(NodeDescriptor parent, final DescriptorData<UserExpressionDescriptor> data);
}
/*
 * Copyright 2000-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.intellij.debugger.engine.evaluation.EvaluationContext;
import org.jetbrains.annotations.NotNull;

public interface NodeManager {
  @NotNull
  DebuggerTreeNode createMessageNode(String s);

  @NotNull
  DebuggerTreeNode createNode(NodeDescriptor nodeDescriptor, EvaluationContext evaluationContext);
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree.render

import com.intellij.debugger.DebuggerManagerEx
import com.intellij.debugger.JavaDebuggerBundle
import com.intellij.debugger.actions.ArrayAction
import com.intellij.debugger.actions.ArrayFilterAction
import com.intellij.debugger.engine.JavaValue
import com.intellij.debugger.engine.SuspendContextImpl
import com.intellij.debugger.engine.events.SuspendContextCommandImpl
import com.intellij.debugger.impl.DebuggerUtilsImpl
import com.intellij.debugger.impl.PrioritizedTask
import com.intellij.debugger.settings.NodeRendererSettings
import com.intellij.icons.AllIcons
import com.intellij.openapi.application.ReadAction
import com.intellij.openapi.util.Pair
import com.intellij.psi.JavaCodeFragment
import com.intellij.psi.PsiDocumentManager
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiType
import com.intellij.ui.SimpleColoredComponent
import com.intellij.ui.SimpleTextAttributes
import com.intellij.util.ui.tree.TreeModelAdapter
import com.intellij.util.ui.tree.TreeUtil
import com.intellij.xdebugger.impl.XDebuggerUtilImpl
import com.intellij.xdebugger.impl.ui.DebuggerUIUtil
import com.intellij.xdebugger.impl.ui.tree.XDebuggerTreeInplaceEditor
import com.intellij.xdebugger.impl.ui.tree.nodes.XDebuggerTreeNode
import com.intellij.xdebugger.impl.ui.tree.nodes.XValueNodeImpl
import com.sun.jdi.ArrayReference
import com.sun.jdi.ArrayType
import java.awt.Rectangle
import javax.swing.event.TreeModelEvent
import javax.swing.tree.TreeNode
import kotlin.math.min

final class ArrayFilterInplaceEditor(node: XDebuggerTreeNode, private val myTemp: Boolean, thisType: PsiType?) : XDebuggerTreeInplaceEditor(node,
                                                                                                                                            "arrayFilter") {
  init {
    if (thisType != null) {
      myExpressionEditor.setDocumentProcessor({ d ->
                                                val psiFile = PsiDocumentManager.getInstance(project).getPsiFile(d)
                                                if (psiFile is JavaCodeFragment) psiFile.thisType = thisType
                                                d
                                              })
    }
    val arrayRenderer = ArrayAction.getArrayRenderer((myNode.parent as XValueNodeImpl).valueContainer)
    myExpressionEditor.expression = if (arrayRenderer is ArrayRenderer.Filtered) arrayRenderer.expression else null
  }

  override fun cancelEditing() {
    super.cancelEditing()
    if (myTemp) (myNode.parent as XValueNodeImpl).removeTemporaryEditorNode(myNode)
  }

  override fun doOKAction() {
    myTree.model.addTreeModelListener(object : TreeModelAdapter() {
      override fun process(event: TreeModelEvent, type: EventType) {
        if (event.treePath?.lastPathComponent != myNode.parent) {
          myTree.model.removeTreeModelListener(this)
        }
        if (type == EventType.NodesInserted) {
          event.children?.filter { ArrayFilterAction.isArrayFilter(it as TreeNode) }?.forEach {
            myTree.selectionPath = TreeUtil.getPathFromRoot(it as TreeNode)
            myTree.model.removeTreeModelListener(this)
          }
        }
      }
    })
    ArrayAction.setArrayRenderer(if (XDebuggerUtilImpl.isEmptyExpression(expression))
                                   NodeRendererSettings.getInstance().arrayRenderer
                                 else
                                   ArrayRenderer.Filtered(expression),
                                 myNode.parent as XValueNodeImpl,
                                 DebuggerManagerEx.getInstanceEx(project).context)
    super.doOKAction()
  }

  override fun getEditorBounds(): Rectangle? {
    val bounds = super.getEditorBounds() ?: return null

    val nameLabel = SimpleColoredComponent()
    nameLabel.ipad.right = 0
    nameLabel.ipad.left = 0
    nameLabel.icon = myNode.icon
    nameLabel.append(JavaDebuggerBundle.message("message.node.filtered"), SimpleTextAttributes.REGULAR_ATTRIBUTES)
    val offset = nameLabel.preferredSize.width

    bounds.x += offset
    bounds.width -= offset
    return bounds
  }

  companion object {
    @JvmStatic
    fun edit(node: XDebuggerTreeNode, temp: Boolean) {
      val javaValue = (node.parent as XValueNodeImpl).valueContainer
      if (javaValue is JavaValue) {
        val debugProcess = javaValue.evaluationContext.debugProcess
        debugProcess.managerThread.schedule(
          object : SuspendContextCommandImpl(javaValue.evaluationContext.suspendContext) {
            override fun getPriority(): PrioritizedTask.Priority {
              return PrioritizedTask.Priority.NORMAL
            }

            override fun contextAction(suspendContext: SuspendContextImpl) {
              var type: String? = null
              val value = javaValue.descriptor.value
              if (value is ArrayReference) {
                type = (value.type() as ArrayType).componentTypeName()
              }
              else {
                val lastChildrenValue = ExpressionChildrenRenderer.getLastChildrenValue(javaValue.descriptor)
                if (lastChildrenValue is ArrayReference) {
                  // take first non-null element for now
                  for (v in lastChildrenValue.getValues(0, min(lastChildrenValue.length(), 100))) {
                    if (v != null) {
                      type = v.type().name()
                      break
                    }
                  }
                }
              }
              val pair = ReadAction.compute<Pair<PsiElement, PsiType>, Exception> {
                DebuggerUtilsImpl.getPsiClassAndType(type, javaValue.project)
              }
              DebuggerUIUtil.invokeLater({ ArrayFilterInplaceEditor(node, temp, pair.second).show() })
            }

            override fun commandCancelled() {
              DebuggerUIUtil.invokeLater({ ArrayFilterInplaceEditor(node, temp, null).show() })
            }
          })
      }
      else {
        ArrayFilterInplaceEditor(node, temp, null).show()
      }
    }

    @JvmStatic
    fun editParent(parentNode: XValueNodeImpl) {
      var temp = false
      var node = parentNode.children.find { ArrayFilterAction.isArrayFilter(it) }
      if (node == null) {
        node = parentNode.addTemporaryEditorNode(AllIcons.General.Filter, JavaDebuggerBundle.message("message.node.filtered"))
        temp = true
      }
      edit(node as XDebuggerTreeNode, temp)
    }
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.DebuggerManagerEx;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.actions.ArrayAction;
import com.intellij.debugger.engine.ContextUtil;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerManagerThreadImpl;
import com.intellij.debugger.engine.JavaValue;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.evaluation.TextWithImportsImpl;
import com.intellij.debugger.impl.DebuggerUtilsAsync;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.memory.utils.ErrorsValueGroup;
import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.debugger.settings.ViewsGeneralSettings;
import com.intellij.debugger.ui.impl.watch.ArrayElementDescriptorImpl;
import com.intellij.debugger.ui.impl.watch.NodeManagerImpl;
import com.intellij.debugger.ui.impl.watch.ValueDescriptorImpl;
import com.intellij.debugger.ui.tree.DebuggerTreeNode;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.NodeDescriptorFactory;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.roots.LanguageLevelProjectExtension;
import com.intellij.openapi.util.DefaultJDOMExternalizer;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.WriteExternalException;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.pom.java.LanguageLevel;
import com.intellij.psi.*;
import com.intellij.psi.util.TypeConversionUtil;
import com.intellij.ui.SimpleTextAttributes;
import com.intellij.util.IncorrectOperationException;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.xdebugger.XExpression;
import com.intellij.xdebugger.frame.XCompositeNode;
import com.intellij.xdebugger.frame.XDebuggerTreeNodeHyperlink;
import com.intellij.xdebugger.frame.XValueChildrenList;
import com.intellij.xdebugger.impl.ui.tree.XDebuggerTree;
import com.intellij.xdebugger.impl.ui.tree.nodes.XValueNodeImpl;
import com.sun.jdi.*;
import one.util.streamex.StreamEx;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;

import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import java.awt.event.MouseEvent;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

public class ArrayRenderer extends NodeRendererImpl {
  private static final Logger LOG = Logger.getInstance(ArrayRenderer.class);

  public static final @NonNls String UNIQUE_ID = "ArrayRenderer";

  public int START_INDEX = 0;
  public int END_INDEX = Integer.MAX_VALUE;
  public int ENTRIES_LIMIT = XCompositeNode.MAX_CHILDREN_TO_SHOW;

  private boolean myForced = false;

  public ArrayRenderer() {
    super(DEFAULT_NAME, true);
  }

  @Override
  public String getUniqueId() {
    return UNIQUE_ID;
  }

  @Override
  public @NonNls String getName() {
    return "Array";
  }

  @Override
  public void setName(String text) {
    LOG.assertTrue(false);
  }

  @Override
  public ArrayRenderer clone() {
    return (ArrayRenderer)super.clone();
  }

  @Override
  public String calcLabel(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener listener)
    throws EvaluateException {
    if (!Registry.is("debugger.renderers.arrays") ||
        OnDemandRenderer.isOnDemandForced((DebugProcessImpl)evaluationContext.getDebugProcess())) {
      return ClassRenderer.calcLabel(descriptor, evaluationContext);
    }

    Value value = descriptor.getValue();
    if (value == null) {
      return "null";
    }
    else if (value instanceof ArrayReference arrValue) {
      String componentTypeName = ((ArrayType)arrValue.type()).componentTypeName();
      boolean isString = CommonClassNames.JAVA_LANG_STRING.equals(componentTypeName);
      if (TypeConversionUtil.isPrimitive(componentTypeName) || isString) {
        CompletableFuture<String> asyncLabel = DebuggerUtilsAsync.length(arrValue)
          .thenCompose(length -> {
            if (length > 0) {
              int shownLength = Math.min(length, Registry.intValue(
                isString ? "debugger.renderers.arrays.max.strings" : "debugger.renderers.arrays.max.primitives"));
              return DebuggerUtilsAsync.getValues(arrValue, 0, shownLength).thenCompose(values -> {
                CompletableFuture<String>[] futures = ContainerUtil.map2Array(values, new CompletableFuture[0], ArrayRenderer::getElementAsString);
                return CompletableFuture.allOf(futures).thenApply(__ -> {
                  List<String> elements = ContainerUtil.map(futures, CompletableFuture::join);
                  if (descriptor instanceof ValueDescriptorImpl) {
                    int compactLength = Math.min(shownLength, isString ? 5 : 10);
                    String compact =
                      createLabel(elements.subList(0, compactLength), length - values.size() + (shownLength - compactLength));
                    ((ValueDescriptorImpl)descriptor).setCompactValueLabel(compact);
                  }
                  return createLabel(elements, length - values.size());
                });
              });
            }
            return CompletableFuture.completedFuture("[]");
          });
        if (asyncLabel.isDone()) {
          return asyncLabel.join();
        }
        else {
          asyncLabel.thenAccept(res -> {
            descriptor.setValueLabel(res);
            listener.labelChanged();
          });
        }
      }
      return "";
    }
    return JavaDebuggerBundle.message("label.undefined");
  }

  private static String createLabel(List<String> elements, int remaining) {
    StreamEx<String> strings = StreamEx.of(elements);
    if (remaining > 0) {
      strings = strings.append(JavaDebuggerBundle.message("message.node.array.elements.more", remaining));
    }
    return strings.joining(", ", "[", "]");
  }

  private static CompletableFuture<String> getElementAsString(Value value) {
    if (value instanceof StringReference) {
      return DebuggerUtilsAsync.getStringValue((StringReference)value).thenApply(e -> "\"" + StringUtil.first(e, 15, true) + "\"");
    }
    return CompletableFuture.completedFuture(value != null ? value.toString() : "null");
  }

  public void setForced(boolean forced) {
    myForced = forced;
  }

  @Override
  public void buildChildren(Value value, ChildrenBuilder builder, EvaluationContext evaluationContext) {
    DebuggerManagerThreadImpl.assertIsManagerThread();

    ArrayReference array = (ArrayReference)value;
    DebuggerUtilsAsync.length(array)
      .thenAccept(arrayLength -> {
        if (arrayLength > 0) {
          if (!myForced) {
            builder.initChildrenArrayRenderer(this, arrayLength);
          }

          if (ENTRIES_LIMIT <= 0) {
            ENTRIES_LIMIT = 1;
          }

          AtomicInteger added = new AtomicInteger();
          AtomicBoolean hiddenNulls = new AtomicBoolean();

          addChunk(array, START_INDEX, Math.min(arrayLength - 1, END_INDEX), arrayLength, builder, evaluationContext, added, hiddenNulls);
        }
      });
  }

  private CompletableFuture<Void> addChunk(ArrayReference array,
                                           int start,
                                           int end,
                                           int length,
                                           ChildrenBuilder builder,
                                           EvaluationContext evaluationContext,
                                           AtomicInteger added,
                                           AtomicBoolean hiddenNulls) {
    int chunkLength = Math.min(XCompositeNode.MAX_CHILDREN_TO_SHOW, end - start + 1);
    return DebuggerUtilsAsync.getValues(array, start, chunkLength)
      .thenCompose(values -> {
        int idx = start;
        for (; idx < start + values.size(); idx++) {
          Value val = values.get(idx - start);
          if (ViewsGeneralSettings.getInstance().HIDE_NULL_ARRAY_ELEMENTS && val == null) {
            hiddenNulls.set(true);
            continue;
          }

          ArrayElementDescriptorImpl descriptor = (ArrayElementDescriptorImpl)builder.getDescriptorManager()
            .getArrayItemDescriptor(builder.getParentDescriptor(), array, idx);
          descriptor.setValue(val);
          DebuggerTreeNode arrayItemNode = ((NodeManagerImpl)builder.getNodeManager()).createNode(descriptor, evaluationContext);
          builder.addChildren(Collections.singletonList(arrayItemNode), false);

          if (added.incrementAndGet() >= ENTRIES_LIMIT) {
            break;
          }
        }
        // process next chunk if needed
        if (idx < end && added.get() < ENTRIES_LIMIT) {
          return addChunk(array, idx, end, length, builder, evaluationContext, added, hiddenNulls);
        }
        finish(builder, length, added.get(), hiddenNulls.get(), end, idx);
        return CompletableFuture.completedFuture(null);
      });
  }

  private void finish(ChildrenBuilder builder, int arrayLength, int added, boolean hiddenNulls, int end, int idx) {
    builder.addChildren(Collections.emptyList(), true);

    if (added == 0) {
      if (START_INDEX == 0 && arrayLength - 1 <= END_INDEX) {
        builder
          .setMessage(JavaDebuggerBundle.message("message.node.all.elements.null"), null, SimpleTextAttributes.REGULAR_ATTRIBUTES,
                      null);
      }
      else {
        builder.setMessage(JavaDebuggerBundle.message("message.node.all.array.elements.null", START_INDEX, END_INDEX), null,
                           SimpleTextAttributes.REGULAR_ATTRIBUTES, null);
      }
    }
    else {
      if (hiddenNulls) {
        builder
          .setMessage(JavaDebuggerBundle.message("message.node.elements.null.hidden"), null, SimpleTextAttributes.REGULAR_ATTRIBUTES,
                      null);
      }
      if (!myForced && idx < end) {
        builder.tooManyChildren(end - idx);
      }
    }
  }

  private static final class ArrayValuesCache {
    private final ArrayReference myArray;
    private List<Value> myCachedValues = Collections.emptyList();
    private int myCachedStartIndex;

    private ArrayValuesCache(ArrayReference array) {
      myArray = array;
    }

    Value getValue(int index) {
      if (index < myCachedStartIndex || index >= myCachedStartIndex + myCachedValues.size()) {
        myCachedStartIndex = index;
        myCachedValues = myArray.getValues(index, Math.min(XCompositeNode.MAX_CHILDREN_TO_SHOW, myArray.length() - index));
      }
      return myCachedValues.get(index - myCachedStartIndex);
    }
  }

  @Override
  public void readExternal(Element element) throws InvalidDataException {
    super.readExternal(element);
    DefaultJDOMExternalizer.readExternal(this, element);
  }

  @Override
  public void writeExternal(Element element) throws WriteExternalException {
    super.writeExternal(element);
    DefaultJDOMExternalizer.writeExternal(this, element);
  }

  @Override
  public PsiExpression getChildValueExpression(DebuggerTreeNode node, DebuggerContext context) {
    LOG.assertTrue(node.getDescriptor() instanceof ArrayElementDescriptorImpl, node.getDescriptor().getClass().getName());
    ArrayElementDescriptorImpl descriptor = (ArrayElementDescriptorImpl)node.getDescriptor();

    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(node.getProject());
    try {
      LanguageLevel languageLevel = LanguageLevelProjectExtension.getInstance(node.getProject()).getLanguageLevel();
      return elementFactory.createExpressionFromText("this[" + descriptor.getIndex() + "]", elementFactory.getArrayClass(languageLevel));
    }
    catch (IncorrectOperationException e) {
      LOG.error(e);
      return null;
    }
  }

  @Override
  public CompletableFuture<Boolean> isExpandableAsync(Value value, EvaluationContext evaluationContext, NodeDescriptor parentDescriptor) {
    if (!(value instanceof ArrayReference)) {
      return CompletableFuture.completedFuture(false);
    }
    return DebuggerUtilsAsync.length(((ArrayReference)value)).thenApply(l -> l > 0);
  }

  @Override
  public boolean isApplicable(Type type) {
    return type instanceof ArrayType;
  }

  //TODO: make async
  public static class Filtered extends ArrayRenderer {
    private final XExpression myExpression;

    public Filtered(XExpression expression) {
      myExpression = expression;
    }

    public XExpression getExpression() {
      return myExpression;
    }

    @Override
    public void buildChildren(Value value, ChildrenBuilder builder, EvaluationContext evaluationContext) {
      DebuggerManagerThreadImpl.assertIsManagerThread();
      NodeManagerImpl nodeManager = (NodeManagerImpl)builder.getNodeManager();
      NodeDescriptorFactory descriptorFactory = builder.getDescriptorManager();

      builder.setMessage(JavaDebuggerBundle.message("message.node.filtered") + " " + myExpression.getExpression(),
                         AllIcons.General.Filter,
                         SimpleTextAttributes.REGULAR_ATTRIBUTES,
                         FILTER_HYPERLINK);

      if (ENTRIES_LIMIT <= 0) {
        ENTRIES_LIMIT = 1;
      }

      ArrayReference array = (ArrayReference)value;
      int arrayLength = array.length();
      if (arrayLength > 0) {
        builder.initChildrenArrayRenderer(this, arrayLength);

        CachedEvaluator cachedEvaluator = new CachedEvaluator() {
          @Override
          protected String getClassName() {
            return ((ArrayType)array.type()).componentTypeName();
          }

          @Override
          protected PsiElement overrideContext(PsiElement context) {
            return ContextUtil.getContextElement(evaluationContext);
          }
        };
        cachedEvaluator.setReferenceExpression(TextWithImportsImpl.fromXExpression(myExpression));

        try {
          int added = 0;
          if (arrayLength - 1 >= START_INDEX) {

            ErrorsValueGroup errorsGroup = null;
            ArrayValuesCache arrayValuesCache = new ArrayValuesCache(array);
            for (int idx = START_INDEX; idx < arrayLength; idx++) {
              ArrayElementDescriptorImpl descriptor =
                (ArrayElementDescriptorImpl)descriptorFactory.getArrayItemDescriptor(builder.getParentDescriptor(), array, idx);
              Value val = arrayValuesCache.getValue(idx);
              descriptor.setValue(val);
              try {
                if (DebuggerUtilsEx.evaluateBoolean(cachedEvaluator.getEvaluator(evaluationContext.getProject()),
                                                    (EvaluationContextImpl)evaluationContext.createEvaluationContext(val))) {

                  DebuggerTreeNode arrayItemNode = nodeManager.createNode(descriptor, evaluationContext);
                  builder.addChildren(Collections.singletonList(arrayItemNode), false);
                  added++;
                  //if (added > ENTRIES_LIMIT) {
                  //  break;
                  //}
                }
              }
              catch (EvaluateException e) {
                if (errorsGroup == null) {
                  errorsGroup = new ErrorsValueGroup();
                  builder.addChildren(XValueChildrenList.bottomGroup(errorsGroup), false);
                }
                JavaValue childValue = JavaValue.create(null, descriptor, ((EvaluationContextImpl)evaluationContext), nodeManager, false);
                errorsGroup.addErrorValue(e.getMessage(), childValue);
              }
            }
          }

          builder.addChildren(Collections.emptyList(), true);
        }
        catch (ObjectCollectedException e) {
          builder.setErrorMessage(JavaDebuggerBundle.message("evaluation.error.array.collected"));
        }

        //if (added != 0 && END_INDEX < arrayLength - 1) {
        //  builder.setRemaining(arrayLength - 1 - END_INDEX);
        //}
      }
    }

    public static final XDebuggerTreeNodeHyperlink FILTER_HYPERLINK = new XDebuggerTreeNodeHyperlink(
      JavaDebuggerBundle.message("array.filter.node.clear.link")) {
      @Override
      public void onClick(MouseEvent e) {
        XDebuggerTree tree = (XDebuggerTree)e.getSource();
        TreePath path = tree.getPathForLocation(e.getX(), e.getY());
        if (path != null) {
          TreeNode parent = ((TreeNode)path.getLastPathComponent()).getParent();
          if (parent instanceof XValueNodeImpl valueNode) {
            ArrayAction.setArrayRenderer(NodeRendererSettings.getInstance().getArrayRenderer(),
                                         valueNode,
                                         DebuggerManagerEx.getInstanceEx(tree.getProject()).getContext());
          }
        }
        e.consume();
      }
    };
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.util.JDOMExternalizerUtil;
import com.intellij.openapi.util.NlsSafe;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public final class BasicRendererProperties implements Cloneable {
  private static final Logger LOG = Logger.getInstance(BasicRendererProperties.class);

  private static final @NonNls String NAME_OPTION = "NAME";
  private String myName;

  private static final @NonNls String ENABLED_OPTION = "ENABLED";
  private boolean myEnabled;

  private static final @NonNls String CLASSNAME_OPTION = "QUALIFIED_NAME";
  private String myClassName;

  private static final @NonNls String SHOW_TYPE_OPTION = "SHOW_TYPE";
  private boolean myShowType = true;

  private final boolean myEnabledDefaultValue;

  public BasicRendererProperties(boolean enabledDefaultValue) {
    myEnabledDefaultValue = enabledDefaultValue;
  }

  public @NlsSafe String getName() {
    return myName;
  }

  public void setName(final String name) {
    myName = name;
  }

  public boolean isEnabled() {
    return myEnabled;
  }

  public void setEnabled(final boolean enabled) {
    myEnabled = enabled;
  }

  public String getClassName() {
    return myClassName;
  }

  public void setClassName(final String className) {
    myClassName = className;
  }

  public boolean isShowType() {
    return myShowType;
  }

  public void setShowType(boolean showType) {
    myShowType = showType;
  }

  public void readExternal(@NotNull Element element, @Nullable String defaultName) {
    myName = null;
    myClassName = null;
    for (Element option : element.getChildren("option")) {
      final String optionName = option.getAttributeValue("name");
      switch (optionName) {
        case NAME_OPTION -> myName = option.getAttributeValue("value");
        case ENABLED_OPTION -> {
          // default is false
          String value = option.getAttributeValue("value");
          if (value != null) {
            myEnabled = Boolean.parseBoolean(value);
          }
        }
        case CLASSNAME_OPTION -> myClassName = option.getAttributeValue("value");
        case SHOW_TYPE_OPTION ->
          // default is true
          myShowType = !"false".equalsIgnoreCase(option.getAttributeValue("value"));
      }
    }

    if (myName == null) {
      myName = defaultName;
    }
  }

  public void writeExternal(@NotNull Element element, @Nullable String defaultName) {
    if (myName != null && !myName.equals(defaultName)) {
      JDOMExternalizerUtil.writeField(element, NAME_OPTION, myName);
    }
    if (myEnabled != myEnabledDefaultValue) {
      JDOMExternalizerUtil.writeField(element, ENABLED_OPTION, Boolean.toString(myEnabled));
    }
    if (myClassName != null) {
      JDOMExternalizerUtil.writeField(element, CLASSNAME_OPTION, myClassName);
    }
    if (!myShowType) {
      // default is true
      //noinspection ConstantConditions
      JDOMExternalizerUtil.writeField(element, SHOW_TYPE_OPTION, Boolean.toString(myShowType));
    }
  }

  @Override
  public BasicRendererProperties clone() {
    try {
      return (BasicRendererProperties)super.clone();
    }
    catch (CloneNotSupportedException e) {
      LOG.error(e);
    }
    return null;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.*;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.jdi.ThreadReferenceProxy;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.impl.DebuggerUtilsImpl;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.registry.Registry;
import com.intellij.rt.debugger.BatchEvaluatorServer;
import com.intellij.util.containers.ContainerUtil;
import com.jetbrains.jdi.MethodImpl;
import com.sun.jdi.*;
import org.jetbrains.annotations.NotNull;

import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

public final class BatchEvaluator {
  private static final Logger LOG = Logger.getInstance(BatchEvaluator.class);

  private final DebugProcess myDebugProcess;
  private boolean myBatchEvaluatorChecked;
  private ClassType myBatchEvaluatorClass;
  private Method myBatchEvaluatorMethod;

  private static final Key<BatchEvaluator> BATCH_EVALUATOR_KEY = new Key<>("BatchEvaluator");
  public static final Key<Boolean> REMOTE_SESSION_KEY = new Key<>("is_remote_session_key");

  private final HashMap<SuspendContext, List<ToStringCommand>> myBuffer = new HashMap<>();

  private BatchEvaluator(DebugProcess process) {
    myDebugProcess = process;
    myDebugProcess.addDebugProcessListener(new DebugProcessListener() {
      @Override
      public void processDetached(@NotNull DebugProcess process, boolean closedByUser) {
        myBatchEvaluatorChecked = false;
        myBatchEvaluatorClass = null;
        myBatchEvaluatorMethod = null;
      }
    });
  }

  public boolean hasBatchEvaluator(EvaluationContext evaluationContext) {
    if (!myBatchEvaluatorChecked) {
      myBatchEvaluatorChecked = true;
      if (DebuggerUtilsImpl.isRemote(myDebugProcess)) {
        // optimization: for remote sessions the BatchEvaluator is not there for sure
        return false;
      }

      ThreadReferenceProxy thread = evaluationContext.getSuspendContext().getThread();

      if (thread == null) {
        return false;
      }

      ThreadReference threadReference = thread.getThreadReference();
      if (threadReference == null) {
        return false;
      }

      try {
        myBatchEvaluatorClass = (ClassType)myDebugProcess.findClass(evaluationContext, BatchEvaluatorServer.class.getName(),
                                                                    evaluationContext.getClassLoader());
      }
      catch (EvaluateException ignored) {
      }

      if (myBatchEvaluatorClass != null) {
        myBatchEvaluatorMethod = DebuggerUtils.findMethod(myBatchEvaluatorClass, "evaluate", "([Ljava/lang/Object;)Ljava/lang/String;");
      }
    }
    return myBatchEvaluatorMethod != null;
  }

  public void invoke(ToStringCommand command) {
    DebuggerManagerThreadImpl.assertIsManagerThread();

    final EvaluationContext evaluationContext = command.getEvaluationContext();
    final SuspendContext suspendContext = evaluationContext.getSuspendContext();

    if (!Registry.is("debugger.batch.evaluation.force") &&
        (!Registry.is("debugger.batch.evaluation") || !hasBatchEvaluator(evaluationContext))) {
      myDebugProcess.getManagerThread().invokeCommand(command);
    }
    else {
      List<ToStringCommand> toStringCommands = myBuffer.get(suspendContext);
      if (toStringCommands == null) {
        toStringCommands = new ArrayList<>();
        myBuffer.put(suspendContext, toStringCommands);
        ((DebuggerManagerThreadImpl)myDebugProcess.getManagerThread()).schedule(new BatchEvaluatorCommand(evaluationContext));
      }

      toStringCommands.add(command);
    }
  }

  public static BatchEvaluator getBatchEvaluator(DebugProcess debugProcess) {
    BatchEvaluator batchEvaluator = debugProcess.getUserData(BATCH_EVALUATOR_KEY);

    if (batchEvaluator == null) {
      batchEvaluator = new BatchEvaluator(debugProcess);
      debugProcess.putUserData(BATCH_EVALUATOR_KEY, batchEvaluator);
    }
    return batchEvaluator;
  }

  private boolean doEvaluateBatch(List<ToStringCommand> requests, EvaluationContext evaluationContext) {
    try {
      if (!hasBatchEvaluator(evaluationContext)) {
        return false;
      }
      DebugProcess debugProcess = evaluationContext.getDebugProcess();
      List<Value> values = ContainerUtil.map(requests, ToStringCommand::getValue);

      ArrayType objectArrayClass = (ArrayType)debugProcess.findClass(
        evaluationContext,
        "java.lang.Object[]",
        evaluationContext.getClassLoader());
      if (objectArrayClass == null) {
        return false;
      }

      ArrayReference argArray = DebuggerUtilsEx.mirrorOfArray(objectArrayClass, values.size(), evaluationContext);
      DebuggerUtilsEx.setValuesNoCheck(argArray, values);
      String value = DebuggerUtils.processCollectibleValue(
        () -> ((DebugProcessImpl)debugProcess).invokeMethod(
          evaluationContext, myBatchEvaluatorClass, myBatchEvaluatorMethod, Collections.singletonList(argArray),
          MethodImpl.SKIP_ASSIGNABLE_CHECK, true),
        result -> result instanceof StringReference ? ((StringReference)result).value() : null
      );
      if (value != null) {
        byte[] bytes = value.getBytes(StandardCharsets.ISO_8859_1);
        try (DataInputStream dis = new DataInputStream(new ByteArrayInputStream(bytes))) {
          int count = 0;
          while (dis.available() > 0) {
            boolean error = dis.readBoolean();
            String message = dis.readUTF();
            if (count >= requests.size()) {
              LOG.error("Invalid number of results: required " + requests.size() + ", reply = " + Arrays.toString(bytes));
              return false;
            }
            ToStringCommand command = requests.get(count++);
            if (error) {
              command.evaluationError(JavaDebuggerBundle.message("evaluation.error.method.exception", message));
            }
            else {
              command.evaluationResult(message);
            }
          }
        }
        catch (IOException e) {
          LOG.error("Failed to read batch response", e, "reply was " + Arrays.toString(bytes));
          return false;
        }
        return true;
      }
    }
    catch (ClassNotLoadedException | ObjectCollectedException | EvaluateException | InvalidTypeException e) {
      LOG.debug(e);
    }
    return false;
  }

  private class BatchEvaluatorCommand extends PossiblySyncCommand {
    private final EvaluationContext myEvaluationContext;

    BatchEvaluatorCommand(EvaluationContext evaluationContext) {
      super((SuspendContextImpl)evaluationContext.getSuspendContext());
      myEvaluationContext = evaluationContext;
    }

    @Override
    public void syncAction(@NotNull SuspendContextImpl suspendContext) {
      List<ToStringCommand> commands = myBuffer.remove(suspendContext);

      if ((commands.size() == 1 && !Registry.is("debugger.batch.evaluation.force")) || !doEvaluateBatch(commands, myEvaluationContext)) {
        commands.forEach(ToStringCommand::action);
      }
    }

    @Override
    public void commandCancelled() {
      myBuffer.remove(getSuspendContext());
    }
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.openapi.diagnostic.Logger;
import com.sun.jdi.*;

import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

public class BinaryRenderer extends CompoundRendererProvider {
  private static final Logger LOG = Logger.getInstance(BinaryRenderer.class);

  @Override
  protected String getName() {
    return "Binary";
  }

  @Override
  protected ValueLabelRenderer getValueLabelRenderer() {
    return new LabelRenderer() {
      @Override
      public String calcLabel(ValueDescriptor valueDescriptor,
                              EvaluationContext evaluationContext,
                              DescriptorLabelListener labelListener) {
        Value value = valueDescriptor.getValue();

        if (value == null) {
          return "null";
        }

        StringBuilder buf = new StringBuilder("0b");
        int prefixLength = buf.length();
        String valueStr = "";
        if (value instanceof ByteValue) {
          valueStr = Integer.toBinaryString(0xff & ((ByteValue)value).byteValue());
        }
        else if (value instanceof ShortValue) {
          valueStr = Integer.toBinaryString(0xffff & ((ShortValue)value).shortValue());
        }
        else if (value instanceof IntegerValue) {
          valueStr = Integer.toBinaryString(((PrimitiveValue)value).intValue());
        }
        else if (value instanceof LongValue) {
          valueStr = Long.toBinaryString(((LongValue)value).longValue());
        }
        else {
          LOG.error("Unsupported value " + value);
        }

        // add leading zeros
        int remainder = valueStr.length() % 8;
        if (remainder != 0) {
          buf.append("0".repeat(8 - remainder));
        }

        buf.append(valueStr);

        // group by 8
        for (int i = buf.length() - 8; i > prefixLength; i -= 8) {
          buf.insert(i, '_');
        }
        return buf.toString();
      }
    };
  }

  @Override
  protected Function<Type, CompletableFuture<Boolean>> getIsApplicableChecker() {
    return t -> {
      if (t == null) {
        return CompletableFuture.completedFuture(false);
      }
      return CompletableFuture.completedFuture(t instanceof ByteType ||
                                               t instanceof ShortType ||
                                               t instanceof IntegerType ||
                                               t instanceof LongType);
    };
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.evaluation.*;
import com.intellij.debugger.impl.DebuggerUtilsImpl;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.sun.jdi.ArrayReference;
import com.sun.jdi.Value;

import java.nio.charset.StandardCharsets;

final class ByteArrayAsStringRenderer extends CompoundRendererProvider {
  @Override
  protected String getName() {
    return "String";
  }

  @Override
  protected String getClassName() {
    return "byte[]";
  }

  @Override
  protected ValueLabelRenderer getValueLabelRenderer() {
    LabelRenderer labelRenderer = new LabelRenderer() {
      @Override
      public String calcLabel(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener labelListener)
        throws EvaluateException {
        if (evaluationContext instanceof EvaluationContextImpl && !((EvaluationContextImpl)evaluationContext).isEvaluationPossible()) {
          Value value = descriptor.getValue();
          if (value instanceof ArrayReference) {
            // TODO: read charset from the target vm
            byte[] bytes = DebuggerUtilsImpl.readBytesArray(value);
            if (bytes != null) {
              return new String(bytes, StandardCharsets.UTF_8);
            }
          }
        }
        return super.calcLabel(descriptor, evaluationContext, labelListener);
      }
    };
    labelRenderer.setLabelExpression(new TextWithImportsImpl(CodeFragmentKind.EXPRESSION, "new String(this)"));
    return labelRenderer;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.evaluation.CodeFragmentFactory;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil;
import com.intellij.debugger.engine.evaluation.TextWithImports;
import com.intellij.debugger.engine.evaluation.expression.ExpressionEvaluator;
import com.intellij.debugger.engine.evaluation.expression.UnsupportedExpressionException;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.impl.DebuggerUtilsImpl;
import com.intellij.debugger.ui.impl.watch.CompilingEvaluatorImpl;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Pair;
import com.intellij.psi.*;
import org.jetbrains.annotations.Nullable;

import java.lang.ref.SoftReference;

public abstract class CachedEvaluator {
  private static class Cache {
    protected ExpressionEvaluator myEvaluator;
    protected EvaluateException myException;
    protected PsiExpression myPsiChildrenExpression;
  }

  SoftReference<Cache> myCache = new SoftReference<>(null);
  private TextWithImports myReferenceExpression;

  protected abstract String getClassName();

  public TextWithImports getReferenceExpression() {
    return myReferenceExpression != null ? myReferenceExpression : DebuggerUtils.getInstance().createExpressionWithImports("");
  }

  public void setReferenceExpression(TextWithImports referenceExpression) {
    myReferenceExpression = referenceExpression;
    clear();
  }

  public void clear() {
    myCache.clear();
  }

  protected Cache initEvaluatorAndChildrenExpression(final Project project) {
    final Cache cache = new Cache();
    try {
      String className = getClassName();
      Pair<PsiElement, PsiType> psiClassAndType = DebuggerUtilsImpl.getPsiClassAndType(className, project);
      PsiElement context = psiClassAndType.first;
      if (context == null) {
        throw EvaluateExceptionUtil.createEvaluateException(JavaDebuggerBundle.message("evaluation.error.cannot.find.source", className));
      }
      CodeFragmentFactory factory = DebuggerUtilsEx.findAppropriateCodeFragmentFactory(myReferenceExpression, context);
      JavaCodeFragment codeFragment = factory.createCodeFragment(myReferenceExpression, overrideContext(context), project);
      codeFragment.setThisType(psiClassAndType.second);
      DebuggerUtils.checkSyntax(codeFragment);
      cache.myPsiChildrenExpression = codeFragment instanceof PsiExpressionCodeFragment ? ((PsiExpressionCodeFragment)codeFragment).getExpression() : null;

      try {
        cache.myEvaluator = factory.getEvaluatorBuilder().build(codeFragment, null);
      }
      catch (UnsupportedExpressionException ex) {
        ExpressionEvaluator eval = CompilingEvaluatorImpl.create(project, context, element -> codeFragment);
        if (eval != null) {
          cache.myEvaluator = eval;
        }
        else {
          throw ex;
        }
      }
    }
    catch (EvaluateException e) {
      cache.myException = e;
    }

    myCache = new SoftReference<>(cache);
    return cache;
  }

  protected PsiElement overrideContext(PsiElement context) {
    return context;
  }

  protected ExpressionEvaluator getEvaluator(final Project project) throws EvaluateException {
    Cache cache = myCache.get();
    if (cache == null) {
      cache = PsiDocumentManager.getInstance(project).commitAndRunReadAction(() -> initEvaluatorAndChildrenExpression(project));
    }

    if (cache.myException != null) {
      throw cache.myException;
    }

    return cache.myEvaluator;
  }

  @Nullable
  protected PsiExpression getPsiExpression(final Project project) {
    Cache cache = myCache.get();
    if (cache == null) {
      cache = initEvaluatorAndChildrenExpression(project);
    }

    return cache.myPsiChildrenExpression;
  }
}
/*
 * Copyright 2000-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.ui.tree.DebuggerTreeNode;
import com.intellij.debugger.ui.tree.NodeDescriptorFactory;
import com.intellij.debugger.ui.tree.NodeManager;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.xdebugger.frame.XCompositeNode;

import java.util.List;

public interface ChildrenBuilder extends XCompositeNode {
  NodeDescriptorFactory getDescriptorManager();

  NodeManager getNodeManager();

  ValueDescriptor getParentDescriptor();

  void setChildren(List<? extends DebuggerTreeNode> children);

  default void addChildren(List<? extends DebuggerTreeNode> children, boolean last) {
    setChildren(children);
  }

  void initChildrenArrayRenderer(ArrayRenderer renderer, int arrayLength);
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.ui.tree.DebuggerTreeNode;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.psi.PsiElement;
import com.sun.jdi.Value;

import java.util.concurrent.CompletableFuture;

public interface ChildrenRenderer extends Renderer {
  void buildChildren(Value value, ChildrenBuilder builder, EvaluationContext evaluationContext);

  /**
   * <pre>
   * - parentNode
   *    + ..
   *    + node
   *    + ...
   * </pre>
   * is invoked on the renderer of the parentNode
   *
   * @param node a child node
   * @return expression that evaluates the child node.
   * Use 'this' to refer the expression that evaluates this (parent) node
   */
  PsiElement getChildValueExpression(DebuggerTreeNode node, DebuggerContext context) throws EvaluateException;

  /**
   * @deprecated override {@link #isExpandableAsync(Value, EvaluationContext, NodeDescriptor)}
   */
  @Deprecated
  default boolean isExpandable(Value value, EvaluationContext evaluationContext, NodeDescriptor parentDescriptor) {
    throw new AbstractMethodError("isExpandableAsync is not implemented");
  }

  default CompletableFuture<Boolean> isExpandableAsync(Value value, EvaluationContext evaluationContext, NodeDescriptor parentDescriptor) {
    return CompletableFuture.completedFuture(isExpandable(value, evaluationContext, parentDescriptor));
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.FullValueEvaluatorProvider;
import com.intellij.debugger.engine.JavaValue;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.psi.PsiClass;
import com.intellij.xdebugger.impl.ui.DebuggerUIUtil;
import com.sun.jdi.*;
import org.jetbrains.annotations.NotNull;

import java.util.Collections;

class ClassObjectRenderer extends CompoundRendererProvider {
  private static final Logger LOG = Logger.getInstance(ClassObjectRenderer.class);

  @Override
  protected String getName() {
    return "Class";
  }

  @Override
  protected String getClassName() {
    return "java.lang.Class";
  }

  @Override
  protected boolean isEnabled() {
    return true;
  }

  @Override
  protected FullValueEvaluatorProvider getFullValueEvaluatorProvider() {
    return (evaluationContext, valueDescriptor) ->
      new JavaValue.JavaFullValueEvaluator(JavaDebuggerBundle.message("message.node.navigate"), evaluationContext) {
        @Override
        public void evaluate(@NotNull XFullValueEvaluationCallback callback) {
          Value value = valueDescriptor.getValue();
          ClassType type = ((ClassType)value.type());
          Method nameMethod = DebuggerUtils.findMethod(type, "getName", "()Ljava/lang/String;");
          if (nameMethod != null) {
            try {
              final DebugProcessImpl process = evaluationContext.getDebugProcess();
              Value res = process.invokeMethod(evaluationContext, (ObjectReference)value, nameMethod, Collections.emptyList());
              if (res instanceof StringReference) {
                callback.evaluated("");
                final String line = ((StringReference)res).value();
                ApplicationManager.getApplication().runReadAction(() -> {
                  final PsiClass psiClass = DebuggerUtils.findClass(line,
                                                                    valueDescriptor.getProject(),
                                                                    process.getSearchScope());
                  if (psiClass != null) {
                    DebuggerUIUtil.invokeLater(() -> psiClass.navigate(true));
                  }
                });
              }
            }
            catch (EvaluateException e) {
              LOG.info("Exception while getting type name", e);
            }
          }
        }

        @Override
        public boolean isShowValuePopup() {
          return false;
        }
      };
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebuggerManagerThreadImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.jdi.StackFrameProxy;
import com.intellij.debugger.impl.DebuggerUtilsAsync;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.impl.DebuggerUtilsImpl;
import com.intellij.debugger.ui.impl.watch.FieldDescriptorImpl;
import com.intellij.debugger.ui.impl.watch.MessageDescriptor;
import com.intellij.debugger.ui.impl.watch.ValueDescriptorImpl;
import com.intellij.debugger.ui.tree.*;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.util.*;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.CommonClassNames;
import com.intellij.psi.JavaPsiFacade;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiElementFactory;
import com.intellij.util.IncorrectOperationException;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.xdebugger.frame.XCompositeNode;
import com.intellij.xdebugger.impl.ui.XDebuggerUIConstants;
import com.jetbrains.jdi.StringReferenceImpl;
import com.sun.jdi.*;
import one.util.streamex.StreamEx;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;
import java.util.concurrent.CompletableFuture;

public class ClassRenderer extends NodeRendererImpl {
  private static final Logger LOG = Logger.getInstance(ClassRenderer.class);

  public static final @NonNls String UNIQUE_ID = "ClassRenderer";

  public boolean SHOW_SYNTHETICS = true;
  public boolean SHOW_VAL_FIELDS_AS_LOCAL_VARIABLES = true;
  public boolean SHOW_STATIC = false;
  public boolean SHOW_STATIC_FINAL = false;

  public boolean SHOW_FQ_TYPE_NAMES = false;
  public boolean SHOW_DECLARED_TYPE = false;
  public boolean SHOW_OBJECT_ID = true;

  public boolean SHOW_STRINGS_TYPE = false;

  public ClassRenderer() {
    super(DEFAULT_NAME, true);
  }

  @Nullable
  public final String renderTypeName(@Nullable final String typeName) {
    if (SHOW_FQ_TYPE_NAMES || typeName == null) {
      return typeName;
    }
    String baseLambdaClassName = DebuggerUtilsEx.getLambdaBaseClassName(typeName);
    if (baseLambdaClassName != null) {
      return renderTypeName(baseLambdaClassName) + "$lambda";
    }

    final int dotIndex = typeName.lastIndexOf('.');
    if (dotIndex > 0) {
      return typeName.substring(dotIndex + 1);
    }
    return typeName;
  }

  @Override
  public String getUniqueId() {
    return UNIQUE_ID;
  }

  @Override
  public ClassRenderer clone() {
    return (ClassRenderer)super.clone();
  }

  @Override
  public String calcLabel(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener labelListener)
    throws EvaluateException {
    return calcLabelAsync(descriptor, evaluationContext, labelListener);
  }

  private static String calcLabelAsync(ValueDescriptor descriptor,
                                       EvaluationContext evaluationContext,
                                       DescriptorLabelListener labelListener)
    throws EvaluateException {
    Value value = descriptor.getValue();
    CompletableFuture<String> future;
    if (value instanceof StringReferenceImpl) {
      DebuggerUtils.ensureNotInsideObjectConstructor((ObjectReference)value, evaluationContext);
      future = DebuggerUtilsAsync.getStringValue((StringReference)value);
    }
    else {
      future = CompletableFuture.completedFuture(calcLabel(descriptor, evaluationContext));
    }
    return calcLabelFromFuture(future, descriptor, labelListener);
  }

  private static String calcLabelFromFuture(CompletableFuture<String> future,
                                            ValueDescriptor descriptor,
                                            DescriptorLabelListener labelListener) {
    if (!future.isDone()) {
      future.whenComplete((s, throwable) -> {
        if (throwable != null) {
          descriptor.setValueLabelFailed((EvaluateException)throwable);
        }
        else {
          descriptor.setValueLabel(s);
        }
        labelListener.labelChanged();
      });
    }
    return future.getNow(XDebuggerUIConstants.getCollectingDataMessage());
  }

  protected static String calcLabel(ValueDescriptor descriptor, EvaluationContext evaluationContext) throws EvaluateException {
    Value value = descriptor.getValue();
    if (value instanceof ObjectReference) {
      if (value instanceof StringReference) {
        DebuggerUtils.ensureNotInsideObjectConstructor((ObjectReference)value, evaluationContext);
        return ((StringReference)value).value();
      }
      else if (value instanceof ClassObjectReference) {
        ReferenceType type = ((ClassObjectReference)value).reflectedType();
        return (type != null) ? type.name() : "{...}";
      }
      else {
        final ObjectReference objRef = (ObjectReference)value;
        final Type type = objRef.type();
        if (type instanceof ClassType && ((ClassType)type).isEnum()) {
          final String name = getEnumConstantName(objRef, (ClassType)type);
          if (name != null) {
            return name;
          }
          else {
            return type.name();
          }
        }
        else {
          return "";
        }
      }
    }
    else if (value == null) {
      return "null";
    }
    else {
      return JavaDebuggerBundle.message("label.undefined");
    }
  }

  @Override
  public void buildChildren(final Value value, final ChildrenBuilder builder, final EvaluationContext evaluationContext) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    final ValueDescriptorImpl parentDescriptor = (ValueDescriptorImpl)builder.getParentDescriptor();
    final NodeManager nodeManager = builder.getNodeManager();
    final NodeDescriptorFactory nodeDescriptorFactory = builder.getDescriptorManager();

    if (!(value instanceof ObjectReference objRef)) {
      builder.setChildren(Collections.emptyList());
      return;
    }

    final ReferenceType refType = objRef.referenceType();
    // default ObjectReference processing
    DebuggerUtilsAsync.allFields(refType)
      .thenAccept(fields -> {
          if (fields.isEmpty()) {
            builder.setChildren(Collections.singletonList(nodeManager.createMessageNode(MessageDescriptor.CLASS_HAS_NO_FIELDS.getLabel())));
            return;
          }

          createNodesToShow(fields, evaluationContext, parentDescriptor, nodeManager, nodeDescriptorFactory, objRef)
            .thenAccept(nodesToShow -> {
              if (nodesToShow.isEmpty()) {
                setClassHasNoFieldsToDisplayMessage(builder, nodeManager);
                return;
              }

              builder.setChildren(nodesToShow);
            }
          );
      }
    );
  }

  protected void setClassHasNoFieldsToDisplayMessage(ChildrenBuilder builder, NodeManager nodeManager) {
    builder.setChildren(Collections.singletonList(nodeManager.createMessageNode(JavaDebuggerBundle.message("message.node.class.no.fields.to.display"))));
  }

  protected CompletableFuture<List<DebuggerTreeNode>> createNodesToShow(List<Field> fields,
                                                                        EvaluationContext evaluationContext,
                                                                        ValueDescriptorImpl parentDescriptor,
                                                                        NodeManager nodeManager,
                                                                        NodeDescriptorFactory nodeDescriptorFactory,
                                                                        ObjectReference objRef) {
    List<Field> fieldsToShow = ContainerUtil.filter(fields, field -> shouldDisplay(evaluationContext, objRef, field));
    if (fieldsToShow.isEmpty()) {
      return CompletableFuture.completedFuture(Collections.emptyList());
    }

    CompletableFuture<List<DebuggerTreeNode>>[] futures = createNodesChunked(
      fieldsToShow, evaluationContext, parentDescriptor, nodeManager, nodeDescriptorFactory, objRef
    );

    return CompletableFuture.allOf(futures).thenApply(__ -> StreamEx.of(futures).flatCollection(CompletableFuture::join).toList());
  }

  private CompletableFuture<List<DebuggerTreeNode>>[] createNodesChunked(List<Field> fields,
                                                                         EvaluationContext evaluationContext,
                                                                         ValueDescriptorImpl parentDescriptor,
                                                                         NodeManager nodeManager,
                                                                         NodeDescriptorFactory nodeDescriptorFactory,
                                                                         ObjectReference objRef) {
    List<List<Field>> chunks = DebuggerUtilsImpl.partition(fields, XCompositeNode.MAX_CHILDREN_TO_SHOW);
    Set<String> names = Collections.synchronizedSet(new HashSet<>());
    //noinspection unchecked
    return chunks.stream()
      .map(l -> createNodes(l, evaluationContext, parentDescriptor, nodeManager, nodeDescriptorFactory, objRef, names))
      .toArray(CompletableFuture[]::new);
  }

  private CompletableFuture<List<DebuggerTreeNode>> createNodes(List<Field> fields,
                                                                EvaluationContext evaluationContext,
                                                                ValueDescriptorImpl parentDescriptor,
                                                                NodeManager nodeManager,
                                                                NodeDescriptorFactory nodeDescriptorFactory,
                                                                ObjectReference objRef,
                                                                Set<String> names) {
    return DebuggerUtilsAsync.getValues(objRef, fields)
      .thenApply(cachedValues -> {
        List<DebuggerTreeNode> res = new ArrayList<>(fields.size());
        for (Field field : fields) {
          FieldDescriptorImpl fieldDescriptor =
            (FieldDescriptorImpl)createFieldDescriptor(parentDescriptor, nodeDescriptorFactory, objRef, field, evaluationContext);
          if (cachedValues != null) {
            fieldDescriptor.setValue(cachedValues.get(field));
          }
          if (!names.add(fieldDescriptor.getName())) {
            fieldDescriptor.putUserData(FieldDescriptor.SHOW_DECLARING_TYPE, Boolean.TRUE);
          }
          res.add(nodeManager.createNode(fieldDescriptor, evaluationContext));
        }
        return res;
      });
  }

  @NotNull
  protected FieldDescriptor createFieldDescriptor(ValueDescriptorImpl parentDescriptor,
                                                  NodeDescriptorFactory nodeDescriptorFactory,
                                                  ObjectReference objRef,
                                                  Field field,
                                                  EvaluationContext evaluationContext) {
    return nodeDescriptorFactory.getFieldDescriptor(parentDescriptor, objRef, field);
  }

  protected boolean shouldDisplay(EvaluationContext context, @NotNull ObjectReference objInstance, @NotNull Field field) {
    final boolean isSynthetic = DebuggerUtils.isSynthetic(field);
    if (!SHOW_SYNTHETICS && isSynthetic) {
      return false;
    }
    if (SHOW_VAL_FIELDS_AS_LOCAL_VARIABLES && isSynthetic) {
      try {
        final StackFrameProxy frameProxy = context.getFrameProxy();
        if (frameProxy != null) {
          final Location location = frameProxy.location();
          if (location != null &&
              objInstance.equals(context.computeThisObject()) &&
              Comparing.equal(objInstance.referenceType(), location.declaringType()) &&
              StringUtil.startsWith(field.name(), FieldDescriptorImpl.OUTER_LOCAL_VAR_FIELD_PREFIX)) {
            return false;
          }
        }
      }
      catch (EvaluateException ignored) {
      }
    }
    if (!SHOW_STATIC && field.isStatic()) {
      return false;
    }

    if (!SHOW_STATIC_FINAL && field.isStatic() && field.isFinal()) {
      return false;
    }

    return true;
  }

  @Override
  public void readExternal(Element element) throws InvalidDataException {
    super.readExternal(element);
    DefaultJDOMExternalizer.readExternal(this, element);
  }

  @Override
  public void writeExternal(Element element) throws WriteExternalException {
    super.writeExternal(element);
    DefaultJDOMExternalizer.write(this, element, new DifferenceFilter<>(this, new ClassRenderer()));
  }

  @Override
  public PsiElement getChildValueExpression(DebuggerTreeNode node, DebuggerContext context) throws EvaluateException {
    DescriptorWithParentObject descriptor = (DescriptorWithParentObject)node.getDescriptor();

    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(node.getProject());
    try {
      return elementFactory.createExpressionFromText("this." + descriptor.getName(), DebuggerUtils.findClass(
        descriptor.getObject().referenceType().name(), context.getProject(), context.getDebugProcess().getSearchScope())
      );
    }
    catch (IncorrectOperationException e) {
      throw new EvaluateException(JavaDebuggerBundle.message("error.invalid.field.name", descriptor.getName()), null);
    }
  }

  @Override
  public CompletableFuture<Boolean> isExpandableAsync(Value value, EvaluationContext evaluationContext, NodeDescriptor parentDescriptor) {
    DebuggerManagerThreadImpl.assertIsManagerThread();
    if (value instanceof ArrayReference) {
      return DebuggerUtilsAsync.length((ArrayReference)value).thenApply(r -> r > 0).exceptionally(throwable -> true);
    }
    else if (value instanceof ObjectReference) {
      return CompletableFuture.completedFuture(true); // if object has no fields, it contains a child-message about that
      //return ((ObjectReference)value).referenceType().allFields().size() > 0;
    }

    return CompletableFuture.completedFuture(false);
  }

  @Override
  public boolean isApplicable(Type type) {
    return type instanceof ReferenceType && !(type instanceof ArrayType);
  }

  @Override
  public @NonNls String getName() {
    return "Object";
  }

  @Override
  public void setName(String text) {
    LOG.assertTrue(false);
  }

  @Nullable
  public static String getEnumConstantName(@NotNull ObjectReference objRef, ClassType classType) {
    do {
      if (!classType.isPrepared()) {
        return null;
      }
      classType = classType.superclass();
      if (classType == null) {
        return null;
      }
    }
    while (!(CommonClassNames.JAVA_LANG_ENUM.equals(classType.name())));
    final Field field = classType.fieldByName("name");
    if (field == null) {
      return null;
    }
    final Value value = objRef.getValue(field);
    if (!(value instanceof StringReference)) {
      return null;
    }
    return ((StringReference)value).value();
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.SuspendContextImpl;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.events.SuspendContextCommandImpl;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.ui.scale.JBUIScale;
import com.intellij.util.ui.ColorIcon;
import com.sun.jdi.*;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import java.awt.*;
import java.util.Collections;

class ColorObjectRenderer extends CompoundRendererProvider {
  private static final Logger LOG = Logger.getInstance(ColorObjectRenderer.class);

  @Override
  protected String getName() {
    return "Color";
  }

  @Override
  protected String getClassName() {
    return "java.awt.Color";
  }

  @Override
  protected ValueIconRenderer getIconRenderer() {
    return (descriptor, evaluationContext, listener) -> {
      Value value = descriptor.getValue();
      if (value instanceof ObjectReference) {
        try {
          ObjectReference objRef = (ObjectReference)value;
          ReferenceType refType = objRef.referenceType();
          if (refType instanceof ClassType) {
            Value rgbValue = null;
            Method getRGBMethod = DebuggerUtils.findMethod(refType, "getRGB", "()I");
            if (getRGBMethod != null) {
              ReferenceType rgbMethodDeclaringType = getRGBMethod.declaringType();
              if (rgbMethodDeclaringType.name().equals("java.awt.Color")) { // getRGB is not overridden
                Field valueField = rgbMethodDeclaringType.fieldByName("value");
                if (valueField != null) {
                  rgbValue = objRef.getValue(valueField);
                }
              }
              if (rgbValue instanceof IntegerValue) {
                return createIcon((IntegerValue)rgbValue);
              }
              else {
                EvaluationContextImpl evalContext = ((EvaluationContextImpl)evaluationContext);
                DebugProcessImpl debugProcess = evalContext.getDebugProcess();
                debugProcess.getManagerThread().schedule(new SuspendContextCommandImpl(evalContext.getSuspendContext()) {
                  @Override
                  public void contextAction(@NotNull SuspendContextImpl suspendContext) {
                    try {
                      Value rgbValue = debugProcess.invokeMethod(evaluationContext, objRef, getRGBMethod, Collections.emptyList());
                      if (rgbValue instanceof IntegerValue) {
                        descriptor.setValueIcon(createIcon((IntegerValue)rgbValue));
                        listener.labelChanged();
                      }
                    }
                    catch (EvaluateException e) {
                      LOG.info(e);
                    }
                  }
                });
              }
            }
          }
        }
        catch (Exception e) {
          throw new EvaluateException(e.getMessage(), e);
        }
      }
      return null;
    };
  }

  @Override
  protected boolean isEnabled() {
    return true;
  }

  private static Icon createIcon(IntegerValue rgbValue) {
    //noinspection UseJBColor
    return JBUIScale.scaleIcon(new ColorIcon(16, 12, new Color(rgbValue.value(), true), true));
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.engine.DebugProcess;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.FullValueEvaluatorProvider;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.debugger.ui.impl.watch.ValueDescriptorImpl;
import com.intellij.debugger.ui.tree.DebuggerTreeNode;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.WriteExternalException;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.CommonClassNames;
import com.intellij.psi.JavaPsiFacade;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiElementFactory;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.util.TypeConversionUtil;
import com.intellij.xdebugger.frame.XFullValueEvaluator;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.Type;
import com.sun.jdi.Value;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.util.concurrent.CompletableFuture;

/**
 * Do not extend, use {@link CompoundRendererProvider}
 */
public class CompoundReferenceRenderer extends NodeRendererImpl implements FullValueEvaluatorProvider {
  protected static final Logger LOG = Logger.getInstance(CompoundReferenceRenderer.class);
  private static final AutoToStringRenderer AUTO_TO_STRING_RENDERER = new AutoToStringRenderer();
  public static final @NonNls String UNIQUE_ID = "CompoundNodeRenderer";
  public static final @NonNls String UNIQUE_ID_OLD = "CompoundTypeRenderer";

  private ValueLabelRenderer myLabelRenderer;
  private ChildrenRenderer myChildrenRenderer;
  private ValueIconRenderer myIconRenderer = null;
  protected final NodeRendererSettings myRendererSettings;

  private FullValueEvaluatorProvider myFullValueEvaluatorProvider;

  public CompoundReferenceRenderer(NodeRendererSettings rendererSettings,
                                   String name,
                                   ValueLabelRenderer labelRenderer,
                                   ChildrenRenderer childrenRenderer) {
    super(name);
    myRendererSettings = rendererSettings;
    myLabelRenderer = labelRenderer;
    myChildrenRenderer = childrenRenderer;
    myProperties.setClassName(CommonClassNames.JAVA_LANG_OBJECT);
    LOG.assertTrue(labelRenderer == null || labelRenderer instanceof ReferenceRenderer || labelRenderer instanceof ClassRenderer);
    LOG.assertTrue(childrenRenderer == null || childrenRenderer instanceof ReferenceRenderer || childrenRenderer instanceof ClassRenderer);
  }

  public CompoundReferenceRenderer(String name, ValueLabelRenderer labelRenderer, ChildrenRenderer childrenRenderer) {
    this(NodeRendererSettings.getInstance(), name, labelRenderer, childrenRenderer);
  }

  @Override
  public void buildChildren(Value value, ChildrenBuilder builder, EvaluationContext evaluationContext) {
    getChildrenRenderer().buildChildren(value, builder, evaluationContext);
  }

  @Override
  public PsiElement getChildValueExpression(DebuggerTreeNode node, DebuggerContext context) throws EvaluateException {
    return getChildrenRenderer().getChildValueExpression(node, context);
  }

  @Override
  public CompletableFuture<Boolean> isExpandableAsync(Value value, EvaluationContext evaluationContext, NodeDescriptor parentDescriptor) {
    return getChildrenRenderer().isExpandableAsync(value, evaluationContext, parentDescriptor);
  }

  @Override
  public String calcLabel(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener listener)
    throws EvaluateException {
    return getLabelRenderer().calcLabel(descriptor, evaluationContext, listener);
  }

  @Override
  public @Nullable Icon calcValueIcon(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener listener)
    throws EvaluateException {
    if (myIconRenderer != null) {
      return myIconRenderer.calcValueIcon(descriptor, evaluationContext, listener);
    }
    return null;
  }

  void setIconRenderer(ValueIconRenderer iconRenderer) {
    myIconRenderer = iconRenderer;
  }

  @Override
  public @Nullable XFullValueEvaluator getFullValueEvaluator(EvaluationContextImpl evaluationContext, ValueDescriptorImpl valueDescriptor) {
    if (myFullValueEvaluatorProvider != null) {
      return myFullValueEvaluatorProvider.getFullValueEvaluator(evaluationContext, valueDescriptor);
    }
    return null;
  }

  void setFullValueEvaluator(FullValueEvaluatorProvider fullValueEvaluatorProvider) {
    myFullValueEvaluatorProvider = fullValueEvaluatorProvider;
  }

  public void setLabelRenderer(ValueLabelRenderer labelRenderer) {
    final ValueLabelRenderer prevRenderer = getLabelRenderer();
    myLabelRenderer = isBaseRenderer(labelRenderer) ? null : labelRenderer;
    final ValueLabelRenderer currentRenderer = getLabelRenderer();
    if (prevRenderer != currentRenderer) {
      if (currentRenderer instanceof ReferenceRenderer) {
        ((ReferenceRenderer)currentRenderer).setClassName(getClassName());
      }
    }
  }

  public void setChildrenRenderer(ChildrenRenderer childrenRenderer) {
    final ChildrenRenderer prevRenderer = getChildrenRenderer();
    myChildrenRenderer = isBaseRenderer(childrenRenderer) ? null : childrenRenderer;
    final ChildrenRenderer currentRenderer = getChildrenRenderer();
    if (prevRenderer != currentRenderer) {
      if (currentRenderer instanceof ReferenceRenderer) {
        ((ReferenceRenderer)currentRenderer).setClassName(getClassName());
      }
    }
  }

  public ChildrenRenderer getChildrenRenderer() {
    return myChildrenRenderer != null ? myChildrenRenderer : getDefaultRenderer();
  }

  private NodeRenderer getDefaultRenderer() {
    String name = getClassName();
    if (TypeConversionUtil.isPrimitive(name)) {
      return myRendererSettings.getPrimitiveRenderer();
    }
    return name.endsWith("]") ? myRendererSettings.getArrayRenderer() : AUTO_TO_STRING_RENDERER;
  }

  public ValueLabelRenderer getLabelRenderer() {
    return myLabelRenderer != null ? myLabelRenderer : getDefaultRenderer();
  }

  private ChildrenRenderer getRawChildrenRenderer() {
    return myChildrenRenderer == getDefaultRenderer() ? null : myChildrenRenderer;
  }

  private ValueLabelRenderer getRawLabelRenderer() {
    return myLabelRenderer == getDefaultRenderer() ? null : myLabelRenderer;
  }

  public void setClassName(@NotNull String name) {
    myProperties.setClassName(name);
    if (getRawLabelRenderer() != null) {
      if (myLabelRenderer instanceof ReferenceRenderer) {
        ((ReferenceRenderer)myLabelRenderer).setClassName(name);
      }
    }

    if (getRawChildrenRenderer() != null) {
      if (myChildrenRenderer instanceof ReferenceRenderer) {
        ((ReferenceRenderer)myChildrenRenderer).setClassName(name);
      }
    }
  }

  @Override
  public boolean isApplicable(Type type) {
    String className = getClassName();
    if (!StringUtil.isEmpty(className)) {
      return DebuggerUtils.instanceOf(type, className);
    }
    return getLabelRenderer().isApplicable(type) && getChildrenRenderer().isApplicable(type);
  }

  @NotNull
  public String getClassName() {
    return myProperties.getClassName();
  }

  protected final PsiElement getContext(Project project, DebuggerContext context) {
    DebugProcess process = context.getDebugProcess();
    GlobalSearchScope scope = process != null ? process.getSearchScope() : GlobalSearchScope.allScope(project);
    return DebuggerUtils.findClass(getClassName(), project, scope);
  }

  protected final PsiElement getChildValueExpression(String text, DebuggerTreeNode node, DebuggerContext context) {
    Project project = node.getProject();
    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);
    return elementFactory.createExpressionFromText(text, getContext(project, context));
  }

  public boolean isBaseRenderer(Renderer renderer) {
    return renderer == AUTO_TO_STRING_RENDERER ||
           renderer == myRendererSettings.getClassRenderer() ||
           renderer == myRendererSettings.getPrimitiveRenderer() ||
           renderer == myRendererSettings.getArrayRenderer();
  }

  private static final class AutoToStringRenderer extends ToStringRenderer {
    private AutoToStringRenderer() {
      setIsApplicableChecker(type -> CompletableFuture.completedFuture(type instanceof ReferenceType));
    }

    @Override
    public String getUniqueId() {
      return "AutoToString";
    }

    @Override
    public boolean isOnDemand(EvaluationContext evaluationContext, ValueDescriptor valueDescriptor) {
      return NodeRendererSettings.getInstance().getToStringRenderer().isOnDemand(evaluationContext, valueDescriptor);
    }

    @Override
    public String calcLabel(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener listener) {
      NodeRendererSettings nodeRendererSettings = NodeRendererSettings.getInstance();
      ToStringRenderer toStringRenderer = nodeRendererSettings.getToStringRenderer();
      CompletableFuture<Boolean> toStringApplicable = CompletableFuture.completedFuture(false);
      if (toStringRenderer.isEnabled()) {
        toStringApplicable = toStringRenderer.isApplicableAsync(descriptor.getType());
      }
      CompletableFuture<NodeRenderer> renderer = toStringApplicable
        .thenApply(applicable -> applicable ? toStringRenderer : nodeRendererSettings.getClassRenderer());
      return calcLabel(renderer, descriptor, evaluationContext, listener);
    }
  }

  @Override
  public String getUniqueId() {
    return UNIQUE_ID;
  }

  @Override
  public CompoundReferenceRenderer clone() {
    CompoundReferenceRenderer renderer = (CompoundReferenceRenderer)super.clone();
    renderer.myLabelRenderer = (myLabelRenderer != null) ? (ValueLabelRenderer)myLabelRenderer.clone() : null;
    renderer.myChildrenRenderer = (myChildrenRenderer != null) ? (ChildrenRenderer)myChildrenRenderer.clone() : null;
    return renderer;
  }

  @Override
  public void readExternal(Element element) throws InvalidDataException {
    super.readExternal(element);
    for (Element elem : element.getChildren(NodeRendererSettings.RENDERER_TAG)) {
      String role = elem.getAttributeValue("role");
      if (role == null) {
        continue;
      }
      if ("label".equals(role)) {
        myLabelRenderer = (ValueLabelRenderer)myRendererSettings.readRenderer(elem);
      }
      else if ("children".equals(role)) {
        myChildrenRenderer = (ChildrenRenderer)myRendererSettings.readRenderer(elem);
      }
    }
  }

  @Override
  public void writeExternal(Element element) throws WriteExternalException {
    super.writeExternal(element);
    if (myLabelRenderer != null) {
      final Element labelRendererElement = myRendererSettings.writeRenderer(myLabelRenderer);
      labelRendererElement.setAttribute("role", "label");
      element.addContent(labelRendererElement);
    }
    if (myChildrenRenderer != null) {
      final Element childrenRendererElement = myRendererSettings.writeRenderer(myChildrenRenderer);
      childrenRendererElement.setAttribute("role", "children");
      element.addContent(childrenRendererElement);
    }
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.FullValueEvaluatorProvider;
import com.intellij.debugger.impl.DebuggerUtilsAsync;
import com.intellij.openapi.extensions.ExtensionPointName;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.text.StringUtil;
import com.sun.jdi.Type;
import org.jetbrains.annotations.NotNull;

import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

/**
 * Allows to construct a renderer with the provided capabilities
 */
public abstract class CompoundRendererProvider {
  public static final ExtensionPointName<CompoundRendererProvider> EP_NAME =
    ExtensionPointName.create("com.intellij.debugger.compoundRendererProvider");

  protected abstract String getName();

  protected String getClassName() {
    return null;
  }

  protected ValueLabelRenderer getValueLabelRenderer() {
    return null;
  }

  protected ValueIconRenderer getIconRenderer() {
    return null;
  }

  protected ChildrenRenderer getChildrenRenderer() {
    return null;
  }

  protected FullValueEvaluatorProvider getFullValueEvaluatorProvider() {
    return null;
  }
  
  protected Function<Type, CompletableFuture<Boolean>> getIsApplicableChecker() {
    return null;
  }

  public boolean isApplicable(Project project) {
    return true;
  }
  
  protected boolean isEnabled() {
    return false;
  }

  @NotNull
  public final NodeRenderer createRenderer() {
    CompoundReferenceRenderer res = new CompoundReferenceRenderer(getName(), getValueLabelRenderer(), getChildrenRenderer());
    res.setIconRenderer(getIconRenderer());
    res.setFullValueEvaluator(getFullValueEvaluatorProvider());
    String className = getClassName();
    if (!StringUtil.isEmpty(className)) {
      res.setClassName(className);
      res.setIsApplicableChecker(type -> DebuggerUtilsAsync.instanceOf(type, res.getClassName()));
    }
    Function<Type, CompletableFuture<Boolean>> isApplicableChecker = getIsApplicableChecker();
    if (isApplicableChecker != null) {
      res.setIsApplicableChecker(isApplicableChecker);
    }
    res.setEnabled(isEnabled());
    return res;
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.JavaValue;
import com.intellij.debugger.engine.evaluation.TextWithImports;
import com.intellij.debugger.engine.evaluation.TextWithImportsImpl;
import com.intellij.debugger.impl.DebuggerUtilsImpl;
import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.debugger.ui.impl.watch.UserExpressionDescriptorImpl;
import com.intellij.debugger.ui.impl.watch.ValueDescriptorImpl;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.application.ModalityState;
import com.intellij.openapi.application.ReadAction;
import com.intellij.util.concurrency.AppExecutorUtil;
import com.intellij.xdebugger.frame.XValue;
import com.intellij.xdebugger.frame.XValueNode;
import com.intellij.xdebugger.frame.XValuePlace;
import com.intellij.xdebugger.impl.XDebuggerUtilImpl;
import com.intellij.xdebugger.impl.ui.DebuggerUIUtil;
import com.intellij.xdebugger.impl.ui.tree.XDebuggerTreeInplaceEditor;
import com.intellij.xdebugger.impl.ui.tree.XDebuggerTreeRestorer;
import com.intellij.xdebugger.impl.ui.tree.nodes.XDebuggerTreeNode;
import com.intellij.xdebugger.impl.ui.tree.nodes.XValueContainerNode;
import com.intellij.xdebugger.impl.ui.tree.nodes.XValueNodeImpl;
import com.sun.jdi.Type;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.tree.TreePath;
import java.awt.*;
import java.util.List;

public class CustomFieldInplaceEditor extends XDebuggerTreeInplaceEditor {
  private final UserExpressionDescriptorImpl myDescriptor;
  protected final EnumerationChildrenRenderer myRenderer;

  public CustomFieldInplaceEditor(@NotNull XDebuggerTreeNode node,
                                  @Nullable UserExpressionDescriptorImpl descriptor,
                                  @Nullable EnumerationChildrenRenderer renderer) {
    super(node, "customField");
    myDescriptor = descriptor;
    myRenderer = renderer;
    myExpressionEditor.setExpression(descriptor != null ? TextWithImportsImpl.toXExpression(descriptor.getEvaluationText()) : null);

    ValueDescriptorImpl parentDescriptor = ((JavaValue)((XValueContainerNode<?>)node.getParent()).getValueContainer()).getDescriptor();
    ReadAction.nonBlocking(() -> DebuggerUtilsImpl.getPsiClassAndType(getTypeName(parentDescriptor), getProject()).first)
      .finishOnUiThread(ModalityState.defaultModalityState(), context -> {
        if (context != null) {
          myExpressionEditor.setContext(context);
        }
      })
      .submit(AppExecutorUtil.getAppExecutorService());
  }

  public static void editNew(@NotNull XValueNodeImpl parentNode) {
    ValueDescriptorImpl descriptor = ((JavaValue)parentNode.getValueContainer()).getDescriptor();
    EnumerationChildrenRenderer renderer = EnumerationChildrenRenderer.getCurrent(descriptor);
    XDebuggerTreeNode newNode = parentNode.addTemporaryEditorNode(AllIcons.Debugger.Db_watch, null);
    DebuggerUIUtil.invokeLater(() -> new CustomFieldInplaceEditor(newNode, null, renderer) {
      @Override
      public void cancelEditing() {
        super.cancelEditing();
        parentNode.removeTemporaryEditorNode(newNode);
      }

      @Override
      protected List<EnumerationChildrenRenderer.ChildInfo> getRendererChildren() {
        if (myRenderer != null) {
          return myRenderer.getChildren();
        }
        String name = getTypeName(descriptor);
        EnumerationChildrenRenderer enumerationChildrenRenderer = new EnumerationChildrenRenderer();
        enumerationChildrenRenderer.setAppendDefaultChildren(true);

        Renderer lastRenderer = descriptor.getLastRenderer();
        if (lastRenderer instanceof CompoundReferenceRenderer &&
            NodeRendererSettings.getInstance().getCustomRenderers().contains((NodeRenderer)lastRenderer) &&
            !(((CompoundReferenceRenderer)lastRenderer).getChildrenRenderer() instanceof ExpressionChildrenRenderer)) {
          ((CompoundReferenceRenderer)lastRenderer).setChildrenRenderer(enumerationChildrenRenderer);
        }
        else {
          NodeRenderer renderer =
            NodeRendererSettings.getInstance().createCompoundReferenceRenderer(name, name, null, enumerationChildrenRenderer);
          renderer.setEnabled(true);
          NodeRendererSettings.getInstance().getCustomRenderers().addRenderer(renderer);
          NodeRendererSettings.getInstance().fireRenderersChanged();
        }
        return enumerationChildrenRenderer.getChildren();
      }
    }.show());
  }

  @Nullable
  private static String getTypeName(ValueDescriptorImpl descriptor) {
    Type type = descriptor.getType();
    return type != null ? type.name() : null;
  }

  protected List<EnumerationChildrenRenderer.ChildInfo> getRendererChildren() {
    return myRenderer.getChildren();
  }

  @Override
  public void doOKAction() {
    List<EnumerationChildrenRenderer.ChildInfo> children = getRendererChildren();
    TextWithImports newText = TextWithImportsImpl.fromXExpression(myExpressionEditor.getExpression());
    if (myDescriptor == null) {
      children.add(0, new EnumerationChildrenRenderer.ChildInfo("", newText, false));
    }
    else {
      int index = myDescriptor.getEnumerationIndex();
      EnumerationChildrenRenderer.ChildInfo old = children.get(index);
      children.set(index, new EnumerationChildrenRenderer.ChildInfo(old.myName, newText, old.myOnDemand));
    }

    myTree.putClientProperty(XDebuggerTreeRestorer.SELECTION_PATH_PROPERTY,
                             createDummySelectionTreePath(newText.getText(), (XDebuggerTreeNode)myNode.getParent()));

    XDebuggerUtilImpl.rebuildTreeAndViews(myTree);

    super.doOKAction();
  }

  private static TreePath createDummySelectionTreePath(String name, XDebuggerTreeNode parentNode) {
    return new XValueNodeImpl(parentNode.getTree(), parentNode, name, new XValue() {
      @Override
      public void computePresentation(@NotNull XValueNode node, @NotNull XValuePlace place) {
      }
    }).getPath();
  }

  @Nullable
  @Override
  protected Rectangle getEditorBounds() {
    Rectangle bounds = super.getEditorBounds();
    if (bounds == null) {
      return null;
    }
    int afterIconX = getAfterIconX();
    bounds.x += afterIconX;
    bounds.width -= afterIconX;
    return bounds;
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.JavaValue;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.popup.JBPopup;
import com.intellij.openapi.util.Disposer;
import com.intellij.openapi.wm.WindowManager;
import com.intellij.ui.awt.RelativePoint;
import com.intellij.xdebugger.impl.ui.DebuggerUIUtil;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import java.awt.*;

public abstract class CustomPopupFullValueEvaluator<T> extends JavaValue.JavaFullValueEvaluator {
  public CustomPopupFullValueEvaluator(@NotNull @Nls String linkText, @NotNull EvaluationContextImpl evaluationContext) {
    super(linkText, evaluationContext);
    setShowValuePopup(false);
  }

  protected abstract T getData();

  protected abstract JComponent createComponent(T data);

  @Override
  public void evaluate(@NotNull final XFullValueEvaluationCallback callback) {
    final T data = getData();
    DebuggerUIUtil.invokeLater(() -> {
      if (callback.isObsolete()) return;
      final JComponent comp = createComponent(data);
      Project project = getEvaluationContext().getProject();
      JBPopup popup = DebuggerUIUtil.createValuePopup(project, comp, null);
      JFrame frame = WindowManager.getInstance().getFrame(project);
      Dimension frameSize = frame.getSize();
      Dimension size = new Dimension(frameSize.width / 2, frameSize.height / 2);
      popup.setSize(size);
      if (comp instanceof Disposable) {
        Disposer.register(popup, (Disposable)comp);
      }
      callback.evaluated("");
      popup.show(new RelativePoint(frame, new Point(size.width / 2, size.height / 2)));
    });
  }
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree.render;


public interface DescriptorLabelListener {
  DescriptorLabelListener DUMMY_LISTENER = new DescriptorLabelListener() {
    @Override
    public void labelChanged() {
    }
  };

  void labelChanged();
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.evaluation.TextWithImports;
import com.intellij.debugger.impl.descriptors.data.UserExpressionData;
import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.debugger.ui.impl.watch.ValueDescriptorImpl;
import com.intellij.debugger.ui.tree.*;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.JDOMExternalizerUtil;
import com.intellij.openapi.util.WriteExternalException;
import com.intellij.psi.PsiElement;
import com.sun.jdi.Value;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

public final class EnumerationChildrenRenderer extends ReferenceRenderer implements ChildrenRenderer {
  public static final @NonNls String UNIQUE_ID = "EnumerationChildrenRenderer";

  private boolean myAppendDefaultChildren;
  private List<ChildInfo> myChildren;

  public static final @NonNls String APPEND_DEFAULT_NAME = "AppendDefault";
  public static final @NonNls String CHILDREN_EXPRESSION = "ChildrenExpression";
  public static final @NonNls String CHILD_NAME = "Name";
  public static final @NonNls String CHILD_ONDEMAND = "OnDemand";

  public EnumerationChildrenRenderer() {
    this(new ArrayList<>());
  }

  public EnumerationChildrenRenderer(List<ChildInfo> children) {
    super();
    myChildren = children;
  }

  public void setAppendDefaultChildren(boolean appendDefaultChildren) {
    myAppendDefaultChildren = appendDefaultChildren;
  }

  public boolean isAppendDefaultChildren() {
    return myAppendDefaultChildren;
  }

  @Override
  public String getUniqueId() {
    return UNIQUE_ID;
  }

  @Override
  public EnumerationChildrenRenderer clone() {
    return (EnumerationChildrenRenderer)super.clone();
  }

  @Override
  public void readExternal(Element element) throws InvalidDataException {
    super.readExternal(element);

    myChildren.clear();

    myAppendDefaultChildren = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, APPEND_DEFAULT_NAME));

    List<Element> children = element.getChildren(CHILDREN_EXPRESSION);
    for (Element item : children) {
      String name = item.getAttributeValue(CHILD_NAME);
      TextWithImports text = DebuggerUtils.getInstance().readTextWithImports(item.getChildren().get(0));
      boolean onDemand = Boolean.parseBoolean(item.getAttributeValue(CHILD_ONDEMAND));

      myChildren.add(new ChildInfo(name, text, onDemand));
    }
  }

  @Override
  public void writeExternal(Element element) throws WriteExternalException {
    super.writeExternal(element);

    if (myAppendDefaultChildren) {
      JDOMExternalizerUtil.writeField(element, APPEND_DEFAULT_NAME, "true");
    }

    for (ChildInfo childInfo : myChildren) {
      Element child = new Element(CHILDREN_EXPRESSION);
      child.setAttribute(CHILD_NAME, childInfo.myName);
      if (childInfo.myOnDemand) {
        child.setAttribute(CHILD_ONDEMAND, "true");
      }
      child.addContent(DebuggerUtils.getInstance().writeTextWithImports(childInfo.myExpression));

      element.addContent(child);
    }
  }

  @Override
  public void buildChildren(Value value, ChildrenBuilder builder, EvaluationContext evaluationContext) {
    NodeManager nodeManager = builder.getNodeManager();
    NodeDescriptorFactory descriptorFactory = builder.getDescriptorManager();

    List<DebuggerTreeNode> children = new ArrayList<>();
    int idx = 0;
    for (ChildInfo childInfo : myChildren) {
      UserExpressionData data = new UserExpressionData((ValueDescriptorImpl)builder.getParentDescriptor(),
                                                       getClassName(),
                                                       childInfo.myName,
                                                       childInfo.myExpression);
      data.setEnumerationIndex(idx++);
      UserExpressionDescriptor descriptor = descriptorFactory.getUserExpressionDescriptor(builder.getParentDescriptor(), data);
      if (childInfo.myOnDemand) {
        descriptor.putUserData(OnDemandRenderer.ON_DEMAND_CALCULATED, false);
      }
      children.add(nodeManager.createNode(descriptor, evaluationContext));
    }
    builder.addChildren(children, !myAppendDefaultChildren);

    if (myAppendDefaultChildren) {
      DebugProcessImpl.getDefaultRenderer(value).buildChildren(value, builder, evaluationContext);
    }
  }

  @Override
  public PsiElement getChildValueExpression(DebuggerTreeNode node, DebuggerContext context) throws EvaluateException {
    return ((ValueDescriptor)node.getDescriptor()).getDescriptorEvaluation(context);
  }

  @Override
  public CompletableFuture<Boolean> isExpandableAsync(Value value, EvaluationContext evaluationContext, NodeDescriptor parentDescriptor) {
    if (myChildren.size() > 0) {
      return CompletableFuture.completedFuture(true);
    }
    if (myAppendDefaultChildren) {
      return DebugProcessImpl.getDefaultRenderer(value).isExpandableAsync(value, evaluationContext, parentDescriptor);
    }
    return CompletableFuture.completedFuture(false);
  }

  public List<ChildInfo> getChildren() {
    return myChildren;
  }

  public void setChildren(List<ChildInfo> children) {
    myChildren = children;
  }

  @Nullable
  public static EnumerationChildrenRenderer getCurrent(ValueDescriptorImpl valueDescriptor) {
    Renderer renderer = valueDescriptor.getLastRenderer();
    if (renderer instanceof CompoundReferenceRenderer &&
        NodeRendererSettings.getInstance().getCustomRenderers().contains((NodeRenderer)renderer)) {
      ChildrenRenderer childrenRenderer = ((CompoundReferenceRenderer)renderer).getChildrenRenderer();
      if (childrenRenderer instanceof EnumerationChildrenRenderer) {
        return (EnumerationChildrenRenderer)childrenRenderer;
      }
    }
    return null;
  }

  public static class ChildInfo implements Cloneable {
    public String myName;
    public TextWithImports myExpression;
    public boolean myOnDemand;

    public ChildInfo(String name, TextWithImports expression, boolean onDemand) {
      myName = name;
      myExpression = expression;
      myOnDemand = onDemand;
    }
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.PossiblySyncCommand;
import com.intellij.debugger.engine.SuspendContextImpl;
import com.intellij.debugger.engine.evaluation.*;
import com.intellij.debugger.engine.evaluation.expression.ExpressionEvaluator;
import com.intellij.debugger.impl.DebuggerUtilsAsync;
import com.intellij.debugger.ui.impl.watch.DebuggerTreeNodeExpression;
import com.intellij.debugger.ui.tree.DebuggerTreeNode;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.openapi.util.DefaultJDOMExternalizer;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.WriteExternalException;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.PsiExpression;
import com.sun.jdi.BooleanValue;
import com.sun.jdi.Type;
import com.sun.jdi.Value;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.concurrent.CompletableFuture;

public final class ExpressionChildrenRenderer extends ReferenceRenderer implements ChildrenRenderer {
  public static final @NonNls String UNIQUE_ID = "ExpressionChildrenRenderer";
  private static final Key<Value> EXPRESSION_VALUE = new Key<>("EXPRESSION_VALUE");
  private static final Key<NodeRenderer> LAST_CHILDREN_RENDERER = new Key<>("LAST_CHILDREN_RENDERER");

  private CachedEvaluator myChildrenExpandable = createCachedEvaluator();
  private CachedEvaluator myChildrenExpression = createCachedEvaluator();

  private NodeRenderer myPredictedRenderer;

  @Override
  public String getUniqueId() {
    return UNIQUE_ID;
  }

  @Override
  public ExpressionChildrenRenderer clone() {
    ExpressionChildrenRenderer clone = (ExpressionChildrenRenderer)super.clone();
    clone.myChildrenExpandable = createCachedEvaluator();
    clone.setChildrenExpandable(getChildrenExpandable());
    clone.myChildrenExpression = createCachedEvaluator();
    clone.setChildrenExpression(getChildrenExpression());
    return clone;
  }

  @Override
  public void buildChildren(Value value, ChildrenBuilder builder, EvaluationContext evaluationContext) {
    EvaluationContextImpl evaluationContextImpl = (EvaluationContextImpl)evaluationContext;
    evaluationContextImpl.getDebugProcess().getManagerThread().schedule(new PossiblySyncCommand(evaluationContextImpl.getSuspendContext()) {
      @Override
      public void syncAction(@NotNull SuspendContextImpl suspendContext) {
        try {
          ValueDescriptor parentDescriptor = builder.getParentDescriptor();
          Value childrenValue = evaluateChildren(evaluationContext.createEvaluationContext(value), parentDescriptor);

          DebuggerUtilsAsync.type(childrenValue)
            .thenAccept(type -> getChildrenRenderer(type, parentDescriptor).buildChildren(childrenValue, builder, evaluationContext));
        }
        catch (EvaluateException e) {
          builder.setErrorMessage(JavaDebuggerBundle.message("error.unable.to.evaluate.children.expression") + " " + e.getMessage());
          // fallback to the default renderer
          DebugProcessImpl.getDefaultRenderer(value).buildChildren(value, builder, evaluationContext);
        }
      }
    });
  }

  @Nullable
  public static NodeRenderer getLastChildrenRenderer(ValueDescriptor descriptor) {
    return descriptor.getUserData(LAST_CHILDREN_RENDERER);
  }

  public static void setPreferableChildrenRenderer(ValueDescriptor descriptor, NodeRenderer renderer) {
    descriptor.putUserData(LAST_CHILDREN_RENDERER, renderer);
  }

  public static Value getLastChildrenValue(NodeDescriptor descriptor) {
    return descriptor.getUserData(EXPRESSION_VALUE);
  }

  private Value evaluateChildren(EvaluationContext context, NodeDescriptor descriptor) throws EvaluateException {
    ExpressionEvaluator evaluator = myChildrenExpression.getEvaluator(context.getProject());
    Value value = context.computeAndKeep(() -> evaluator.evaluate(context));
    descriptor.putUserData(EXPRESSION_VALUE, value);
    return value;
  }

  @Override
  public void readExternal(Element element) throws InvalidDataException {
    super.readExternal(element);
    DefaultJDOMExternalizer.readExternal(this, element);

    TextWithImports childrenExpression = DebuggerUtils.getInstance().readTextWithImports(element, "CHILDREN_EXPRESSION");
    if (childrenExpression != null) {
      setChildrenExpression(childrenExpression);
    }

    TextWithImports childrenExpandable = DebuggerUtils.getInstance().readTextWithImports(element, "CHILDREN_EXPANDABLE");
    if (childrenExpandable != null) {
      myChildrenExpandable.setReferenceExpression(childrenExpandable);
    }
  }

  @Override
  public void writeExternal(Element element) throws WriteExternalException {
    super.writeExternal(element);
    DefaultJDOMExternalizer.writeExternal(this, element);
    DebuggerUtils.getInstance().writeTextWithImports(element, "CHILDREN_EXPANDABLE", getChildrenExpandable());
    DebuggerUtils.getInstance().writeTextWithImports(element, "CHILDREN_EXPRESSION", getChildrenExpression());
  }

  @Override
  public PsiExpression getChildValueExpression(DebuggerTreeNode node, DebuggerContext context) throws EvaluateException {
    Value expressionValue = getLastChildrenValue(node.getParent().getDescriptor());
    if (expressionValue == null) {
      throw EvaluateExceptionUtil.createEvaluateException(JavaDebuggerBundle.message("error.unable.to.evaluate.children.expression"));
    }

    NodeRenderer childrenRenderer = getChildrenRenderer(expressionValue.type(), (ValueDescriptor)node.getParent().getDescriptor());

    PsiExpression childrenPsiExpression = myChildrenExpression.getPsiExpression(node.getProject());
    if (childrenPsiExpression == null) {
      return null;
    }
    return DebuggerTreeNodeExpression.substituteThis(
      childrenRenderer.getChildValueExpression(node, context),
      (PsiExpression)childrenPsiExpression.copy(),
      expressionValue);
  }

  private static NodeRenderer getChildrenRenderer(Type type, ValueDescriptor parentDescriptor) {
    NodeRenderer renderer = getLastChildrenRenderer(parentDescriptor);
    if (renderer == null || type == null/* || !renderer.isApplicable(type)*/) {
      renderer = DebugProcessImpl.getDefaultRenderer(type);
      setPreferableChildrenRenderer(parentDescriptor, renderer);
    }
    return renderer;
  }

  @Override
  public CompletableFuture<Boolean> isExpandableAsync(Value value, EvaluationContext context, NodeDescriptor parentDescriptor) {
    CompletableFuture<Boolean> res = new CompletableFuture<>();
    EvaluationContextImpl evaluationContextImpl = (EvaluationContextImpl)context;
    DebugProcessImpl debugProcess = evaluationContextImpl.getDebugProcess();
    debugProcess.getManagerThread().schedule(new PossiblySyncCommand(evaluationContextImpl.getSuspendContext()) {
      @Override
      public void syncAction(@NotNull SuspendContextImpl suspendContext) {
        EvaluationContext evaluationContext = context.createEvaluationContext(value);

        if (!StringUtil.isEmpty(myChildrenExpandable.getReferenceExpression().getText())) {
          try {
            Value expanded = myChildrenExpandable.getEvaluator(evaluationContext.getProject()).evaluate(evaluationContext);
            if (expanded instanceof BooleanValue) {
              res.complete(((BooleanValue)expanded).booleanValue());
              return;
            }
          }
          catch (EvaluateException e) {
            // ignored
          }
        }

        try {
          Value children = evaluateChildren(evaluationContext, parentDescriptor);
          DebugProcessImpl.getDefaultRenderer(value.type())
            .isExpandableAsync(children, evaluationContext, parentDescriptor)
            .whenComplete((aBoolean, throwable) -> DebuggerUtilsAsync.completeFuture(aBoolean, throwable, res));
        }
        catch (EvaluateException e) {
          res.complete(true);
        }
      }

      @Override
      protected void commandCancelled() {
        res.cancel(false);
      }
    });
    return res;
  }

  public TextWithImports getChildrenExpression() {
    return myChildrenExpression.getReferenceExpression();
  }

  public void setChildrenExpression(TextWithImports expression) {
    myChildrenExpression.setReferenceExpression(expression);
  }

  public TextWithImports getChildrenExpandable() {
    return myChildrenExpandable.getReferenceExpression();
  }

  public void setChildrenExpandable(TextWithImports childrenExpandable) {
    myChildrenExpandable.setReferenceExpression(childrenExpandable);
  }

  @Override
  public void setClassName(String name) {
    super.setClassName(name);
    myChildrenExpression.clear();
    myChildrenExpandable.clear();
  }

  public NodeRenderer getPredictedRenderer() {
    return myPredictedRenderer;
  }

  public void setPredictedRenderer(NodeRenderer predictedRenderer) {
    myPredictedRenderer = predictedRenderer;
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.openapi.util.registry.Registry;

public class FileObjectRenderer extends CompoundRendererProvider {
  @Override
  protected String getName() {
    return "File";
  }

  @Override
  protected ChildrenRenderer getChildrenRenderer() {
    return NodeRendererSettings.createExpressionChildrenRenderer("listFiles()", null);
  }

  @Override
  protected String getClassName() {
    return "java.io.File";
  }

  @Override
  protected boolean isEnabled() {
    return Registry.is("debugger.renderers.file");
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.FullValueEvaluatorProvider;
import com.sun.jdi.*;

import javax.swing.*;

public class GraphicsObjectRenderer extends CompoundRendererProvider {
  @Override
  protected String getName() {
    return "Graphics";
  }

  @Override
  protected String getClassName() {
    return "sun.java2d.SunGraphics2D";
  }

  @Override
  protected boolean isEnabled() {
    return true;
  }

  @Override
  protected FullValueEvaluatorProvider getFullValueEvaluatorProvider() {
    return (evaluationContext, valueDescriptor) -> {
      try {
        ObjectReference value = (ObjectReference)valueDescriptor.getValue();
        Field surfaceField = ((ClassType)value.type()).fieldByName("surfaceData");
        if (surfaceField == null) return null;
        ObjectReference surfaceDataValue = (ObjectReference)value.getValue(surfaceField);
        if (surfaceDataValue == null) return null;

        Field imgField = ((ReferenceType)surfaceDataValue.type()).fieldByName("bufImg"); // BufImgSurfaceData
        if (imgField == null) {
          imgField = ((ReferenceType)surfaceDataValue.type()).fieldByName("offscreenImage"); // CGLSurfaceData
        }
        if (imgField == null) return null;

        final Value bufImgValue = surfaceDataValue.getValue(imgField);
        Type type = bufImgValue.type();
        if (!(type instanceof ReferenceType) || !DebuggerUtils.instanceOf(type, "java.awt.Image")) {
          return null;
        }
        return new ImageObjectRenderer.IconPopupEvaluator(JavaDebuggerBundle.message("message.node.show.image"), evaluationContext) {
          @Override
          protected Icon getData() {
            return ImageObjectRenderer.getIcon(getEvaluationContext(), bufImgValue, "imageToBytes");
          }
        };
      }
      catch (Exception ignored) {
      }
      return null;
    };
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.util.text.StringUtil;
import com.sun.jdi.*;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;

public class HexRenderer extends NodeRendererImpl {
  public static final @NonNls String UNIQUE_ID = "HexRenderer";
  private static final Logger LOG = Logger.getInstance(HexRenderer.class);

  public HexRenderer() {
    super(DEFAULT_NAME, false);
  }

  @Override
  public String getUniqueId() {
    return UNIQUE_ID;
  }

  @Override
  public @NonNls String getName() {
    return "Hex";
  }

  @Override
  public void setName(String name) {
    // prohibit change
  }

  @Override
  public HexRenderer clone() {
    return (HexRenderer)super.clone();
  }

  @Override
  public String calcLabel(ValueDescriptor valueDescriptor, EvaluationContext evaluationContext, DescriptorLabelListener labelListener) {
    Value value = valueDescriptor.getValue();
    StringBuilder buf = new StringBuilder();

    if (value == null) {
      return "null";
    }
    else if (value instanceof CharValue) {
      PrimitiveRenderer.appendCharValue((CharValue)value, buf);
      buf.append(' ');
      appendHexValue((PrimitiveValue)value, buf);
      return buf.toString();
    }
    else {
      appendHexValue((PrimitiveValue)value, buf);
      return buf.toString();
    }
  }

  static void appendHexValue(@NotNull PrimitiveValue value, StringBuilder buf) {
    if (value instanceof CharValue) {
      long longValue = value.longValue();
      buf.append("0x").append(StringUtil.toUpperCase(Long.toHexString(longValue)));
    }
    else if (value instanceof ByteValue) {
      String strValue = StringUtil.toUpperCase(Integer.toHexString(value.byteValue()));
      if (strValue.length() > 2) {
        strValue = strValue.substring(strValue.length() - 2);
      }
      buf.append("0x").append(strValue);
    }
    else if (value instanceof ShortValue) {
      String strValue = StringUtil.toUpperCase(Integer.toHexString(value.shortValue()));
      if (strValue.length() > 4) {
        strValue = strValue.substring(strValue.length() - 4);
      }
      buf.append("0x").append(strValue);
    }
    else if (value instanceof IntegerValue) {
      buf.append("0x").append(StringUtil.toUpperCase(Integer.toHexString(value.intValue())));
    }
    else if (value instanceof LongValue) {
      buf.append("0x").append(StringUtil.toUpperCase(Long.toHexString(value.longValue())));
    }
    else {
      LOG.assertTrue(false);
    }
  }

  //returns whether this renderer is apllicable to this type or it's supertypes
  @Override
  public boolean isApplicable(Type t) {
    if (t == null) {
      return false;
    }
    return t instanceof CharType ||
           t instanceof ByteType ||
           t instanceof ShortType ||
           t instanceof IntegerType ||
           t instanceof LongType;
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.FullValueEvaluatorProvider;
import com.intellij.debugger.engine.SuspendContextImpl;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.engine.events.SuspendContextCommandImpl;
import com.intellij.debugger.impl.DebuggerUtilsImpl;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.util.registry.Registry;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;

class IconObjectRenderer extends CompoundRendererProvider {
  @Override
  protected String getName() {
    return "Icon";
  }

  @Override
  protected String getClassName() {
    return "javax.swing.Icon";
  }

  @Override
  protected boolean isEnabled() {
    return true;
  }

  @Override
  protected ValueIconRenderer getIconRenderer() {
    return (descriptor, evaluationContext, listener) -> {
      EvaluationContextImpl evalContext = ((EvaluationContextImpl)evaluationContext);
      DebugProcessImpl debugProcess = evalContext.getDebugProcess();

      if (!Registry.is("debugger.auto.fetch.icons") || DebuggerUtilsImpl.isRemote(debugProcess)) return null;

      debugProcess.getManagerThread().schedule(new SuspendContextCommandImpl(evalContext.getSuspendContext()) {
        @Override
        public void contextAction(@NotNull SuspendContextImpl suspendContext) {
          String getterName = AllIcons.Debugger.Value.getIconHeight() <= 16 ? "iconToBytesPreviewNormal" : "iconToBytesPreviewRetina";
          descriptor.setValueIcon(ImageObjectRenderer.getIcon(evaluationContext, descriptor.getValue(), getterName));
          listener.labelChanged();
        }
      });
      return null;
    };
  }

  @Override
  protected FullValueEvaluatorProvider getFullValueEvaluatorProvider() {
    return (evaluationContext, valueDescriptor) -> {
      return new ImageObjectRenderer.IconPopupEvaluator(JavaDebuggerBundle.message("message.node.show.icon"), evaluationContext) {
        @Override
        protected Icon getData() {
          return ImageObjectRenderer.getIcon(getEvaluationContext(), valueDescriptor.getValue(), "iconToBytes");
        }
      };
    };
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.CommonBundle;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcess;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.FullValueEvaluatorProvider;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.impl.ClassLoadingUtils;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.rt.debugger.ImageSerializer;
import com.sun.jdi.ClassType;
import com.sun.jdi.Method;
import com.sun.jdi.StringReference;
import com.sun.jdi.Value;
import org.intellij.images.editor.impl.ImageEditorManagerImpl;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.nio.charset.StandardCharsets;
import java.util.Collections;

final class ImageObjectRenderer extends CompoundRendererProvider {
  private static final Logger LOG = Logger.getInstance(ImageObjectRenderer.class);

  @Override
  protected String getName() {
    return "Image";
  }

  @Override
  protected String getClassName() {
    return "java.awt.Image";
  }

  @Override
  protected boolean isEnabled() {
    return true;
  }

  @Override
  protected FullValueEvaluatorProvider getFullValueEvaluatorProvider() {
    return (evaluationContext, valueDescriptor) ->
      new IconPopupEvaluator(JavaDebuggerBundle.message("message.node.show.image"), evaluationContext) {
        @Override
        protected Icon getData() {
          return getIcon(getEvaluationContext(), valueDescriptor.getValue(), "imageToBytes");
        }
      };
  }

  static JComponent createIconViewer(@Nullable Icon icon) {
    if (icon == null) return new JLabel(CommonBundle.message("label.no.data"), SwingConstants.CENTER);
    final int w = icon.getIconWidth();
    final int h = icon.getIconHeight();
    final BufferedImage image = GraphicsEnvironment.getLocalGraphicsEnvironment()
      .getDefaultScreenDevice().getDefaultConfiguration().createCompatibleImage(w, h, Transparency.TRANSLUCENT);
    final Graphics2D g = image.createGraphics();
    icon.paintIcon(null, g, 0, 0);
    g.dispose();

    return ImageEditorManagerImpl.createImageEditorUI(image);
  }

  @Nullable
  static ImageIcon getIcon(EvaluationContext evaluationContext, Value obj, String methodName) {
    try {
      byte[] data = getImageBytes(evaluationContext, obj, methodName);
      if (data != null) {
        return new ImageIcon(data);
      }
    }
    catch (Exception e) {
      LOG.info("Exception while getting image data", e);
    }
    return null;
  }

  private static byte @Nullable [] getImageBytes(EvaluationContext evaluationContext, Value obj, String methodName)
    throws EvaluateException {
    DebugProcess process = evaluationContext.getDebugProcess();
    EvaluationContext copyContext = evaluationContext.createEvaluationContext(obj);
    ClassType helperClass = ClassLoadingUtils.getHelperClass(ImageSerializer.class, copyContext);

    if (helperClass != null) {
      Method method = DebuggerUtils.findMethod(helperClass, methodName, null);
      if (method != null) {
        StringReference bytes = (StringReference)process.invokeMethod(copyContext, helperClass, method, Collections.singletonList(obj));
        if (bytes != null) {
          return bytes.value().getBytes(StandardCharsets.ISO_8859_1);
        }
      }
    }
    return null;
  }

  static abstract class IconPopupEvaluator extends CustomPopupFullValueEvaluator<Icon> {
    IconPopupEvaluator(@NotNull @Nls String linkText, @NotNull EvaluationContextImpl evaluationContext) {
      super(linkText, evaluationContext);
    }

    @Override
    protected JComponent createComponent(Icon data) {
      return createIconViewer(data);
    }
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.PossiblySyncCommand;
import com.intellij.debugger.engine.SuspendContextImpl;
import com.intellij.debugger.engine.evaluation.*;
import com.intellij.debugger.engine.evaluation.expression.ExpressionEvaluator;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.openapi.util.DefaultJDOMExternalizer;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.WriteExternalException;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.xdebugger.impl.ui.XDebuggerUIConstants;
import com.sun.jdi.Value;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class LabelRenderer extends ReferenceRenderer implements ValueLabelRenderer, OnDemandRenderer {
  public static final @NonNls String UNIQUE_ID = "LabelRenderer";
  public boolean ON_DEMAND;

  private CachedEvaluator myLabelExpression = createCachedEvaluator();
  private String myPrefix;

  public LabelRenderer() {
    super();
  }

  @Override
  public String getUniqueId() {
    return UNIQUE_ID;
  }

  @Override
  public LabelRenderer clone() {
    LabelRenderer clone = (LabelRenderer)super.clone();
    clone.myLabelExpression = createCachedEvaluator();
    clone.setLabelExpression(getLabelExpression());
    return clone;
  }

  @Override
  public String calcLabel(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener labelListener)
    throws EvaluateException {

    if (!isShowValue(descriptor, evaluationContext)) {
      return prefix("");
    }

    Value value = descriptor.getValue();
    if (value == null) {
      return prefix("null");
    }

    EvaluationContextImpl evaluationContextImpl = (EvaluationContextImpl)evaluationContext;
    DebugProcessImpl debugProcess = evaluationContextImpl.getDebugProcess();
    debugProcess.getManagerThread().schedule(new PossiblySyncCommand(evaluationContextImpl.getSuspendContext()) {
      @Override
      public void syncAction(@NotNull SuspendContextImpl suspendContext) {
        try {
          ExpressionEvaluator evaluator = myLabelExpression.getEvaluator(debugProcess.getProject());

          if (!debugProcess.isAttached()) {
            throw EvaluateExceptionUtil.PROCESS_EXITED;
          }
          EvaluationContext thisEvaluationContext = evaluationContext.createEvaluationContext(value);
          Value labelValue = evaluator.evaluate(thisEvaluationContext);
          String result = StringUtil.notNullize(DebuggerUtils.getValueAsString(thisEvaluationContext, labelValue));
          descriptor.setValueLabel(prefix(result));
        }
        catch (EvaluateException ex) {
          descriptor.setValueLabelFailed(
            new EvaluateException(JavaDebuggerBundle.message("error.unable.to.evaluate.expression") + " " + ex.getMessage(), ex));
        }
        labelListener.labelChanged();
      }
    });
    return XDebuggerUIConstants.getCollectingDataMessage();
  }

  private String prefix(String result) {
    return myPrefix != null ? myPrefix + result : result;
  }

  @NotNull
  @Override
  public String getLinkText() {
    return " " + getLabelExpression().getText();
  }

  @Override
  public void readExternal(Element element) throws InvalidDataException {
    super.readExternal(element);
    DefaultJDOMExternalizer.readExternal(this, element);
    TextWithImports labelExpression = DebuggerUtils.getInstance().readTextWithImports(element, "LABEL_EXPRESSION");
    if (labelExpression != null) {
      setLabelExpression(labelExpression);
    }
  }

  @Override
  public void writeExternal(Element element) throws WriteExternalException {
    super.writeExternal(element);
    DefaultJDOMExternalizer.writeExternal(this, element);
    DebuggerUtils.getInstance().writeTextWithImports(element, "LABEL_EXPRESSION", getLabelExpression());
  }

  public TextWithImports getLabelExpression() {
    return myLabelExpression.getReferenceExpression();
  }

  public void setLabelExpression(TextWithImports expression) {
    myLabelExpression.setReferenceExpression(expression);
  }

  public void setPrefix(@Nullable String prefix) {
    myPrefix = prefix;
  }

  @Override
  public boolean isOnDemand(EvaluationContext evaluationContext, ValueDescriptor valueDescriptor) {
    return ON_DEMAND || OnDemandRenderer.super.isOnDemand(evaluationContext, valueDescriptor);
  }

  public boolean isOnDemand() {
    return ON_DEMAND;
  }

  public void setOnDemand(boolean value) {
    ON_DEMAND = value;
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.openapi.extensions.ExtensionPointName;
import org.jetbrains.annotations.Nls;

/**
 * Allows to register custom value renderer.
 * <p>It is recommended to use {@link CompoundRendererProvider} instead
 */
public interface NodeRenderer extends ChildrenRenderer, ValueLabelRenderer {
  ExtensionPointName<NodeRenderer> EP_NAME = ExtensionPointName.create("com.intellij.debugger.nodeRenderer");

  @Nls String getName();

  void setName(String text);

  boolean isEnabled();

  void setEnabled(boolean enabled);
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcess;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.debugger.ui.impl.watch.ValueDescriptorImpl;
import com.intellij.debugger.ui.overhead.OverheadProducer;
import com.intellij.debugger.ui.tree.DebuggerTreeNode;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.psi.PsiElement;
import com.intellij.ui.SimpleColoredComponent;
import com.intellij.xdebugger.impl.ui.XDebuggerUIConstants;
import com.sun.jdi.ObjectReference;
import com.sun.jdi.Type;
import com.sun.jdi.Value;
import org.jdom.Element;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

public abstract class NodeRendererImpl implements NodeRenderer {
  public static final String DEFAULT_NAME = "unnamed";

  protected BasicRendererProperties myProperties;
  private final String myDefaultName;
  private Function<? super Type, ? extends CompletableFuture<Boolean>> myIsApplicableChecker = null;

  protected NodeRendererImpl() {
    this(DEFAULT_NAME, false);
  }

  protected NodeRendererImpl(@NotNull String presentableName) {
    this(presentableName, false);
  }

  protected NodeRendererImpl(@NotNull String presentableName, boolean enabledDefaultValue) {
    myDefaultName = presentableName;
    myProperties = new BasicRendererProperties(enabledDefaultValue);
    myProperties.setName(presentableName);
    myProperties.setEnabled(enabledDefaultValue);
  }

  @Override
  public String getName() {
    return myProperties.getName();
  }

  @Override
  public void setName(String name) {
    myProperties.setName(name);
  }

  @Override
  public boolean isEnabled() {
    return myProperties.isEnabled();
  }

  @Override
  public void setEnabled(boolean enabled) {
    myProperties.setEnabled(enabled);
  }

  public boolean isShowType() {
    return myProperties.isShowType();
  }

  public void setShowType(boolean showType) {
    myProperties.setShowType(showType);
  }

  @Override
  public void buildChildren(Value value, ChildrenBuilder builder, EvaluationContext evaluationContext) {
  }

  @Override
  public PsiElement getChildValueExpression(DebuggerTreeNode node, DebuggerContext context) throws EvaluateException {
    return null;
  }

  @ApiStatus.Internal
  public void setIsApplicableChecker(@NotNull Function<? super Type, ? extends CompletableFuture<Boolean>> isApplicableAsync) {
    myIsApplicableChecker = isApplicableAsync;
  }

  @Override
  public final CompletableFuture<Boolean> isApplicableAsync(Type type) {
    if (myIsApplicableChecker != null) {
      return myIsApplicableChecker.apply(type);
    }
    return NodeRenderer.super.isApplicableAsync(type);
  }

  @Override
  public boolean isExpandable(Value value, EvaluationContext evaluationContext, NodeDescriptor parentDescriptor) {
    return false;
  }

  @Override
  public NodeRendererImpl clone() {
    try {
      final NodeRendererImpl cloned = (NodeRendererImpl)super.clone();
      cloned.myProperties = myProperties.clone();
      return cloned;
    }
    catch (CloneNotSupportedException e) {
      throw new RuntimeException(e);
    }
  }

  @Override
  public void readExternal(Element element) {
    myProperties.readExternal(element, myDefaultName);
  }

  @Override
  public void writeExternal(Element element) {
    myProperties.writeExternal(element, myDefaultName);
  }

  public String toString() {
    return getName();
  }

  @Nullable
  public String calcIdLabel(ValueDescriptor descriptor, DebugProcess process, DescriptorLabelListener labelListener) {
    Value value = descriptor.getValue();
    if (!(value instanceof ObjectReference) || !isShowType()) {
      return null;
    }
    return ValueDescriptorImpl.calcIdLabel(descriptor, labelListener);
  }

  public boolean hasOverhead() {
    return false;
  }

  public static class Overhead implements OverheadProducer {
    private final NodeRendererImpl myRenderer;

    public Overhead(@NotNull NodeRendererImpl renderer) {
      myRenderer = renderer;
    }

    @Override
    public boolean isEnabled() {
      return myRenderer.isEnabled();
    }

    @Override
    public void setEnabled(boolean enabled) {
      myRenderer.setEnabled(enabled);
      NodeRendererSettings.getInstance().fireRenderersChanged();
    }

    @Override
    public void customizeRenderer(SimpleColoredComponent renderer) {
      renderer.append(JavaDebuggerBundle.message("renderer.name", myRenderer.getName()));
    }

    @Override
    public int hashCode() {
      return myRenderer.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
      return obj instanceof Overhead && myRenderer.equals(((Overhead)obj).myRenderer);
    }
  }

  public static String calcLabel(CompletableFuture<NodeRenderer> renderer,
                                 ValueDescriptor descriptor,
                                 EvaluationContext evaluationContext,
                                 DescriptorLabelListener listener) {
    return renderer.thenApply(r -> {
      try {
        return r.calcLabel(descriptor, evaluationContext, listener);
      }
      catch (EvaluateException e) {
        descriptor.setValueLabelFailed(e);
        listener.labelChanged();
        return "";
      }
    }).getNow(XDebuggerUIConstants.getCollectingDataMessage());
  }
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree.render;

import java.util.EventListener;

public interface NodeRendererSettingsListener extends EventListener {
  void renderersChanged();
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.xdebugger.frame.XValueNode;
import org.jetbrains.annotations.NotNull;

public interface OnDemandPresentationProvider {
  void setPresentation(@NotNull final XValueNode node);
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.actions.ForceOnDemandRenderersAction;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.FullValueEvaluatorProvider;
import com.intellij.debugger.engine.JavaDebugProcess;
import com.intellij.debugger.engine.JavaValue;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;
import com.intellij.debugger.ui.impl.watch.ValueDescriptorImpl;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.openapi.util.Key;
import com.intellij.xdebugger.frame.XFullValueEvaluator;
import com.intellij.xdebugger.frame.XValuePlace;
import com.intellij.xdebugger.impl.XDebugSessionImpl;
import com.intellij.xdebugger.impl.ui.tree.nodes.HeadlessValueEvaluationCallback;
import com.intellij.xdebugger.impl.ui.tree.nodes.XValueNodeImpl;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public interface OnDemandRenderer extends FullValueEvaluatorProvider {
  @Nullable
  @Override
  default XFullValueEvaluator getFullValueEvaluator(EvaluationContextImpl evaluationContext,
                                                    ValueDescriptorImpl valueDescriptor) {
    if (isOnDemand(evaluationContext, valueDescriptor) && !isCalculated(valueDescriptor)) {
      return createFullValueEvaluator(getLinkText());
    }
    return null;
  }

  @Nls String getLinkText();

  default boolean isOnDemand(EvaluationContext evaluationContext, ValueDescriptor valueDescriptor) {
    return isOnDemandForced((DebugProcessImpl)evaluationContext.getDebugProcess());
  }

  default boolean isShowValue(ValueDescriptor valueDescriptor, EvaluationContext evaluationContext) {
    return !isOnDemand(evaluationContext, valueDescriptor) || isCalculated(valueDescriptor);
  }

  static XFullValueEvaluator createFullValueEvaluator(@Nls String text) {
    return new XFullValueEvaluator(text) {
      @Override
      public void startEvaluation(@NotNull XFullValueEvaluationCallback callback) {
        if (callback instanceof HeadlessValueEvaluationCallback) {
          XValueNodeImpl node = ((HeadlessValueEvaluationCallback)callback).getNode();
          node.clearFullValueEvaluator();
          setCalculated(((JavaValue)node.getValueContainer()).getDescriptor());
          node.getValueContainer().computePresentation(node, XValuePlace.TREE);
        }
        callback.evaluated("");
      }
    }.setShowValuePopup(false);
  }

  Key<Boolean> ON_DEMAND_CALCULATED = Key.create("ON_DEMAND_CALCULATED");

  static boolean isCalculated(ValueDescriptor descriptor) {
    return ON_DEMAND_CALCULATED.get(descriptor, false);
  }

  static void setCalculated(ValueDescriptor descriptor) {
    ON_DEMAND_CALCULATED.set(descriptor, true);
  }

  static boolean isOnDemandForced(DebugProcessImpl debugProcess) {
    JavaDebugProcess process = debugProcess.getXdebugProcess();
    return process != null && ForceOnDemandRenderersAction.isForcedOnDemand((XDebugSessionImpl)process.getSession());
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.settings.NodeRendererSettings;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.openapi.util.DefaultJDOMExternalizer;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.JDOMExternalizerUtil;
import com.intellij.openapi.util.WriteExternalException;
import com.intellij.openapi.util.text.StringUtil;
import com.sun.jdi.*;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;

public class PrimitiveRenderer extends NodeRendererImpl {
  public static final @NonNls String UNIQUE_ID = "PrimitiveRenderer";

  public boolean SHOW_HEX_VALUE = false;

  public PrimitiveRenderer() {
    super("Primitive");
  }

  @Override
  public String getUniqueId() {
    return UNIQUE_ID;
  }

  @Override
  public void setName(String text) {
    // prohibit name change
  }

  @Override
  public final boolean isEnabled() {
    return true;
  }

  @Override
  public void setEnabled(boolean enabled) {
    // prohibit change
  }

  @Override
  public boolean isApplicable(Type type) {
    return type == null || type instanceof PrimitiveType || type instanceof VoidType;
  }

  @Override
  public String calcLabel(ValueDescriptor valueDescriptor, EvaluationContext evaluationContext, DescriptorLabelListener labelListener) {
    Value value = valueDescriptor.getValue();
    if (value == null) {
      return "null";
    }
    else if (value instanceof PrimitiveValue) {
      if (value instanceof CharValue) {
        StringBuilder buf = new StringBuilder();
        appendCharValue((CharValue)value, buf);
        if (SHOW_HEX_VALUE) {
          appendHexValue((CharValue)value, buf);
        }
        else {
          buf.append(' ').append(((PrimitiveValue)value).longValue());
        }
        return buf.toString();
      }
      else {
        if (SHOW_HEX_VALUE) {
          StringBuilder buf = new StringBuilder();
          buf.append(value);
          appendHexValue((PrimitiveValue)value, buf);
          return buf.toString();
        }
        else {
          return value.toString();
        }
      }
    }
    else {
      return JavaDebuggerBundle.message("label.undefined");
    }
  }

  static void appendCharValue(CharValue value, StringBuilder buf) {
    buf.append('\'');
    String s = value.toString();
    StringUtil.escapeStringCharacters(s.length(), s, "'", buf);
    buf.append('\'');
  }

  private static void appendHexValue(PrimitiveValue value, StringBuilder buf) {
    if (NodeRendererSettings.getInstance().getHexRenderer().isApplicable(value.type())) {
      buf.append(" (");
      HexRenderer.appendHexValue(value, buf);
      buf.append(')');
    }
  }

  public boolean isShowHexValue() {
    return SHOW_HEX_VALUE;
  }

  public void setShowHexValue(boolean show) {
    this.SHOW_HEX_VALUE = show;
  }

  @Override
  public void readExternal(Element element) throws InvalidDataException {
    super.readExternal(element);
    DefaultJDOMExternalizer.readExternal(this, element);
  }

  @Override
  public void writeExternal(Element element) throws WriteExternalException {
    super.writeExternal(element);

    if (SHOW_HEX_VALUE) {
      JDOMExternalizerUtil.writeField(element, "SHOW_HEX_VALUE", "true");
    }
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.impl.DebuggerUtilsAsync;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.util.InvalidDataException;
import com.intellij.openapi.util.WriteExternalException;
import com.intellij.psi.CommonClassNames;
import com.sun.jdi.Type;
import org.jdom.Element;
import org.jetbrains.annotations.NotNull;

import java.util.concurrent.CompletableFuture;

public abstract class ReferenceRenderer implements Renderer {
  private static final Logger LOG = Logger.getInstance(ReferenceRenderer.class);
  protected BasicRendererProperties myProperties = new BasicRendererProperties(false);

  protected ReferenceRenderer() {
    this(CommonClassNames.JAVA_LANG_OBJECT);
  }

  protected ReferenceRenderer(@NotNull String className) {
    myProperties.setClassName(className);
  }

  @Override
  public CompletableFuture<Boolean> isApplicableAsync(Type type) {
    return DebuggerUtilsAsync.instanceOf(type, getClassName());
  }

  public String getClassName() {
    return myProperties.getClassName();
  }

  public void setClassName(String className) {
    myProperties.setClassName(className);
  }

  @Override
  public Renderer clone() {
    try {
      final ReferenceRenderer cloned = (ReferenceRenderer)super.clone();
      cloned.myProperties = myProperties.clone();
      return cloned;
    }
    catch (CloneNotSupportedException e) {
      LOG.error(e);
    }
    return null;
  }

  @Override
  public void writeExternal(Element element) throws WriteExternalException {
    myProperties.writeExternal(element, CommonClassNames.JAVA_LANG_OBJECT);
  }

  @Override
  public void readExternal(Element element) throws InvalidDataException {
    myProperties.readExternal(element, CommonClassNames.JAVA_LANG_OBJECT);
  }

  protected CachedEvaluator createCachedEvaluator() {
    return new CachedEvaluator() {
      @Override
      protected String getClassName() {
        return ReferenceRenderer.this.getClassName();
      }
    };
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.openapi.util.JDOMExternalizable;
import com.sun.jdi.Type;

import java.util.concurrent.CompletableFuture;

public interface Renderer extends Cloneable, JDOMExternalizable {
  String getUniqueId();

  /**
   * Checks whether this renderer is applicable to this type
   *
   * @deprecated override {@link #isApplicableAsync(Type)}
   */
  @Deprecated
  default boolean isApplicable(Type type) {
    throw new AbstractMethodError("Override isApplicableAsync");
  }

  /**
   * Checks whether this renderer is applicable to this type
   */
  default CompletableFuture<Boolean> isApplicableAsync(Type type) {
    return CompletableFuture.completedFuture(isApplicable(type));
  }

  Renderer clone();
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.FullValueEvaluatorProvider;
import com.intellij.debugger.engine.JavaValue;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.execution.filters.ExceptionFilter;
import com.intellij.execution.filters.Filter;
import com.intellij.execution.filters.HyperlinkInfo;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.xdebugger.impl.ui.DebuggerUIUtil;
import com.sun.jdi.*;
import org.jetbrains.annotations.NotNull;

import java.util.Collections;

class StackTraceElementObjectRenderer extends CompoundRendererProvider {
  private static final Logger LOG = Logger.getInstance(StackTraceElementObjectRenderer.class);

  @Override
  protected String getName() {
    return "StackTraceElement";
  }

  @Override
  protected String getClassName() {
    return "java.lang.StackTraceElement";
  }

  @Override
  protected boolean isEnabled() {
    return true;
  }

  @Override
  protected FullValueEvaluatorProvider getFullValueEvaluatorProvider() {
    return (evaluationContext, valueDescriptor) -> new JavaValue.JavaFullValueEvaluator(JavaDebuggerBundle.message("message.node.navigate"),
                                                                                        evaluationContext) {
      @Override
      public void evaluate(@NotNull XFullValueEvaluationCallback callback) {
        Value value = valueDescriptor.getValue();
        ClassType type = ((ClassType)value.type());
        Method toString = DebuggerUtils.findMethod(type, "toString", "()Ljava/lang/String;");
        if (toString != null) {
          try {
            Value res =
              evaluationContext.getDebugProcess()
                .invokeMethod(evaluationContext, (ObjectReference)value, toString, Collections.emptyList());
            if (res instanceof StringReference) {
              callback.evaluated("");
              final String line = ((StringReference)res).value();
              ApplicationManager.getApplication().runReadAction(() -> {
                Project project = valueDescriptor.getProject();
                ExceptionFilter filter = new ExceptionFilter(project, evaluationContext.getDebugProcess().getSession().getSearchScope());
                Filter.Result result = filter.applyFilter(line, line.length());
                if (result != null) {
                  final HyperlinkInfo info = result.getFirstHyperlinkInfo();
                  if (info != null) {
                    DebuggerUIUtil.invokeLater(() -> info.navigate(project));
                  }
                }
              });
            }
          }
          catch (EvaluateException e) {
            LOG.info("Exception while getting stack info", e);
          }
        }
      }

      @Override
      public boolean isShowValuePopup() {
        return false;
      }
    };
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.sun.jdi.LongType;
import com.sun.jdi.LongValue;
import com.sun.jdi.Type;
import com.sun.jdi.Value;

import java.sql.Timestamp;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

public class TimestampRenderer extends CompoundRendererProvider {
  @Override
  protected String getName() {
    return "Timestamp";
  }

  @Override
  protected ValueLabelRenderer getValueLabelRenderer() {
    return new LabelRenderer() {
      @Override
      public String calcLabel(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener labelListener) {
        Value value = descriptor.getValue();
        if (value == null) {
          return "null";
        }
        else if (value instanceof LongValue) {
          return new Timestamp(((LongValue)value).longValue()).toString();
        }
        return null;
      }
    };
  }

  @Override
  protected Function<Type, CompletableFuture<Boolean>> getIsApplicableChecker() {
    return type -> CompletableFuture.completedFuture(type instanceof LongType);
  }
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.SuspendContext;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.managerThread.SuspendContextCommand;
import com.sun.jdi.Value;

public abstract class ToStringCommand implements SuspendContextCommand {
  private final EvaluationContext myEvaluationContext;
  private final Value myValue;

  private boolean myIsEvaluated = false;

  protected ToStringCommand(EvaluationContext evaluationContext, Value value) {
    myEvaluationContext = evaluationContext;
    myValue = value;
  }

  @Override
  public void action() {
    if (myIsEvaluated) return;
    try {
      final String valueAsString = DebuggerUtils.getValueAsString(myEvaluationContext, myValue);
      evaluationResult(valueAsString);
    }
    catch (final EvaluateException ex) {
      evaluationError(ex.getMessage());
    }
  }

  @Override
  public void commandCancelled() {
  }

  public void setEvaluated() {
    myIsEvaluated = true;
  }

  @Override
  public SuspendContext getSuspendContext() {
    return myEvaluationContext.getSuspendContext();
  }

  public abstract void evaluationResult(String message);

  public abstract void evaluationError(String message);

  public Value getValue() {
    return myValue;
  }

  public EvaluationContext getEvaluationContext() {
    return myEvaluationContext;
  }
}

// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.DebugProcessImpl;
import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.impl.DebuggerUtilsAsync;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.ui.tree.DebuggerTreeNode;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.openapi.util.JDOMExternalizerUtil;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.CommonClassNames;
import com.intellij.psi.PsiElement;
import com.intellij.ui.classFilter.ClassFilter;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.xdebugger.impl.ui.XDebuggerUIConstants;
import com.sun.jdi.*;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;

import java.util.concurrent.CompletableFuture;

import static com.intellij.psi.CommonClassNames.JAVA_LANG_STRING;

public class ToStringRenderer extends NodeRendererImpl implements OnDemandRenderer {
  public static final @NonNls String UNIQUE_ID = "ToStringRenderer";

  private boolean USE_CLASS_FILTERS = false;
  private boolean ON_DEMAND;
  private ClassFilter[] myClassFilters = ClassFilter.EMPTY_ARRAY;

  public ToStringRenderer() {
    super(DEFAULT_NAME, true);
    setIsApplicableChecker(type -> {
      // do not render 'String' objects for performance reasons
      if (!(type instanceof ReferenceType) || JAVA_LANG_STRING.equals(type.name())) {
        return CompletableFuture.completedFuture(false);
      }
      return overridesToStringAsync(type);
    });
  }

  @Override
  public String getUniqueId() {
    return UNIQUE_ID;
  }

  @Override
  public String getName() {
    return "toString";
  }

  @Override
  public void setName(String name) {
    // prohibit change
  }

  @Override
  public ToStringRenderer clone() {
    final ToStringRenderer cloned = (ToStringRenderer)super.clone();
    final ClassFilter[] classFilters = (myClassFilters.length > 0) ? new ClassFilter[myClassFilters.length] : ClassFilter.EMPTY_ARRAY;
    for (int idx = 0; idx < classFilters.length; idx++) {
      classFilters[idx] = myClassFilters[idx].clone();
    }
    cloned.myClassFilters = classFilters;
    return cloned;
  }

  @Override
  public String calcLabel(final ValueDescriptor valueDescriptor, EvaluationContext evaluationContext, final DescriptorLabelListener labelListener)
    throws EvaluateException {

    if (!isShowValue(valueDescriptor, evaluationContext)) {
      return "";
    }

    Value value = valueDescriptor.getValue();
    if (value instanceof ObjectReference) {
      DebuggerUtils.ensureNotInsideObjectConstructor((ObjectReference)value, evaluationContext);
    }
    BatchEvaluator.getBatchEvaluator(evaluationContext.getDebugProcess()).invoke(new ToStringCommand(evaluationContext, value) {
      @Override
      public void evaluationResult(String message) {
        valueDescriptor.setValueLabel(
          StringUtil.notNullize(message)
        );
        labelListener.labelChanged();
      }

      @Override
      public void evaluationError(String message) {
        final String msg = value != null ? message + " " + JavaDebuggerBundle
          .message("evaluation.error.cannot.evaluate.tostring", value.type().name()) : message;
        valueDescriptor.setValueLabelFailed(new EvaluateException(msg, null));
        labelListener.labelChanged();
      }
    });
    return XDebuggerUIConstants.getCollectingDataMessage();
  }

  @NotNull
  @Override
  public String getLinkText() {
    return JavaDebuggerBundle.message("message.node.toString");
  }

  public boolean isUseClassFilters() {
    return USE_CLASS_FILTERS;
  }

  public void setUseClassFilters(boolean value) {
    USE_CLASS_FILTERS = value;
  }

  @Override
  public boolean isOnDemand(EvaluationContext evaluationContext, ValueDescriptor valueDescriptor) {
    if (ON_DEMAND || (USE_CLASS_FILTERS && !isFiltered(valueDescriptor.getType()))) {
      return true;
    }
    return OnDemandRenderer.super.isOnDemand(evaluationContext, valueDescriptor);
  }

  private static boolean overridesToString(Type type) {
    if (type instanceof ClassType) {
      Method toStringMethod = DebuggerUtils.findMethod((ReferenceType)type, "toString", "()Ljava/lang/String;");
      return toStringMethod != null && !CommonClassNames.JAVA_LANG_OBJECT.equals(toStringMethod.declaringType().name());
    }
    return false;
  }

  private static CompletableFuture<Boolean> overridesToStringAsync(Type type) {
    if (!DebuggerUtilsAsync.isAsyncEnabled()) {
      return CompletableFuture.completedFuture(overridesToString(type));
    }
    if (type instanceof ClassType) {
      return DebuggerUtilsAsync.findAnyBaseType(type, t -> {
        if (t instanceof ReferenceType) {
          return DebuggerUtilsAsync.methods((ReferenceType)t)
            .thenApply(methods -> {
              return ContainerUtil.exists(methods,
                                          m -> !m.isAbstract() &&
                                               DebuggerUtilsEx.methodMatches(m, "toString", "()Ljava/lang/String;") &&
                                               !CommonClassNames.JAVA_LANG_OBJECT.equals(m.declaringType().name()));
            });
        }
        return CompletableFuture.completedFuture(false);
      }).thenApply(t -> t != null);
    }
    return CompletableFuture.completedFuture(false);
  }

  @Override
  public void buildChildren(Value value, ChildrenBuilder builder, EvaluationContext evaluationContext) {
    DebugProcessImpl.getDefaultRenderer(value).buildChildren(value, builder, evaluationContext);
  }

  @Override
  public PsiElement getChildValueExpression(DebuggerTreeNode node, DebuggerContext context) throws EvaluateException {
    return DebugProcessImpl.getDefaultRenderer(((ValueDescriptor)node.getParent().getDescriptor()).getType())
      .getChildValueExpression(node, context);
  }

  @Override
  public CompletableFuture<Boolean> isExpandableAsync(Value value, EvaluationContext evaluationContext, NodeDescriptor parentDescriptor) {
    return DebugProcessImpl.getDefaultRenderer(value).isExpandableAsync(value, evaluationContext, parentDescriptor);
  }

  @Override
  public void readExternal(Element element) {
    super.readExternal(element);

    ON_DEMAND = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, "ON_DEMAND"));
    USE_CLASS_FILTERS = Boolean.parseBoolean(JDOMExternalizerUtil.readField(element, "USE_CLASS_FILTERS"));
    myClassFilters = DebuggerUtilsEx.readFilters(element.getChildren("filter"));
  }

  @Override
  public void writeExternal(@NotNull Element element) {
    super.writeExternal(element);

    if (ON_DEMAND) {
      JDOMExternalizerUtil.writeField(element, "ON_DEMAND", "true");
    }
    if (USE_CLASS_FILTERS) {
      JDOMExternalizerUtil.writeField(element, "USE_CLASS_FILTERS", "true");
    }
    DebuggerUtilsEx.writeFilters(element, "filter", myClassFilters);
  }

  public ClassFilter[] getClassFilters() {
    return myClassFilters;
  }

  public void setClassFilters(ClassFilter[] classFilters) {
    myClassFilters = classFilters != null ? classFilters : ClassFilter.EMPTY_ARRAY;
  }

  private boolean isFiltered(Type t) {
    if (t instanceof ReferenceType) {
      for (ClassFilter classFilter : myClassFilters) {
        if (classFilter.isEnabled() && DebuggerUtils.instanceOf(t, classFilter.getPattern())) {
          return true;
        }
      }
    }
    return DebuggerUtilsEx.isFiltered(t.name(), myClassFilters);
  }

  public boolean isOnDemand() {
    return ON_DEMAND;
  }

  public void setOnDemand(boolean value) {
    ON_DEMAND = value;
  }

  @Override
  public boolean hasOverhead() {
    return true;
  }

  /**
   * for kotlin compatibility only
   *
   * @deprecated to be removed in IDEA 2021
   */
  @Deprecated
  @Override
  public boolean isApplicable(Type type) {
    if (!(type instanceof ReferenceType)) {
      return false;
    }

    if (JAVA_LANG_STRING.equals(type.name())) {
      return false; // do not render 'String' objects for performance reasons
    }

    return overridesToString(type);
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.DebuggerUtils;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.evaluation.expression.UnBoxingEvaluator;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.CommonClassNames;
import com.intellij.xdebugger.impl.ui.XDebuggerUIConstants;
import com.sun.jdi.ObjectReference;
import com.sun.jdi.PrimitiveValue;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.Type;

import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

public abstract class UnboxableTypeRenderer extends CompoundRendererProvider {
  private static final Logger LOG = Logger.getInstance(UnboxableTypeRenderer.class);
  private final String myClassName;

  protected UnboxableTypeRenderer(String className) {
    LOG.assertTrue(UnBoxingEvaluator.isTypeUnboxable(className));
    myClassName = className;
  }

  @Override
  protected String getName() {
    return StringUtil.getShortName(myClassName);
  }

  @Override
  protected ValueLabelRenderer getValueLabelRenderer() {
    return new LabelRenderer() {
      @Override
      public String calcLabel(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener labelListener)
        throws EvaluateException {
        CompletableFuture<PrimitiveValue> future =
          UnBoxingEvaluator.getInnerPrimitiveValue((ObjectReference)descriptor.getValue(), false);
        if (future.isDone()) {
          return DebuggerUtils.getValueAsString(evaluationContext, future.join());
        }
        return future.handle((r, ex) -> {
          String res = "";
          if (ex == null) {
            try {
              res = DebuggerUtils.getValueAsString(evaluationContext, r);
              descriptor.setValueLabel(res);
            }
            catch (EvaluateException e) {
              descriptor.setValueLabelFailed(e);
            }
          }
          else {
            descriptor.setValueLabelFailed(new EvaluateException(null, ex));
          }
          labelListener.labelChanged();
          return res;
        }).getNow(XDebuggerUIConstants.getCollectingDataMessage());
      }

      @Override
      public boolean isOnDemand(EvaluationContext evaluationContext, ValueDescriptor valueDescriptor) {
        return false;
      }
    };
  }

  @Override
  protected Function<Type, CompletableFuture<Boolean>> getIsApplicableChecker() {
    return type -> CompletableFuture.completedFuture(type instanceof ReferenceType && StringUtil.equals(type.name(), myClassName));
  }

  @Override
  protected boolean isEnabled() {
    return true;
  }

  public static class BooleanRenderer extends UnboxableTypeRenderer {
    public BooleanRenderer() {
      super(CommonClassNames.JAVA_LANG_BOOLEAN);
    }
  }

  public static class ByteRenderer extends UnboxableTypeRenderer {
    public ByteRenderer() {
      super(CommonClassNames.JAVA_LANG_BYTE);
    }
  }

  public static class CharacterRenderer extends UnboxableTypeRenderer {
    public CharacterRenderer() {
      super(CommonClassNames.JAVA_LANG_CHARACTER);
    }
  }

  public static class ShortRenderer extends UnboxableTypeRenderer {
    public ShortRenderer() {
      super(CommonClassNames.JAVA_LANG_SHORT);
    }
  }

  public static class IntegerRenderer extends UnboxableTypeRenderer {
    public IntegerRenderer() {
      super(CommonClassNames.JAVA_LANG_INTEGER);
    }
  }

  public static class LongRenderer extends UnboxableTypeRenderer {
    public LongRenderer() {
      super(CommonClassNames.JAVA_LANG_LONG);
    }
  }

  public static class FloatRenderer extends UnboxableTypeRenderer {
    public FloatRenderer() {
      super(CommonClassNames.JAVA_LANG_FLOAT);
    }
  }

  public static class DoubleRenderer extends UnboxableTypeRenderer {
    public DoubleRenderer() {
      super(CommonClassNames.JAVA_LANG_DOUBLE);
    }
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;

public interface ValueIconRenderer {
  @Nullable
  Icon calcValueIcon(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener listener)
    throws EvaluateException;
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.ui.tree.ValueDescriptor;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;

public interface ValueLabelRenderer extends Renderer, ValueIconRenderer {
  String calcLabel(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener listener) throws EvaluateException;

  @Override
  @Nullable
  default Icon calcValueIcon(ValueDescriptor descriptor, EvaluationContext evaluationContext, DescriptorLabelListener listener)
    throws EvaluateException {
    return null;
  }
}
// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.ui.tree.render;

import com.intellij.debugger.ui.impl.watch.ValueDescriptorImpl;
import com.intellij.xdebugger.frame.presentation.XValuePresentation;
import org.jetbrains.annotations.NotNull;

public interface XValuePresentationProvider {
  @NotNull
  XValuePresentation getPresentation(ValueDescriptorImpl descriptor);
}
/*
 * Copyright 2000-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.intellij.debugger.engine.StackFrameContext;

public interface StackFrameDescriptor extends NodeDescriptor, StackFrameContext {
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.sun.jdi.ReferenceType;

public interface StaticDescriptor extends NodeDescriptor {
  ReferenceType getType();
}
/*
 * Copyright 2000-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.intellij.debugger.engine.jdi.ThreadReferenceProxy;

public interface ThreadDescriptor extends NodeDescriptor {
  ThreadReferenceProxy getThreadReference();
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.intellij.debugger.engine.jdi.ThreadGroupReferenceProxy;

public interface ThreadGroupDescriptor extends NodeDescriptor {
  ThreadGroupReferenceProxy getThreadGroupReference();
}
/*
 * Copyright 2000-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.intellij.debugger.engine.evaluation.EvaluationContextImpl;

public interface UserExpressionDescriptor extends ValueDescriptor {
  void setContext(EvaluationContextImpl evaluationContext);
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.psi.PsiElement;
import com.sun.jdi.Type;
import com.sun.jdi.Value;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;

public interface ValueDescriptor extends NodeDescriptor {
  PsiElement getDescriptorEvaluation(DebuggerContext context) throws EvaluateException;

  Value getValue();

  @Nullable
  default Type getType() {
    Value value = getValue();
    return value != null ? value.type() : null;
  }

  void setValueLabel(String label);

  void setIdLabel(String idLabel);

  String setValueLabelFailed(EvaluateException e);

  Icon setValueIcon(Icon icon);

  boolean isArray();

  boolean isLvalue();

  boolean isNull();

  boolean isPrimitive();

  boolean isString();
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.ui.IconManager;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointGroup;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;

public class XBreakpointClassGroup extends XBreakpointGroup {
  private final String myPackageName;
  private final String myClassName;

  public XBreakpointClassGroup(@Nullable String packageName, String className) {
    myPackageName = packageName != null ? packageName : getDefaultPackageName();
    myClassName = className;
  }

  @Override
  public Icon getIcon(boolean isOpen) {
    return IconManager.getInstance().getPlatformIcon(com.intellij.ui.PlatformIcons.Class);
  }

  @NotNull
  @Override
  public String getName() {
    return getClassName();
  }

  @NotNull
  @NlsSafe
  public String getPackageName() {
    return myPackageName;
  }

  @NotNull
  @NlsSafe
  public String getClassName() {
    return myClassName;
  }

  private static String getDefaultPackageName() {
    return JavaDebuggerBundle.message("default.package.name");
  }
}
/*
 * Copyright 2000-2012 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.ui.breakpoints.Breakpoint;
import com.intellij.debugger.ui.breakpoints.BreakpointManager;
import com.intellij.icons.AllIcons;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointGroupingRule;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointsGroupingPriorities;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.util.Collection;

class XBreakpointGroupingByClassRule<B> extends XBreakpointGroupingRule<B, XBreakpointClassGroup> {
  XBreakpointGroupingByClassRule() {
    super("XBreakpointGroupingByClassRule", JavaDebuggerBundle.message("rule.name.group.by.class"));
  }

  @Override
  public int getPriority() {
    return XBreakpointsGroupingPriorities.BY_CLASS;
  }

  @Override
  public XBreakpointClassGroup getGroup(@NotNull B b, @NotNull Collection<? extends XBreakpointClassGroup> groups) {
    if (b instanceof XBreakpoint) {
      Breakpoint javaBreakpoint = BreakpointManager.getJavaBreakpoint((XBreakpoint)b);
      if (javaBreakpoint == null) {
        return null;
      }
      String className = javaBreakpoint.getShortClassName();
      String packageName = javaBreakpoint.getPackageName();
      if (className == null) {
        return null;
      }
      for (XBreakpointClassGroup group : groups) {
        if (group.getClassName().equals(className) && group.getPackageName().equals(packageName)) {
          return group;
        }
      }
      return new XBreakpointClassGroup(packageName, className);
    }
    return null;
  }

  @Nullable
  @Override
  public Icon getIcon() {
    return AllIcons.Actions.GroupByClass;
  }
}
/*
 * Copyright 2000-2012 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.ui.breakpoints.Breakpoint;
import com.intellij.debugger.ui.breakpoints.BreakpointManager;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointGroupingRule;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointsGroupingPriorities;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.util.Collection;

public class XBreakpointGroupingByPackageRule<B> extends XBreakpointGroupingRule<B, XBreakpointPackageGroup> {

  protected XBreakpointGroupingByPackageRule() {
    super("XBreakpointGroupingByPackageRule", JavaDebuggerBundle.message("rule.name.group.by.package"));
  }

  @Override
  public int getPriority() {
    return XBreakpointsGroupingPriorities.BY_PACKAGE;
  }

  @Override
  public XBreakpointPackageGroup getGroup(@NotNull B breakpoint, @NotNull Collection<? extends XBreakpointPackageGroup> groups) {
    String packageName = null;
    if (breakpoint instanceof XBreakpoint) {
      Breakpoint javaBreakpoint = BreakpointManager.getJavaBreakpoint((XBreakpoint)breakpoint);
      if (javaBreakpoint != null) {
        packageName = javaBreakpoint.getPackageName();
      }
    }
    if (packageName == null) {
      return null;
    }
    for (XBreakpointPackageGroup group : groups) {
      if (StringUtil.equals(group.getPackageName(), packageName)) {
        return group;
      }
    }
    return new XBreakpointPackageGroup(packageName);
  }

  @Nullable
  @Override
  public Icon getIcon() {
    return AllIcons.Actions.GroupByPackage;
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.ui.IconManager;
import com.intellij.ui.PlatformIcons;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointGroup;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;

public class XBreakpointPackageGroup extends XBreakpointGroup {
  private final String myPackageName;

  public XBreakpointPackageGroup(String packageName) {
    myPackageName = packageName;
  }

  @Override
  public Icon getIcon(boolean isOpen) {
    return IconManager.getInstance().getPlatformIcon(PlatformIcons.Package);
  }

  @NotNull
  @Override
  public String getName() {
    String packageName = getPackageName();
    return StringUtil.isEmpty(packageName) ? getDefaultPackageName() : packageName;
  }

  @NotNull
  @NlsSafe
  public String getPackageName() {
    return myPackageName;
  }

  @Nls
  private static String getDefaultPackageName() {
    return JavaDebuggerBundle.message("default.package.name");
  }
}
<?xml version="1.0" encoding="UTF-8"?>
<form xmlns="http://www.intellij.com/uidesigner/form/" version="1" bind-to-class="org.jetbrains.java.debugger.breakpoints.JavaBreakpointFiltersPanel">
  <grid id="27dc6" layout-manager="GridLayoutManager" row-count="2" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
    <margin top="0" left="0" bottom="0" right="0"/>
    <constraints>
      <xy x="20" y="20" width="500" height="400"/>
    </constraints>
    <properties/>
    <border type="none"/>
    <children>
      <grid id="5736" binding="myConditionsPanel" layout-manager="GridLayoutManager" row-count="6" column-count="2" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="7">
        <margin top="2" left="0" bottom="5" right="0"/>
        <constraints>
          <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="7" anchor="0" fill="3" indent="0" use-parent-layout="false"/>
        </constraints>
        <properties/>
        <clientProperties>
          <BorderFactoryClass class="java.lang.String" value="com.intellij.ui.IdeBorderFactory$PlainSmallWithoutIndent"/>
        </clientProperties>
        <border type="none"/>
        <children>
          <grid id="8e867" layout-manager="GridLayoutManager" row-count="2" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="0">
            <margin top="0" left="0" bottom="0" right="0"/>
            <constraints>
              <grid row="1" column="0" row-span="1" col-span="2" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties/>
            <border type="none"/>
            <children>
              <component id="17e11" class="javax.swing.JCheckBox" binding="myInstanceFiltersCheckBox">
                <constraints>
                  <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
                </constraints>
                <properties>
                  <margin top="2" left="2" bottom="0" right="2"/>
                  <text resource-bundle="messages/JavaDebuggerBundle" key="breakpoint.properties.panel.option.instance.filters"/>
                </properties>
              </component>
              <grid id="5231f" layout-manager="GridLayoutManager" row-count="1" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
                <margin top="0" left="0" bottom="0" right="0"/>
                <constraints>
                  <grid row="1" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
                </constraints>
                <properties/>
                <border type="none"/>
                <children>
                  <xy id="28068" binding="myInstanceFiltersFieldPanel" layout-manager="XYLayout" hgap="-1" vgap="-1">
                    <margin top="0" left="0" bottom="0" right="0"/>
                    <constraints>
                      <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
                    </constraints>
                    <properties/>
                    <border type="none"/>
                    <children/>
                  </xy>
                </children>
              </grid>
            </children>
          </grid>
          <grid id="25884" layout-manager="GridLayoutManager" row-count="2" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="0">
            <margin top="0" left="0" bottom="0" right="0"/>
            <constraints>
              <grid row="2" column="0" row-span="1" col-span="2" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties/>
            <border type="none"/>
            <children>
              <component id="729d5" class="javax.swing.JCheckBox" binding="myClassFiltersCheckBox">
                <constraints>
                  <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
                </constraints>
                <properties>
                  <margin top="2" left="2" bottom="0" right="2"/>
                  <text resource-bundle="messages/JavaDebuggerBundle" key="breakpoint.properties.panel.option.class.filters"/>
                </properties>
              </component>
              <grid id="9bef6" layout-manager="GridLayoutManager" row-count="1" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
                <margin top="0" left="0" bottom="0" right="0"/>
                <constraints>
                  <grid row="1" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
                </constraints>
                <properties/>
                <border type="none"/>
                <children>
                  <component id="d2464" class="com.intellij.debugger.ui.breakpoints.ClassFiltersField" binding="myClassFiltersField" custom-create="true">
                    <constraints>
                      <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
                    </constraints>
                    <properties/>
                  </component>
                </children>
              </grid>
            </children>
          </grid>
          <grid id="275ca" layout-manager="GridLayoutManager" row-count="2" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="0">
            <margin top="0" left="0" bottom="0" right="0"/>
            <constraints>
              <grid row="3" column="0" row-span="1" col-span="2" vsize-policy="3" hsize-policy="7" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties/>
            <border type="none"/>
            <children>
              <component id="27bbc" class="javax.swing.JCheckBox" binding="myPassCountCheckbox">
                <constraints>
                  <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
                </constraints>
                <properties>
                  <margin top="2" left="2" bottom="0" right="2"/>
                  <text resource-bundle="messages/JavaDebuggerBundle" key="breakpoint.properties.panel.option.pass.count"/>
                </properties>
              </component>
              <grid id="71095" binding="myPassCountFieldPanel" layout-manager="GridLayoutManager" row-count="1" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
                <margin top="0" left="0" bottom="0" right="0"/>
                <constraints>
                  <grid row="1" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
                </constraints>
                <properties/>
                <border type="none"/>
                <children>
                  <component id="33fef" class="javax.swing.JTextField" binding="myPassCountField">
                    <constraints>
                      <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="6" anchor="8" fill="1" indent="0" use-parent-layout="false">
                        <preferred-size width="15" height="-1"/>
                      </grid>
                    </constraints>
                    <properties>
                      <enabled value="false"/>
                      <horizontalAlignment value="10"/>
                    </properties>
                  </component>
                </children>
              </grid>
            </children>
          </grid>
          <vspacer id="d1c29">
            <constraints>
              <grid row="5" column="1" row-span="1" col-span="1" vsize-policy="6" hsize-policy="1" anchor="0" fill="2" indent="0" use-parent-layout="false"/>
            </constraints>
          </vspacer>
          <grid id="350e7" binding="myCatchFiltersPanel" layout-manager="GridLayoutManager" row-count="2" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="0">
            <margin top="0" left="0" bottom="0" right="0"/>
            <constraints>
              <grid row="0" column="0" row-span="1" col-span="2" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties/>
            <border type="none"/>
            <children>
              <component id="c5dfb" class="javax.swing.JCheckBox" binding="myCatchCheckBox">
                <constraints>
                  <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
                </constraints>
                <properties>
                  <margin top="2" left="2" bottom="0" right="2"/>
                  <text resource-bundle="messages/JavaDebuggerBundle" key="breakpoint.properties.panel.option.catch.class.filters"/>
                </properties>
              </component>
              <grid id="63496" layout-manager="GridLayoutManager" row-count="1" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
                <margin top="0" left="0" bottom="0" right="0"/>
                <constraints>
                  <grid row="1" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
                </constraints>
                <properties/>
                <border type="none"/>
                <children>
                  <component id="73a6e" class="com.intellij.debugger.ui.breakpoints.ClassFiltersField" binding="myCatchClassFilters" custom-create="true">
                    <constraints>
                      <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
                    </constraints>
                    <properties/>
                  </component>
                </children>
              </grid>
            </children>
          </grid>
          <grid id="c9672" binding="myCallerFiltersPanel" layout-manager="GridLayoutManager" row-count="2" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="0">
            <margin top="0" left="0" bottom="0" right="0"/>
            <constraints>
              <grid row="4" column="0" row-span="1" col-span="2" vsize-policy="3" hsize-policy="7" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
            </constraints>
            <properties/>
            <border type="none"/>
            <children>
              <component id="b5dce" class="javax.swing.JCheckBox" binding="myCallerFiltersCheckBox">
                <constraints>
                  <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="0" hsize-policy="3" anchor="8" fill="0" indent="0" use-parent-layout="false"/>
                </constraints>
                <properties>
                  <margin top="2" left="2" bottom="0" right="2"/>
                  <text resource-bundle="messages/JavaDebuggerBundle" key="breakpoint.properties.panel.option.caller.filter"/>
                </properties>
              </component>
              <grid id="63d4d" layout-manager="GridLayoutManager" row-count="1" column-count="1" same-size-horizontally="false" same-size-vertically="false" hgap="-1" vgap="-1">
                <margin top="0" left="0" bottom="0" right="0"/>
                <constraints>
                  <grid row="1" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
                </constraints>
                <properties/>
                <border type="none"/>
                <children>
                  <component id="e6e72" class="com.intellij.debugger.ui.breakpoints.CallerFiltersField" binding="myCallerFilters" custom-create="true">
                    <constraints>
                      <grid row="0" column="0" row-span="1" col-span="1" vsize-policy="3" hsize-policy="3" anchor="0" fill="1" indent="0" use-parent-layout="false"/>
                    </constraints>
                    <properties/>
                  </component>
                </children>
              </grid>
            </children>
          </grid>
        </children>
      </grid>
    </children>
  </grid>
</form>
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.java.debugger.breakpoints;

import com.intellij.debugger.InstanceFilter;
import com.intellij.debugger.ui.breakpoints.CallerFiltersField;
import com.intellij.debugger.ui.breakpoints.ClassFiltersField;
import com.intellij.debugger.ui.breakpoints.EditInstanceFiltersDialog;
import com.intellij.ide.util.ClassFilter;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.PsiClass;
import com.intellij.ui.FieldPanel;
import com.intellij.ui.MultiLineTooltipUI;
import com.intellij.ui.components.fields.ExtendableTextField;
import com.intellij.util.text.LiteralFormatUtil;
import com.intellij.util.ui.JBUI;
import com.intellij.xdebugger.breakpoints.XBreakpoint;
import com.intellij.xdebugger.breakpoints.ui.XBreakpointCustomPropertiesPanel;
import com.intellij.xdebugger.impl.breakpoints.XBreakpointBase;
import com.intellij.xdebugger.impl.ui.DebuggerUIUtil;
import one.util.streamex.StreamEx;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties;
import org.jetbrains.java.debugger.breakpoints.properties.JavaExceptionBreakpointProperties;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class JavaBreakpointFiltersPanel<T extends JavaBreakpointProperties, B extends XBreakpoint<T>> extends XBreakpointCustomPropertiesPanel<B> {
  private JPanel myConditionsPanel;
  private JCheckBox myInstanceFiltersCheckBox;
  private JPanel myInstanceFiltersFieldPanel;
  private JCheckBox myClassFiltersCheckBox;
  private ClassFiltersField myClassFiltersField;
  private JCheckBox myPassCountCheckbox;
  private JTextField myPassCountField;
  private JCheckBox myCatchCheckBox;
  private ClassFiltersField myCatchClassFilters;
  private JPanel myCatchFiltersPanel;
  private JPanel myPassCountFieldPanel;
  private JCheckBox myCallerFiltersCheckBox;
  private CallerFiltersField myCallerFilters;
  private JPanel myCallerFiltersPanel;

  private final FieldPanel myInstanceFiltersField;

  private InstanceFilter[] myInstanceFilters = InstanceFilter.EMPTY_ARRAY;
  protected final Project myProject;

  private PsiClass myBreakpointPsiClass;

  public JavaBreakpointFiltersPanel(Project project) {
    myProject = project;
    myInstanceFiltersField = new FieldPanel(new MyTextField(), "", null,
                                            new ActionListener() {
                                              @Override
                                              public void actionPerformed(ActionEvent e) {
                                                reloadInstanceFilters();
                                                EditInstanceFiltersDialog _dialog = new EditInstanceFiltersDialog(myProject);
                                                _dialog.setFilters(myInstanceFilters);
                                                _dialog.show();
                                                if (_dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {
                                                  myInstanceFilters = _dialog.getFilters();
                                                  updateInstanceFilterEditor(true);
                                                }
                                              }
                                            },
                                            null
    );

    ActionListener updateListener = new ActionListener() {
      @Override
      public void actionPerformed(ActionEvent e) {
        updateCheckboxes();
      }
    };

    myPassCountCheckbox.addActionListener(updateListener);
    myInstanceFiltersCheckBox.addActionListener(updateListener);
    myClassFiltersCheckBox.addActionListener(updateListener);
    myCatchCheckBox.addActionListener(updateListener);
    myCallerFiltersCheckBox.addActionListener(updateListener);

    ToolTipManager.sharedInstance().registerComponent(myInstanceFiltersField.getTextField());

    insert(myInstanceFiltersFieldPanel, myInstanceFiltersField);

    myCatchClassFilters.setBorder(JBUI.Borders.emptyLeft(myCatchCheckBox.getInsets().left));
    myInstanceFiltersField.setBorder(JBUI.Borders.emptyLeft(myInstanceFiltersCheckBox.getInsets().left));
    myClassFiltersField.setBorder(JBUI.Borders.emptyLeft(myClassFiltersCheckBox.getInsets().left));
    myPassCountFieldPanel.setBorder(JBUI.Borders.emptyLeft(myPassCountCheckbox.getInsets().left));
    myCallerFilters.setBorder(JBUI.Borders.emptyLeft(myCallerFiltersCheckBox.getInsets().left));

    DebuggerUIUtil.focusEditorOnCheck(myPassCountCheckbox, myPassCountField);
    DebuggerUIUtil.focusEditorOnCheck(myInstanceFiltersCheckBox, myInstanceFiltersField.getTextField());
    DebuggerUIUtil.focusEditorOnCheck(myClassFiltersCheckBox, myClassFiltersField.getTextField());
    DebuggerUIUtil.focusEditorOnCheck(myCatchCheckBox, myCatchClassFilters.getTextField());
    DebuggerUIUtil.focusEditorOnCheck(myCallerFiltersCheckBox, myCallerFilters);
  }

  @NotNull
  @Override
  public JComponent getComponent() {
    return myConditionsPanel;
  }

  @Override
  public boolean isVisibleOnPopup(@NotNull B breakpoint) {
    JavaBreakpointProperties properties = breakpoint.getProperties();
    if (properties != null) {
      return properties.isCOUNT_FILTER_ENABLED() ||
             properties.isCLASS_FILTERS_ENABLED() ||
             properties.isINSTANCE_FILTERS_ENABLED() ||
             properties.isCALLER_FILTERS_ENABLED() ||
             (properties instanceof JavaExceptionBreakpointProperties &&
              ((JavaExceptionBreakpointProperties)properties).isCatchFiltersEnabled());
    }
    return false;
  }

  @Override
  public void saveTo(@NotNull B breakpoint) {
    JavaBreakpointProperties properties = breakpoint.getProperties();
    if (properties == null) {
      return;
    }

    boolean changed = false;
    try {
      String text = LiteralFormatUtil.removeUnderscores(myPassCountField.getText().trim());
      int filter = !text.isEmpty() ? Integer.parseInt(text) : 0;
      if (filter < 0) filter = 0;
      changed = properties.setCOUNT_FILTER(filter);
    }
    catch (Exception ignored) {
    }

    changed = properties.setCOUNT_FILTER_ENABLED(properties.getCOUNT_FILTER() > 0 && myPassCountCheckbox.isSelected()) || changed;
    reloadInstanceFilters();
    updateInstanceFilterEditor(true);

    if (properties instanceof JavaExceptionBreakpointProperties exceptionBreakpointProperties) {
      changed = exceptionBreakpointProperties.setCatchFiltersEnabled(!myCatchClassFilters.getText().isEmpty() && myCatchCheckBox.isSelected()) || changed;
      changed = exceptionBreakpointProperties.setCatchClassFilters(myCatchClassFilters.getClassFilters()) || changed;
      changed = exceptionBreakpointProperties.setCatchClassExclusionFilters(myCatchClassFilters.getClassExclusionFilters()) || changed;
    }

    changed = properties.setCLASS_FILTERS_ENABLED(!myClassFiltersField.getText().isEmpty() && myClassFiltersCheckBox.isSelected()) || changed;
    changed = properties.setClassFilters(myClassFiltersField.getClassFilters()) || changed;
    changed = properties.setClassExclusionFilters(myClassFiltersField.getClassExclusionFilters()) || changed;

    changed = properties.setINSTANCE_FILTERS_ENABLED(!myInstanceFiltersField.getText().isEmpty() && myInstanceFiltersCheckBox.isSelected()) || changed;
    changed = properties.setInstanceFilters(myInstanceFilters) || changed;

    changed = properties.setCALLER_FILTERS_ENABLED(!myCallerFilters.getText().isEmpty() && myCallerFiltersCheckBox.isSelected()) || changed;
    changed = properties.setCallerFilters(myCallerFilters.getClassFilters()) || changed;
    changed = properties.setCallerExclusionFilters(myCallerFilters.getClassExclusionFilters()) || changed;

    if (changed) {
      ((XBreakpointBase<?, ?, ?>)breakpoint).fireBreakpointChanged();
    }
  }

  private static void insert(JPanel panel, JComponent component) {
    panel.setLayout(new BorderLayout());
    panel.add(component, BorderLayout.CENTER);
  }

  @Override
  public void loadFrom(@NotNull B breakpoint) {
    myCatchFiltersPanel.setVisible(false);
    myCallerFiltersPanel.setVisible(false);

    JavaBreakpointProperties properties = breakpoint.getProperties();
    if (properties != null) {
      if (properties.getCOUNT_FILTER() > 0) {
        myPassCountField.setText(Integer.toString(properties.getCOUNT_FILTER()));
      }
      else {
        myPassCountField.setText("");
      }

      myPassCountCheckbox.setSelected(properties.isCOUNT_FILTER_ENABLED());

      myInstanceFiltersCheckBox.setSelected(properties.isINSTANCE_FILTERS_ENABLED());
      myInstanceFilters = properties.getInstanceFilters();
      updateInstanceFilterEditor(true);

      myClassFiltersCheckBox.setSelected(properties.isCLASS_FILTERS_ENABLED());
      myClassFiltersField.setClassFilters(properties.getClassFilters(), properties.getClassExclusionFilters());

      if (properties instanceof JavaExceptionBreakpointProperties exceptionBreakpointProperties) {
        myCatchFiltersPanel.setVisible(true);
        myCatchCheckBox.setSelected(exceptionBreakpointProperties.isCatchFiltersEnabled());
        myCatchClassFilters.setClassFilters(exceptionBreakpointProperties.getCatchClassFilters(),
                                            exceptionBreakpointProperties.getCatchClassExclusionFilters());
      }

      myCallerFiltersPanel.setVisible(true);
      myCallerFiltersCheckBox.setSelected(properties.isCALLER_FILTERS_ENABLED());
      myCallerFilters.setClassFilters(properties.getCallerFilters(), properties.getCallerExclusionFilters());

      //XSourcePosition position = breakpoint.getSourcePosition();
      // TODO: need to calculate psi class
      //myBreakpointPsiClass = breakpoint.getPsiClass();
    }
    updateCheckboxes();
  }

  private void updateInstanceFilterEditor(boolean updateText) {
    List<String> filters = StreamEx.of(myInstanceFilters).filter(InstanceFilter::isEnabled).map(f -> Long.toString(f.getId())).toList();
    if (updateText) {
      myInstanceFiltersField.setText(StringUtil.join(filters, " "));
    }

    String tipText = concatWithEx(filters, " ", (int)Math.sqrt(myInstanceFilters.length) + 1, "\n");
    myInstanceFiltersField.getTextField().setToolTipText(tipText);
  }

  private void createUIComponents() {
    myClassFiltersField = new ClassFiltersField(myProject, this);
    myCatchClassFilters = new ClassFiltersField(myProject, this);
    myCallerFilters = new CallerFiltersField(myProject, this);
  }

  private class MyTextField extends ExtendableTextField {
    MyTextField() {
    }

    @Override
    public String getToolTipText(MouseEvent event) {
      reloadInstanceFilters();
      updateInstanceFilterEditor(false);
      String toolTipText = super.getToolTipText(event);
      return getToolTipText().length() == 0 ? null : toolTipText;
    }

    @Override
    public JToolTip createToolTip() {
      JToolTip toolTip = new JToolTip() {{
        setUI(new MultiLineTooltipUI());
      }};
      toolTip.setComponent(this);
      return toolTip;
    }
  }

  private void reloadInstanceFilters() {
    String filtersText = myInstanceFiltersField.getText();

    ArrayList<InstanceFilter> idxs = new ArrayList<>();
    int startNumber = -1;
    for (int i = 0; i <= filtersText.length(); i++) {
      if (i < filtersText.length() && Character.isDigit(filtersText.charAt(i))) {
        if (startNumber == -1) {
          startNumber = i;
        }
      }
      else {
        if (startNumber >= 0) {
          idxs.add(InstanceFilter.create(filtersText.substring(startNumber, i)));
          startNumber = -1;
        }
      }
    }
    myInstanceFilters = StreamEx.of(myInstanceFilters).remove(InstanceFilter::isEnabled).prepend(idxs).toArray(InstanceFilter[]::new);
  }

  @Contract(pure = true)
  private static String concatWithEx(List<String> s, String concator, int N, String NthConcator) {
    StringBuilder result = new StringBuilder();
    int i = 1;
    for (Iterator iterator = s.iterator(); iterator.hasNext(); i++) {
      String str = (String)iterator.next();
      result.append(str);
      if (iterator.hasNext()) {
        if (i % N == 0) {
          result.append(NthConcator);
        }
        else {
          result.append(concator);
        }
      }
    }
    return result.toString();
  }

  protected ClassFilter createClassConditionFilter() {
    ClassFilter classFilter;
    if (myBreakpointPsiClass != null) {
      classFilter = new ClassFilter() {
        @Override
        public boolean isAccepted(PsiClass aClass) {
          return myBreakpointPsiClass == aClass || aClass.isInheritor(myBreakpointPsiClass, true);
        }
      };
    }
    else {
      classFilter = null;
    }
    return classFilter;
  }

  protected void updateCheckboxes() {
    boolean passCountApplicable = true;
    if (myInstanceFiltersCheckBox.isSelected() || myClassFiltersCheckBox.isSelected()) {
      passCountApplicable = false;
    }
    myPassCountCheckbox.setEnabled(passCountApplicable);

    final boolean passCountSelected = myPassCountCheckbox.isSelected();
    myInstanceFiltersCheckBox.setEnabled(!passCountSelected);
    myClassFiltersCheckBox.setEnabled(!passCountSelected);

    myPassCountField.setEditable(myPassCountCheckbox.isSelected());
    myPassCountField.setEnabled(myPassCountCheckbox.isSelected());

    myInstanceFiltersField.setEnabled(myInstanceFiltersCheckBox.isSelected());
    myInstanceFiltersField.getTextField().setEditable(myInstanceFiltersCheckBox.isSelected());

    myClassFiltersField.setEnabled(myClassFiltersCheckBox.isSelected());
    myClassFiltersField.setEditable(myClassFiltersCheckBox.isSelected());

    myCatchClassFilters.setEnabled(myCatchCheckBox.isSelected());
    myCatchClassFilters.setEditable(myCatchCheckBox.isSelected());

    myCallerFilters.setEnabled(myCallerFiltersCheckBox.isSelected());
    myCallerFilters.setEditable(myCallerFiltersCheckBox.isSelected());
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.java.debugger.breakpoints.properties;

import com.intellij.debugger.InstanceFilter;
import com.intellij.ui.classFilter.ClassFilter;
import com.intellij.util.ArrayUtil;
import com.intellij.util.xmlb.annotations.OptionTag;
import com.intellij.util.xmlb.annotations.XCollection;
import com.intellij.xdebugger.breakpoints.XBreakpointProperties;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Arrays;

public class JavaBreakpointProperties<T extends JavaBreakpointProperties> extends XBreakpointProperties<T> {
  private boolean COUNT_FILTER_ENABLED = false;
  private int COUNT_FILTER = 0;

  private boolean CLASS_FILTERS_ENABLED = false;
  private ClassFilter[] myClassFilters;
  private ClassFilter[] myClassExclusionFilters;

  private boolean INSTANCE_FILTERS_ENABLED = false;
  private InstanceFilter[] myInstanceFilters;

  private boolean CALLER_FILTERS_ENABLED = false;
  private ClassFilter[] myCallerFilters;
  private ClassFilter[] myCallerExclusionFilters;

  private boolean TRACING_START = false;
  private boolean TRACING_END = false;

  @XCollection(propertyElementName = "instance-filters")
  public InstanceFilter[] getInstanceFilters() {
    return myInstanceFilters != null ? myInstanceFilters : InstanceFilter.EMPTY_ARRAY;
  }

  public boolean setInstanceFilters(InstanceFilter[] instanceFilters) {
    boolean changed = !filtersEqual(myInstanceFilters, instanceFilters);
    myInstanceFilters = instanceFilters;
    return changed;
  }

  public void addInstanceFilter(long l) {
    InstanceFilter newFilter = InstanceFilter.create(l);
    if (myInstanceFilters == null) {
      myInstanceFilters = new InstanceFilter[]{newFilter};
    }
    else {
      myInstanceFilters = ArrayUtil.append(myInstanceFilters, newFilter);
    }
  }

  @XCollection(propertyElementName = "class-filters")
  public final ClassFilter[] getClassFilters() {
    return myClassFilters != null ? myClassFilters : ClassFilter.EMPTY_ARRAY;
  }

  public final boolean setClassFilters(ClassFilter[] classFilters) {
    boolean changed = !filtersEqual(myClassFilters, classFilters);
    myClassFilters = classFilters;
    return changed;
  }

  protected static boolean filtersEqual(Object[] a, Object[] b) {
    if ((a == null || a.length == 0) && (b == null || b.length == 0)) {
      return true;
    }
    return Arrays.equals(a, b);
  }

  @XCollection(propertyElementName = "class-exclusion-filters")
  public ClassFilter[] getClassExclusionFilters() {
    return myClassExclusionFilters != null ? myClassExclusionFilters : ClassFilter.EMPTY_ARRAY;
  }

  public boolean setClassExclusionFilters(ClassFilter[] classExclusionFilters) {
    boolean changed = !filtersEqual(myClassExclusionFilters, classExclusionFilters);
    myClassExclusionFilters = classExclusionFilters;
    return changed;
  }

  @Nullable
  @Override
  public T getState() {
    return (T)this;
  }

  @Override
  public void loadState(@NotNull T state) {
    setCOUNT_FILTER_ENABLED(state.isCOUNT_FILTER_ENABLED());
    setCOUNT_FILTER(state.getCOUNT_FILTER());

    setCLASS_FILTERS_ENABLED(state.isCLASS_FILTERS_ENABLED());
    myClassFilters = state.getClassFilters();
    myClassExclusionFilters = state.getClassExclusionFilters();

    setINSTANCE_FILTERS_ENABLED(state.isINSTANCE_FILTERS_ENABLED());
    myInstanceFilters = state.getInstanceFilters();

    setCALLER_FILTERS_ENABLED(state.isCALLER_FILTERS_ENABLED());
    myCallerFilters = state.getCallerFilters();
    myCallerExclusionFilters = state.getCallerExclusionFilters();

    setTRACING_START(state.isTRACING_START());
    setTRACING_END(state.isTRACING_END());
  }

  @OptionTag("count-filter-enabled")
  public boolean isCOUNT_FILTER_ENABLED() {
    return COUNT_FILTER_ENABLED;
  }

  public boolean setCOUNT_FILTER_ENABLED(boolean COUNT_FILTER_ENABLED) {
    boolean changed = this.COUNT_FILTER_ENABLED != COUNT_FILTER_ENABLED;
    this.COUNT_FILTER_ENABLED = COUNT_FILTER_ENABLED;
    return changed;
  }

  @OptionTag("count-filter")
  public int getCOUNT_FILTER() {
    return COUNT_FILTER;
  }

  public boolean setCOUNT_FILTER(int COUNT_FILTER) {
    boolean changed = this.COUNT_FILTER != COUNT_FILTER;
    this.COUNT_FILTER = COUNT_FILTER;
    return changed;
  }

  @OptionTag("class-filters-enabled")
  public boolean isCLASS_FILTERS_ENABLED() {
    return CLASS_FILTERS_ENABLED;
  }

  public boolean setCLASS_FILTERS_ENABLED(boolean CLASS_FILTERS_ENABLED) {
    boolean changed = this.CLASS_FILTERS_ENABLED != CLASS_FILTERS_ENABLED;
    this.CLASS_FILTERS_ENABLED = CLASS_FILTERS_ENABLED;
    return changed;
  }

  @OptionTag("instance-filters-enabled")
  public boolean isINSTANCE_FILTERS_ENABLED() {
    return INSTANCE_FILTERS_ENABLED;
  }

  public boolean setINSTANCE_FILTERS_ENABLED(boolean INSTANCE_FILTERS_ENABLED) {
    boolean changed = this.INSTANCE_FILTERS_ENABLED != INSTANCE_FILTERS_ENABLED;
    this.INSTANCE_FILTERS_ENABLED = INSTANCE_FILTERS_ENABLED;
    return changed;
  }

  @OptionTag("caller-filters-enabled")
  public boolean isCALLER_FILTERS_ENABLED() {
    return CALLER_FILTERS_ENABLED;
  }

  public boolean setCALLER_FILTERS_ENABLED(boolean CALLER_FILTERS_ENABLED) {
    boolean changed = this.CALLER_FILTERS_ENABLED != CALLER_FILTERS_ENABLED;
    this.CALLER_FILTERS_ENABLED = CALLER_FILTERS_ENABLED;
    return changed;
  }

  @XCollection(propertyElementName = "caller-filters")
  public ClassFilter[] getCallerFilters() {
    return myCallerFilters != null ? myCallerFilters : ClassFilter.EMPTY_ARRAY;
  }

  public boolean setCallerFilters(ClassFilter[] callerFilters) {
    boolean changed = !filtersEqual(myCallerFilters, callerFilters);
    myCallerFilters = callerFilters;
    return changed;
  }

  @XCollection(propertyElementName = "caller-exclusion-filters")
  public ClassFilter[] getCallerExclusionFilters() {
    return myCallerExclusionFilters != null ? myCallerExclusionFilters : ClassFilter.EMPTY_ARRAY;
  }

  public boolean setCallerExclusionFilters(ClassFilter[] callerExclusionFilters) {
    boolean changed = !filtersEqual(myCallerExclusionFilters, callerExclusionFilters);
    myCallerExclusionFilters = callerExclusionFilters;
    return changed;
  }

  @OptionTag("tracing-start")
  public boolean isTRACING_START() {
    return TRACING_START;
  }

  public boolean setTRACING_START(boolean TRACING_START) {
    boolean changed = this.TRACING_START != TRACING_START;
    this.TRACING_START = TRACING_START;
    return changed;
  }

  @OptionTag("tracing-end")
  public boolean isTRACING_END() {
    return TRACING_END;
  }

  public boolean setTRACING_END(boolean TRACING_END) {
    boolean changed = this.TRACING_END != TRACING_END;
    this.TRACING_END = TRACING_END;
    return changed;
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.java.debugger.breakpoints.properties;

import com.intellij.openapi.util.NlsSafe;
import com.intellij.util.xmlb.annotations.Attribute;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

@ApiStatus.Experimental
public class JavaCollectionBreakpointProperties extends JavaBreakpointProperties<JavaCollectionBreakpointProperties> {
  public boolean SHOULD_SAVE_COLLECTION_HISTORY = true;

  @Attribute("field")
  @NlsSafe
  public String myFieldName;

  @Attribute("class")
  @NlsSafe
  public String myClassName;

  public JavaCollectionBreakpointProperties(String fieldName, String className) {
    myFieldName = fieldName;
    myClassName = className;
  }

  public JavaCollectionBreakpointProperties() {
  }

  @Nullable
  @Override
  public JavaCollectionBreakpointProperties getState() {
    return this;
  }

  @Override
  public void loadState(@NotNull JavaCollectionBreakpointProperties state) {
    super.loadState(state);
    SHOULD_SAVE_COLLECTION_HISTORY = state.SHOULD_SAVE_COLLECTION_HISTORY;
    myFieldName = state.myFieldName;
    myClassName = state.myClassName;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.java.debugger.breakpoints.properties;

import com.intellij.ui.classFilter.ClassFilter;
import com.intellij.util.xmlb.annotations.Attribute;
import com.intellij.util.xmlb.annotations.OptionTag;
import com.intellij.util.xmlb.annotations.XCollection;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class JavaExceptionBreakpointProperties extends JavaBreakpointProperties<JavaExceptionBreakpointProperties> {
  public boolean NOTIFY_CAUGHT = true;
  public boolean NOTIFY_UNCAUGHT = true;

  @Attribute("class")
  public String myQualifiedName;

  @Attribute("package")
  public String myPackageName;

  private boolean myCatchFiltersEnabled = false;
  private ClassFilter[] myCatchClassFilters;
  private ClassFilter[] myCatchClassExclusionFilters;

  public JavaExceptionBreakpointProperties(String qualifiedName, String packageName) {
    myQualifiedName = qualifiedName;
    myPackageName = packageName;
  }

  public JavaExceptionBreakpointProperties() {
  }

  @Nullable
  @Override
  public JavaExceptionBreakpointProperties getState() {
    return this;
  }

  @Override
  public void loadState(@NotNull JavaExceptionBreakpointProperties state) {
    super.loadState(state);

    NOTIFY_CAUGHT = state.NOTIFY_CAUGHT;
    NOTIFY_UNCAUGHT = state.NOTIFY_UNCAUGHT;
    myQualifiedName = state.myQualifiedName;
    myPackageName = state.myPackageName;

    setCatchFiltersEnabled(state.isCatchFiltersEnabled());
    myCatchClassFilters = state.getCatchClassFilters();
    myCatchClassExclusionFilters = state.getCatchClassExclusionFilters();
  }

  @OptionTag("catch-filters-enabled")
  public boolean isCatchFiltersEnabled() {
    return myCatchFiltersEnabled;
  }

  public boolean setCatchFiltersEnabled(boolean enabled) {
    boolean changed = myCatchFiltersEnabled != enabled;
    myCatchFiltersEnabled = enabled;
    return changed;
  }

  @XCollection(propertyElementName = "catch-class-filters")
  public final ClassFilter[] getCatchClassFilters() {
    return myCatchClassFilters != null ? myCatchClassFilters : ClassFilter.EMPTY_ARRAY;
  }

  public final boolean setCatchClassFilters(ClassFilter[] classFilters) {
    boolean changed = !filtersEqual(myCatchClassFilters, classFilters);
    myCatchClassFilters = classFilters;
    return changed;
  }

  @XCollection(propertyElementName = "catch-class-exclusion-filters")
  public ClassFilter[] getCatchClassExclusionFilters() {
    return myCatchClassExclusionFilters != null ? myCatchClassExclusionFilters : ClassFilter.EMPTY_ARRAY;
  }

  public boolean setCatchClassExclusionFilters(ClassFilter[] classExclusionFilters) {
    boolean changed = !filtersEqual(myCatchClassExclusionFilters, classExclusionFilters);
    myCatchClassExclusionFilters = classExclusionFilters;
    return changed;
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.java.debugger.breakpoints.properties;

import com.intellij.openapi.util.NlsSafe;
import com.intellij.util.xmlb.annotations.Attribute;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class JavaFieldBreakpointProperties extends JavaBreakpointProperties<JavaFieldBreakpointProperties> {
  public boolean WATCH_MODIFICATION = true;
  public boolean WATCH_ACCESS = false;

  @Attribute("field")
  @NlsSafe
  public String myFieldName;

  @Attribute("class")
  @NlsSafe
  public String myClassName;

  public JavaFieldBreakpointProperties(String fieldName, String className) {
    myFieldName = fieldName;
    myClassName = className;
  }

  public JavaFieldBreakpointProperties() {
  }

  @Nullable
  @Override
  public JavaFieldBreakpointProperties getState() {
    return this;
  }

  @Override
  public void loadState(@NotNull JavaFieldBreakpointProperties state) {
    super.loadState(state);

    WATCH_MODIFICATION = state.WATCH_MODIFICATION;
    WATCH_ACCESS = state.WATCH_ACCESS;
    myFieldName = state.myFieldName;
    myClassName = state.myClassName;
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package org.jetbrains.java.debugger.breakpoints.properties;

import com.intellij.util.xmlb.annotations.OptionTag;
import com.intellij.util.xmlb.annotations.Transient;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class JavaLineBreakpointProperties extends JavaBreakpointProperties<JavaLineBreakpointProperties> {
  // TODO: rework encoding of inline position, introduce enum/class-based external API

  // null - stop at line and all lambdas
  // -1 - stop only at the base position (first on the line)
  // 0 or more - index of the lambda on the line to stop at
  // -10 or less - stop only at single conditional return statement (-10 at the base method, (-10-i) at the i-th lambda)
  private @Nullable Integer encodedInlinePosition = null;

  private static final int COND_RET_CODE = -10;

  public static int encodeInlinePosition(int lambdaOrdinal, boolean conditionalReturn) {
    return !conditionalReturn
           ? lambdaOrdinal
           : COND_RET_CODE - lambdaOrdinal - 1;
  }

  @Transient
  public @Nullable Integer getLambdaOrdinal() {
    if (encodedInlinePosition == null) {
      return null;
    }
    int n = encodedInlinePosition;
    return n <= COND_RET_CODE ? (COND_RET_CODE - n - 1) : n;
  }

  public boolean isConditionalReturn() {
    return encodedInlinePosition != null && encodedInlinePosition <= COND_RET_CODE;
  }

  @OptionTag("lambda-ordinal") // naming is a historic accident
  public @Nullable Integer getEncodedInlinePosition() {
    return encodedInlinePosition;
  }

  public void setEncodedInlinePosition(@Nullable Integer inlinePositionEncoded) {
    encodedInlinePosition = inlinePositionEncoded;
  }

  /**
   * @deprecated this method is only for backward compatibility,
   *             use {@link #setEncodedInlinePosition(Integer)}
   */
  @Deprecated(forRemoval = true)
  public void setLambdaOrdinal(Integer lambdaOrdinal) {
    setEncodedInlinePosition(lambdaOrdinal);
  }

  @Override
  public void loadState(@NotNull JavaLineBreakpointProperties state) {
    super.loadState(state);

    encodedInlinePosition = state.encodedInlinePosition;
  }

}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.java.debugger.breakpoints.properties;

import com.intellij.util.xmlb.annotations.Attribute;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class JavaMethodBreakpointProperties extends JavaBreakpointProperties<JavaMethodBreakpointProperties> {
  @Attribute("class")
  public String myClassPattern;

  @Attribute("method")
  public String myMethodName;

  public boolean EMULATED = false;
  public boolean WATCH_ENTRY = true;
  public boolean WATCH_EXIT = true;

  public JavaMethodBreakpointProperties(String classPattern, String methodName) {
    myClassPattern = classPattern;
    myMethodName = methodName;
  }

  public JavaMethodBreakpointProperties() {
  }

  @Nullable
  @Override
  public JavaMethodBreakpointProperties getState() {
    return this;
  }

  @Override
  public void loadState(@NotNull JavaMethodBreakpointProperties state) {
    super.loadState(state);

    myClassPattern = state.myClassPattern;
    myMethodName = state.myMethodName;

    EMULATED = state.EMULATED;
    WATCH_ENTRY = state.WATCH_ENTRY;
    WATCH_EXIT = state.WATCH_EXIT;
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package org.jetbrains.java.debugger;

import com.intellij.debugger.engine.evaluation.CodeFragmentFactory;
import com.intellij.debugger.engine.evaluation.TextWithImports;
import com.intellij.debugger.engine.evaluation.TextWithImportsImpl;
import com.intellij.debugger.impl.DebuggerUtilsEx;
import com.intellij.debugger.impl.DebuggerUtilsImpl;
import com.intellij.ide.highlighter.JavaFileType;
import com.intellij.lang.Language;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.fileTypes.FileType;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.*;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.xdebugger.XExpression;
import com.intellij.xdebugger.XSourcePosition;
import com.intellij.xdebugger.evaluation.EvaluationMode;
import com.intellij.xdebugger.evaluation.XDebuggerEditorsProviderBase;
import com.intellij.xdebugger.impl.breakpoints.XExpressionImpl;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;
import java.util.Collections;

public class JavaDebuggerEditorsProvider extends XDebuggerEditorsProviderBase {
  @NotNull
  @Override
  public FileType getFileType() {
    return JavaFileType.INSTANCE;
  }

  @Override
  protected PsiFile createExpressionCodeFragment(@NotNull Project project,
                                                 @NotNull String text,
                                                 @Nullable PsiElement context,
                                                 boolean isPhysical) {
    return JavaCodeFragmentFactory.getInstance(project).createExpressionCodeFragment(text, context, null, isPhysical);
  }

  @NotNull
  @Override
  public Collection<Language> getSupportedLanguages(@Nullable PsiElement context) {
    return ContainerUtil.map(DebuggerUtilsEx.getCodeFragmentFactories(context), factory -> factory.getFileType().getLanguage());
  }

  @NotNull
  @Override
  public Collection<Language> getSupportedLanguages(@NotNull Project project, @Nullable XSourcePosition sourcePosition) {
    if (sourcePosition != null) {
      return getSupportedLanguages(getContextElement(sourcePosition.getFile(), sourcePosition.getOffset(), project));
    }
    return Collections.emptyList();
  }

  @NotNull
  @Override
  public XExpression createExpression(@NotNull Project project, @NotNull Document document, @Nullable Language language, @NotNull EvaluationMode mode) {
    PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(document);
    if (psiFile instanceof JavaCodeFragment) {
      return new XExpressionImpl(document.getText(), language, StringUtil.nullize(((JavaCodeFragment)psiFile).importsToString()), mode);
    }
    return super.createExpression(project, document, language, mode);
  }

  @Override
  protected PsiFile createExpressionCodeFragment(@NotNull Project project,
                                                 @NotNull XExpression expression,
                                                 @Nullable PsiElement context,
                                                 boolean isPhysical) {
    TextWithImports text = TextWithImportsImpl.fromXExpression(expression);
    if (text != null) {
      CodeFragmentFactory factory = DebuggerUtilsEx.findAppropriateCodeFragmentFactory(text, context);
      JavaCodeFragment codeFragment = factory.createPresentationCodeFragment(text, context, project);

      if (context != null) {
        PsiType contextType = context.getUserData(DebuggerUtilsImpl.PSI_TYPE_KEY);
        if (contextType == null) {
          PsiClass contextClass = PsiTreeUtil.getNonStrictParentOfType(context, PsiClass.class);
          if (contextClass != null) {
            contextType = JavaPsiFacade.getElementFactory(codeFragment.getProject()).createType(contextClass);
          }
        }
        codeFragment.setThisType(contextType);
      }

      return codeFragment;
    }
    else {
      return super.createExpressionCodeFragment(project, expression, context, isPhysical);
    }
  }
}
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module" module-name="intellij.platform.util" />
    <orderEntry type="module-library">
      <library name="debugger-memory-agent" type="repository">
        <properties maven-id="org.jetbrains.intellij.deps:debugger-memory-agent:1.0.43">
          <verification>
            <artifact url="file://$MAVEN_REPOSITORY$/org/jetbrains/intellij/deps/debugger-memory-agent/1.0.43/debugger-memory-agent-1.0.43.jar">
              <sha256sum>8915bdd1d6afc9df4eb1003069f40b7d24794b869c7dd1c849e45c1eb98269d8</sha256sum>
            </artifact>
          </verification>
        </properties>
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/jetbrains/intellij/deps/debugger-memory-agent/1.0.43/debugger-memory-agent-1.0.43.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES>
          <root url="jar://$MAVEN_REPOSITORY$/org/jetbrains/intellij/deps/debugger-memory-agent/1.0.43/debugger-memory-agent-1.0.43-sources.jar!/" />
        </SOURCES>
      </library>
    </orderEntry>
    <orderEntry type="library" name="commons-io" level="project" />
    <orderEntry type="library" name="kotlin-stdlib" level="project" />
  </component>
</module>
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.memory.agent.extractor

import com.intellij.openapi.util.io.FileUtil
import com.intellij.openapi.util.io.FileUtilRt
import java.io.File
import java.io.FileNotFoundException
import java.nio.file.Files
import java.nio.file.Path

object AgentExtractor {
  private lateinit var extractedFile: File
  private var lastModified = -1L

  @Synchronized
  fun extract(agentType: AgentLibraryType, directory: Path): Path {
    if (!::extractedFile.isInitialized || !extractedFile.exists() || extractedFile.lastModified() != lastModified) {
        val agentFileName = "${agentType.prefix}memory_agent${agentType.suffix}"
        val file = FileUtilRt.createTempFile(directory.toFile(), "${agentType.prefix}memory_agent", agentType.suffix, true)
        val inputStream = AgentExtractor::class.java.classLoader.getResourceAsStream("bin/$agentFileName") ?: throw FileNotFoundException(agentFileName)
        inputStream.use { input ->
          Files.newOutputStream(file.toPath()).use { output ->
            FileUtil.copy(input, output)
          }
        }
        extractedFile = file
        lastModified = file.lastModified()
    }

    return extractedFile.toPath()
  }

  enum class AgentLibraryType(val prefix: String, val suffix: String) {
    WINDOWS32("", "32.dll"),
    WINDOWS64("", ".dll"),
    WINDOWS_ARM64("", "64a.dll"),
    LINUX_X64("lib", ".so"),
    LINUX_AARCH64("lib", "_aarch64.so"),
    MACOS("lib", ".dylib")
  }
}
// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.memory.agent.extractor

import org.apache.commons.io.IOUtils

class ProxyExtractor {
  fun extractProxy(): ByteArray {
    return IOUtils.toByteArray(ProxyExtractor::class.java.classLoader.getResourceAsStream("com/intellij/memory/agent/IdeaNativeAgentProxy.class"))
  }
}
<?xml version="1.0" encoding="UTF-8"?>
<module relativePaths="true" type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/resources" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module" module-name="intellij.java.execution" />
    <orderEntry type="module" module-name="intellij.jsp" />
    <orderEntry type="module" module-name="intellij.java.psi" />
    <orderEntry type="module" module-name="intellij.java.resources.en" />
    <orderEntry type="module" module-name="intellij.platform.util.jdom" />
    <orderEntry type="module" module-name="intellij.platform.ide" />
    <orderEntry type="module" module-name="intellij.platform.lang" />
    <orderEntry type="module" module-name="intellij.platform.debugger" exported="" />
    <orderEntry type="module" module-name="intellij.platform.core.ui" />
    <orderEntry type="module" module-name="intellij.platform.ide.util.io" />
  </component>
  <component name="copyright">
    <Base>
      <setting name="state" value="0" />
    </Base>
    <LanguageOptions name="HTML">
      <option name="templateOptions">
        <value>
          <option name="block" value="true" />
          <option name="separateBefore" value="false" />
          <option name="separateAfter" value="false" />
          <option name="prefixLines" value="true" />
          <option name="lenBefore" value="80" />
          <option name="lenAfter" value="80" />
          <option name="box" value="false" />
          <option name="filler" value=" " />
        </value>
      </option>
      <option name="notice" value="Copyright (c) &amp;#36;today.year, Your Corporation. All Rights Reserved." />
      <option name="keyword" value="Copyright" />
      <option name="fileTypeOverride" value="2" />
      <option name="relativeBefore" value="true" />
      <option name="addBlankAfter" value="true" />
      <option name="fileLocation" value="1" />
      <option name="useAlternate" value="false" />
    </LanguageOptions>
    <LanguageOptions name="JAVA">
      <option name="templateOptions">
        <value>
          <option name="block" value="true" />
          <option name="separateBefore" value="false" />
          <option name="separateAfter" value="false" />
          <option name="prefixLines" value="true" />
          <option name="lenBefore" value="80" />
          <option name="lenAfter" value="80" />
          <option name="box" value="false" />
          <option name="filler" value=" " />
        </value>
      </option>
      <option name="notice" value="/*&#10; * Copyright 2000-2005 JetBrains s.r.o.&#10; * &#10; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&#10; * you may not use this file except in compliance with the License.&#10; * You may obtain a copy of the License at&#10; * &#10; * http://www.apache.org/licenses/LICENSE-2.0&#10; * &#10; * Unless required by applicable law or agreed to in writing, software&#10; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#10; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#10; * See the License for the specific language governing permissions and&#10; * limitations under the License.&#10; */" />
      <option name="keyword" value="Copyright" />
      <option name="fileTypeOverride" value="2" />
      <option name="relativeBefore" value="true" />
      <option name="addBlankAfter" value="true" />
      <option name="fileLocation" value="1" />
      <option name="useAlternate" value="false" />
    </LanguageOptions>
    <LanguageOptions name="JSP">
      <option name="templateOptions">
        <value>
          <option name="block" value="true" />
          <option name="separateBefore" value="false" />
          <option name="separateAfter" value="false" />
          <option name="prefixLines" value="true" />
          <option name="lenBefore" value="80" />
          <option name="lenAfter" value="80" />
          <option name="box" value="false" />
          <option name="filler" value=" " />
        </value>
      </option>
      <option name="notice" value="Copyright (c) &amp;#36;today.year, Your Corporation. All Rights Reserved." />
      <option name="keyword" value="Copyright" />
      <option name="fileTypeOverride" value="2" />
      <option name="relativeBefore" value="true" />
      <option name="addBlankAfter" value="true" />
      <option name="fileLocation" value="1" />
      <option name="useAlternate" value="false" />
    </LanguageOptions>
    <LanguageOptions name="JavaScript">
      <option name="templateOptions">
        <value>
          <option name="block" value="true" />
          <option name="separateBefore" value="false" />
          <option name="separateAfter" value="false" />
          <option name="prefixLines" value="true" />
          <option name="lenBefore" value="80" />
          <option name="lenAfter" value="80" />
          <option name="box" value="false" />
          <option name="filler" value=" " />
        </value>
      </option>
      <option name="notice" value="Copyright (c) &amp;#36;today.year, Your Corporation. All Rights Reserved." />
      <option name="keyword" value="Copyright" />
      <option name="fileTypeOverride" value="2" />
      <option name="relativeBefore" value="true" />
      <option name="addBlankAfter" value="true" />
      <option name="fileLocation" value="1" />
      <option name="useAlternate" value="false" />
    </LanguageOptions>
    <LanguageOptions name="Properties">
      <option name="templateOptions">
        <value>
          <option name="block" value="true" />
          <option name="separateBefore" value="false" />
          <option name="separateAfter" value="false" />
          <option name="prefixLines" value="true" />
          <option name="lenBefore" value="80" />
          <option name="lenAfter" value="80" />
          <option name="box" value="false" />
          <option name="filler" value=" " />
        </value>
      </option>
      <option name="notice" value="Copyright (c) &amp;#36;today.year, Your Corporation. All Rights Reserved." />
      <option name="keyword" value="Copyright" />
      <option name="fileTypeOverride" value="2" />
      <option name="relativeBefore" value="true" />
      <option name="addBlankAfter" value="true" />
      <option name="fileLocation" value="1" />
      <option name="useAlternate" value="false" />
    </LanguageOptions>
    <LanguageOptions name="XML">
      <option name="templateOptions">
        <value>
          <option name="block" value="true" />
          <option name="separateBefore" value="false" />
          <option name="separateAfter" value="false" />
          <option name="prefixLines" value="true" />
          <option name="lenBefore" value="80" />
          <option name="lenAfter" value="80" />
          <option name="box" value="false" />
          <option name="filler" value=" " />
        </value>
      </option>
      <option name="notice" value="Copyright (c) &amp;#36;today.year, Your Corporation. All Rights Reserved." />
      <option name="keyword" value="Copyright" />
      <option name="fileTypeOverride" value="2" />
      <option name="relativeBefore" value="true" />
      <option name="addBlankAfter" value="true" />
      <option name="fileLocation" value="1" />
      <option name="useAlternate" value="false" />
    </LanguageOptions>
    <LanguageOptions name="__TEMPLATE__">
      <option name="templateOptions">
        <value>
          <option name="block" value="true" />
          <option name="separateBefore" value="false" />
          <option name="separateAfter" value="false" />
          <option name="prefixLines" value="true" />
          <option name="lenBefore" value="80" />
          <option name="lenAfter" value="80" />
          <option name="box" value="false" />
          <option name="filler" value=" " />
        </value>
      </option>
      <option name="notice" value="Copyright 2000-&amp;#36;{today.year} JetBrains s.r.o.&#10;&#10;Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&#10;you may not use this file except in compliance with the License.&#10;You may obtain a copy of the License at&#10;&#10;http://www.apache.org/licenses/LICENSE-2.0&#10;&#10;Unless required by applicable law or agreed to in writing, software&#10;distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#10;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#10;See the License for the specific language governing permissions and&#10;limitations under the License." />
      <option name="keyword" value="Copyright" />
      <option name="fileTypeOverride" value="4" />
      <option name="relativeBefore" value="true" />
      <option name="addBlankAfter" value="true" />
      <option name="fileLocation" value="1" />
      <option name="useAlternate" value="false" />
    </LanguageOptions>
  </component>
</module>
evaluation.error.empty.code.fragment=Code fragment expected
evaluation.error.cannot.evaluate.tostring=Cannot evaluate {0}.toString()
evaluation.error.unsupported.expression.type=Unsupported expression type
evaluation.error.object.is.being.initialized=Object is being initialized
internal.error.locations.of.line=Internal error loading debug information from ''{0}''.  Breakpoints will be unavailable in this class.
evaluation.error.inconsistent.debug.info=Debug information is inconsistent
evaluation.error.boolean.value.expected.in.condition='boolean' value expected in condition
evaluation.error.boolean.condition.expected='boolean' value expected in condition
evaluation.error.process.exited=Cannot evaluate: process exited
evaluation.error.stack.frame.unavailable=Stack frame unavailable
evaluation.error.nested.evaluation=Evaluation is not supported during another method's evaluation
evaluation.error.sources.out.of.sync=Sources do not correspond to code being executed
evaluation.error.cannot.find.stackframe.source=Cannot find source class for current stack frame
evaluation.error.cannot.find.source=Cannot find source class for {0}
evaluation.error.object.collected=Object has been collected
evaluation.error.thread.collected=Thread has been collected
evaluation.error.array.collected=Array has been collected
evaluation.error.thread.resumed=Thread has been resumed
evaluation.error.debug.info.unavailable=Debug info unavailable
evaluation.error.invalid.expression=Invalid expression : {0}
evaluation.error.unknown.expression.type=Expression type unknown: {0}
evaluation.error.unknown.expression.operand=Expression operand unknown: {0}
evaluation.error.type.mismatch=Type mismatch
evaluation.error.class.not.loaded=Class ''{0}'' is not loaded
evaluation.error.thread.not.at.breakpoint=Cannot evaluate methods after Pause action
evaluation.error.method.exception=Method threw ''{0}'' exception.
evaluation.error.surrounded.expression.null=Surrounded expression is null
title.customize.data.views=Customize Data Views
title.evaluating=Evaluating...
error.native.method.exception=None of the frames through and including frame may be native
error.executing.finally=Error while executing finally blocks: {0}
error.early.return=Error while doing early return: {0}
error.throw.exception=Error while throwing exception: {0}
warning.finally.block.detected=Non-empty finally blocks detected:
button.drop.anyway=Do Not Execute
button.execute.finally=Execute Finally Blocks
drop.frame.error.no.information=Information about the frame is not available
progress.evaluating=Evaluating {0}
action.resume.thread.text.resume=Resume
action.interrupt.thread.text=Interrupt
title.set.value=Set Value
warning.recalculate=The value will be recalculated
warning.source.code.not.match=Source code does not match the bytecode
action.add.field.watchpoint.text=Add Field Watchpoint
status.process.started=Process started
status.process.terminated=Process terminated
status.disconnected=Disconnected from the target VM, address: {0}
status.stopped.at.cursor=Stopped at cursor
status.line.breakpoint.reached=Breakpoint reached at {0}({1}:{2,number,#})
status.line.breakpoint.reached.full.trace=Breakpoint reached
status.generic.breakpoint.reached=Breakpoint reached
status.thread.blocked.by=Stepping in thread {0} is blocked by thread {1}
status.thread.blocked.by.resume=<a href="#">Resume {0}</a>
status.breakpoint.reached.in.thread=Breakpoint reached in thread {0}
status.breakpoint.reached.in.thread.switch=<a href="#">Switch thread</a>
status.method.entry.breakpoint.reached=Method ''{0}'' entered at {1}({2}:{3,number,#})
status.method.exit.breakpoint.reached=Method breakpoint reached. Method ''{0}'' is about to exit at {1}({2}:{3,number,#})
status.field.watchpoint.reached.access='{'{0}@{5}'}'.{1} will be accessed at {2}({3}:{4,number,#})
status.static.field.watchpoint.reached.access={0}.{1} will be accessed at {2}({3}:{4,number,#})
status.field.watchpoint.reached.modification='{'{0}@{7}'}'.{1} will be modified at {4}({5}:{6,number,#}). Current value = ''{2}''. New value = ''{3}''
status.static.field.watchpoint.reached.modification={0}.{1} will be modified at {4}({5}:{6,number,#}). Current value = ''{2}''. New value = ''{3}''
status.connected=Connected to the target VM, address: {0}
status.connect.failed=Failed to establish connection to the target VM, address: {0}
error.debugger.already.listening=Debugger is already listening
transport.name.shared.memory=shared memory
transport.name.socket=socket
error.debug.connector.not.found=Required connector ''{0}'' not found. Check your JDK installation.
error.no.debug.listen.port=The port to listen at unspecified
error.no.debug.attach.port=The port to attach to unspecified
error.no.shmem.address=Shared memory address unspecified
error.no.pid=Pid is not specified
debugger.jdi.bootstrap.error={0}. Check your JDK installation.
warning.jdk140.unstable=The debuggee VM version is "1.4.0".\nJ2SDK 1.4.0 documented bugs may cause unstable debugger behavior.\nWe recommend using J2SDK 1.4.0_01 or higher.
title.jdk140.unstable=VM Version Warning
message.remote.jre.version.mismatch=Target JRE version ({0})\ndoes not match project JDK version ({1}), \nwill use sources from JDK: {2}
message.breakpoint.skipped.during.evaluation=Skipped breakpoint at {0} because it happened inside debugger evaluation
message.breakpoint.skipped.other.vm=Skipped breakpoint at {0} because it happened outside current JVM
message.breakpoint.skipped.during.stepping.in.another.thread=Skipped breakpoint at {0} because of stepping in another thread
message.breakpoint.skipped.learn.more=Troubleshooting guide
error.invalid.argument={0,choice, 1#Invalid argument|2#Invalid arguments} 
error.vm.disconnected=VM disconnected. Target virtual machine closed connection
error.unknown.host=Cannot connect to remote process. Host is unknown
error.unknown.host.with.address=Cannot connect to remote process. Host is unknown ({0})
error.cannot.open.debugger.port=Unable to open debugger port
error.exception.while.connecting=Error connecting to remote process.\nException occurred: {0}\nException message: {1}
status.waiting.attach=Debugger is waiting for application to start
status.waiting.attach.address=debug address: {0}
status.listening=Listening to the connection, address: {0}
status.connecting=Connecting to the target VM, address: {0}
status.app.running=The application is running
status.debug.stopped=Debug stopped
status.waiting.evaluation.result=Waiting until last debugger command completes
status.step.out=Stepping out
status.step.into=Stepping into
status.step.over=Stepping over
status.run.to.cursor=Run to cursor
status.process.resumed=Process resumed
status.paused.in.another.thread=Paused in another thread
string.connection=''{0}'', transport: ''{1}''
error.pop.bottom.stackframe=Cannot pop bottom frame
error.pop.stackframe=An error occurred while popping stack frame: {0}
error.class.not.loaded=Class not loaded : {0}
string.file.line.position=Class at {0}:{1}
string.null.context=null context
evaluation.error.array.reference.expected=Array reference expected
evaluation.error.invalid.index.expression=Invalid index expression
evaluation.error.not.rvalue=Right part of the assignment is not a value
evaluation.error.not.lvalue=Left part of the assignment is not lvalue
evaluation.error.incompatible.types=Incompatible types for ''{0}'' operation
evaluation.error.lebeled.loops.not.found=No loop statements labeled with label ''{0}''
evaluation.error.variable.not.declared=Variable ''{0}'' is not declared
evaluation.error.variable.already.declared=Variable ''{0}'' is already declared
evaluation.error.operation.not.supported=Operation ''{0}'' is not supported
evaluation.error.statement.not.supported=Statement ''{0}'' is not supported
evaluation.error.incompatible.variable.initializer.type=Initializer for ''{0}'' has incompatible type
evaluation.error.local.variable.missing.from.class.closure=Local variable ''{0}'' not found in class closure
evaluation.error.local.variable.missing=Cannot find local variable ''{0}''
evaluation.error.cannot.resolve.field.class=Cannot resolve class containing field ''{0}''
evaluation.error.cannot.sources.for.field.class=Cannot find sources for class containing field ''{0}''
evaluation.error.identifier.expected=Identifier expected instead of ''{0}''
evaluation.error.cannot.evaluate.qualifier=Cannot evaluate qualifier ''{0}''
evaluation.error.invalid.array.dimension.expression=Invalid expression for array dimension: {0}
evaluation.error.multi.dimensional.arrays.creation.not.supported=Creation of multi-dimensional arrays not supported
evaluation.error.anonymous.class.evaluation.not.supported=Anonymous class evaluation is not supported
evaluation.error.lambda.evaluation.not.supported=Lambdas evaluation is not supported
evaluation.error.method.reference.evaluation.not.supported=Method reference evaluation is not supported
evaluation.error.no.static.field=No such static field: ''{0}''
evaluation.error.no.instance.field=No such instance field: ''{0}''
evaluation.error.class.or.array.expected=Class or array type expected while evaluating field ''{0}''
evaluation.error.evaluating.field=Error evaluating field : ''{0}''
evaluation.error.evaluating.method=Error evaluating method : ''{0}''
evaluation.error.object.reference.expected=Object reference expected
evaluation.error.no.stackframe=Cannot evaluate: stack frame unavailable
evaluation.error.no.static.method=No such static method: ''{0}''
evaluation.error.no.instance.method=No such instance method: ''{0}''
evaluation.error.array.type.expected=Array type expected
evaluation.error.array.dimention.numeric.value.expected=Numeric value expected as array dimension
evaluation.error.cannot.evaluate.array.initializer=Cannot evaluate array initializer
evaluation.error.incompatible.array.initializer.type=Initializer type is not assignment-compatible with array's component type
evaluation.error.invalid.array.size=Invalid array size
evaluation.error.cannot.initialize.array=Cannot initialize array
evaluation.error.cannot.evaluate.class.type=Cannot evaluate class type
evaluation.error.cannot.resolve.constructor=Cannot resolve constructor ''{0}''
evaluation.error.this.not.avalilable='this' is not available
evaluation.error.cannot.cast.null=Cannot cast null to ''{0}''
evaluation.error.cannot.cast.numeric=Cannot cast numeric value to ''{0}''
evaluation.error.cannot.cast.boolean=Cannot cast boolean value to ''{0}''
evaluation.error.cannot.cast.char=Cannot cast char value to ''{0}''
evaluation.error.cannot.cast.object=Cannot cast ''{0}'' to ''{1}''
evaluation.error.numeric.expected=Numeric value expected
evaluation.error.integer.expected=Integer value expected
evaluation.error.boolean.expected=Boolean value expected
evaluation.error.during.indexing=Evaluation is not possible during indexing
status.invalid.breakpoint.out.of.class=Breakpoint does not belong to any class
error.invalid.breakpoint.source.changed=Source file changed or found source file does not correspond to the breakpoint's file
error.invalid.breakpoint.source.not.found=The class {0}, found in the project classpath, has no associated source files
status.paused=Paused
status.thread.monitor=MONITOR
status.thread.not.started=NOT_STARTED
status.thread.running=RUNNING
status.thread.sleeping=SLEEPING
status.thread.unknown=UNKNOWN
status.thread.wait=WAIT
status.thread.zombie=ZOMBIE
status.thread.undefined=UNDEFINED
progress.hotswap.scanning.path=Scanning: {0}
progress.hotswap.scanning.classes=Scanning for classes to reload...
progress.hotswap.reloading=Reloading classes...
error.operation.canceled=Operation canceled
error.operation.not.supported.by.vm=Operation not supported by VM
error.class.def.not.found=Class definition not found : {0}
error.verification.error=Verification error : {0}
error.unsupported.class.version=Unsupported class version : {0}
error.class.format.error=Class format error : {0}
error.class.circularity.error=Class circularity error : {0}
error.exception.while.reloading=Exception while reloading classes : {0} : {1}
status.hotswap.loaded.classes.up.to.date=Loaded classes are up to date. Nothing to reload
error.io.error=I/O error
status.classes.reloaded={0,number} {0,choice, 0#classes|1#class|2#classes} reloaded
status.classes.not.all.versions.reloaded=For {0} of {1} {1,choice, 1#class|2#classes} not all versions were reloaded
warning.range.too.big=Range specified is too big. {0} needs too much resources to perform requested operation. Are you sure you want to continue?
title.range.too.big=Range Is Too Big
error.array.renderer.configurable.start.index.less.than.zero=Start index is less than 0
error.array.renderer.configurable.end.index.less.than.start=End index is less than start index
label.array.renderer.configurable.start.index=Array sta&rt index:
label.array.renderer.configurable.end.index=en&d index:
label.array.renderer.configurable.max.count1=Show &maximum
label.array.renderer.configurable.max.count2=array elements
label.base.renderer.configurable.autoscroll=Autoscroll to new &local variables
label.base.renderer.configurable.dfa.assist=Predict condition values and exceptions based on data flow analysis
label.base.renderer.configurable.dfa.assist.gray.out=Gray out blocks of code that are predicted to be unreachable
label.base.renderer.configurable.show.synthetic.fields=S&ynthetic fields
label.base.renderer.configurable.show.val.fields.as.locals=$val fields as local &variables
label.base.renderer.configurable.hide.null.array.elements=Hide &null elements in arrays and collections
label.base.renderer.configurable.show.static.fields=&Static fields
label.base.renderer.configurable.show.static.final.fields=Static &final fields
label.base.renderer.configurable.show.declared.type=Declared &type
label.base.renderer.configurable.show.fq.names=Fully &qualified names
label.base.renderer.configurable.show.object.id=Object &id
label.base.renderer.configurable.show.hex.value=Show hex value for primitives
label.base.renderer.configurable.show.strings.type=Show type for strings
label.base.renderer.configurable.populate.throwable.stack=Auto populate Throwable object's stack trace
label.base.renderer.configurable.alternate.view=Enable alternative view for Coll&ections classes
label.base.renderer.configurable.enable.toString=Enable 't&oString()' object view:
label.base.renderer.configurable.all.overriding=For all classes that override 'toString()' method
label.base.renderer.configurable.classes.from.list=For classes from the list:
label.compound.renderer.configurable.show.type=Show type and object id
label.compound.renderer.configurable.ondemand=On-demand
label.compound.renderer.configurable.use.default.renderer=Use default renderer
label.compound.renderer.configurable.use.expression=Use following expression:
label.compound.renderer.configurable.use.expression.list=Use list of expressions:
label.compound.renderer.configurable.apply.to=Apply renderer to objects of type (fully qualified name):
error.compound.renderer.configurable.fqn.generic=Generic type is not allowed
label.compound.renderer.configurable.when.rendering=When rendering a node
label.compound.renderer.configurable.when.expanding=When expanding a node
label.compound.renderer.configurable.test.can.expand=Test if a node can be expanded (optional):
title.compound.renderer.configurable.choose.renderer.reference.type=Renderer Reference Type
label.compound.renderer.configurable.append.default.children=Append default children
button.add=Add
label.compound.renderer.configurable.table.header.name=Name
label.compound.renderer.configurable.table.header.expression=Expression
label.compound.renderer.configurable.table.header.ondemand=On-demand
label.debugger.hotswap.configurable.compile.before.hotswap=Build project before reloading classes
label.debugger.hotswap.configurable.enable.vm.hang.warning=Enable 'JVM will hang' warning
label.debugger.hotswap.configurable.reload.classes=Reload classes after compilation:
label.debugger.hotswap.configurable.always=&Always
label.debugger.hotswap.configurable.never=&Never
label.debugger.hotswap.configurable.ask=As&k
label.debugger.launching.configurable.disable.jit=Disable JIT
label.debugger.launching.configurable.debugger.transport=Transport:
label.debugger.launching.configurable.socket=&Socket
label.debugger.launching.configurable.shmem=Shared &memory
label.debugger.general.configurable.show.alternative.source=Show alternative source switcher
label.debugger.general.configurable.kill.immediately=Kill the debug process immediately
label.debugger.general.configurable.always.debug=Start run configurations with the debug agent
label.debugger.general.configurable.enable.memory.agent=Attach memory agent
label.debugger.general.configurable.enable.memory.agent.tooltip.text=Java debugger will provide additional information about objects in the heap
label.debugger.general.configurable.always.smart.step.into=A&lways do smart step into
label.debugger.general.configurable.skip.synthetic.methods=Ski&p synthetic methods
label.debugger.general.configurable.skip.constructors=Skip &constructors
label.debugger.general.configurable.skip.classLoaders=Skip class l&oaders
label.debugger.general.configurable.skip.simple.getters=Skip simple &getters
label.debugger.general.configurable.step.filters.list.header=Do not step &into the classes
label.debugger.general.configurable.evaluate.finally.on.pop=Evaluate finally blocks on pop frame and early return:
label.debugger.general.configurable.evaluate.finally.always=&Always
label.debugger.general.configurable.evaluate.finally.never=N&ever
label.debugger.general.configurable.evaluate.finally.ask=As&k
label.debugger.general.configurable.resume.only.current.thread=Resume only the current thread
label.threads.view.configurable.show.source.file.name=Show source file name
label.threads.view.configurable.show.class.name=Show class name
label.threads.view.configurable.show.package=Show package name
label.threads.view.configurable.show.line.number=Show &line number
label.threads.view.configurable.current.thread.on.top=Move current thread to the top
label.threads.view.configurable.show.stack.frames.for.synthetic.methods=Show stack &frames for synthetic methods
label.threads.view.configurable.show.thread.groups=Show thread &groups
label.capture.configurable.capture.variables=Capture local variables (may greatly slow down the execution)
label.capture.configurable.debugger.agent=Instrumenting agent (requires debugger restart)
label.capture.configurable.annotations.configure=Configure Annotations...
threads.view.configurable.display.name=Customize Threads View
user.renderers.configurable.display.name=Java Type Renderers
async.stacktraces.configurable.display.name=Async Stack Traces
label.user.renderers.configurable.renderer.name=Renderer name:
text.user.renderers.configurable.no.renderers=No renderers
button.copy=Copy
user.renderers.configurable.button.description.copy=Copy selected renderer
threads.export.attribute.label.daemon=daemon
threads.export.attribute.label.priority=prio={0}
threads.export.attribute.label.tid=tid=0x{0}
threads.export.attribute.label.blocks.thread=blocks {0}
threads.export.attribute.label.waiting.for.thread=waiting for {0} to release lock on {1}
threads.export.attribute.label.locked=locked {0}
threads.export.attribute.label.object-id=<0x{0}> (a {1})
threads.export.attribute.error.incompatible.state=Incompatible thread state: thread not suspended
label.generic.debugger.parameters.patcher.configurable.shmem=Shared &memory
label.generic.debugger.parameters.patcher.configurable.socket=&Socket
button.debugger.settings=Debugger Settings...
label.generic.debugger.parameters.patcher.configurable.transport=Transport:
label.generic.debugger.parameters.patcher.configurable.shmem.address=Shared memory address:
progress.hot.swap.title=Hot Swap
status.hot.swap.completed.with.errors=Hot Swap failed
status.hot.swap.completed.restart=Restart debug session
status.hot.swap.completed.stop=Stop debug session
status.hot.swap.completed.with.warnings=Hot Swap completed with warnings
label.generic.debugger.parameters.patcher.configurable.port=Port:
status.hotswap.uptodate=Loaded classes are up to date. Nothing to reload.
add.instance.filter.dialog.title=Add Instance Filter
add.instance.filter.dialog.prompt=Enter instance ID:
add.instance.filter.dialog.error.numeric.value.expected=Instance ID should be a numeric value of type 'long'
filters.not.configured=No filters configured
hotswap.dialog.title.with.session=Reload Changed Classes for {0}
hotswap.dialog.title=Reload Changed Classes
hotswap.dialog.reload.action.text=Reload
hotswap.dialog.run.prompt=Some classes have been changed. Reload changed classes now?
hotswap.dialog.hang.warning=JVM is currently suspended.\nReloading classes with active third-party JVM agents may cause the JVM to hang.
label.add.field.breakpoint.dialog.fq.name=Fully qualified name of a class:
label.add.field.breakpoint.dialog.field.name=Field name:
add.field.breakpoint.dialog.title=Add Field Watchpoint
add.field.breakpoint.dialog.classchooser.title=Choose Field's Class
add.field.breakpoint.dialog.field.chooser.title={0,choice, 0#Class Has No Fields|1#Select Field}
label.add.wildcard.breakpoint.dialog.method.name=&Method name:
label.add.wildcard.breakpoint.dialog.class.pattern=&Class pattern:
breakpoint.any.exception.display.name=Any exception
action.hide.text=Hide
default.package.name=<Default>
class.filters.dialog.title=Class Filters
class.filters.dialog.inclusion.filters.group=Include
class.filters.dialog.exclusion.filters.group=Exclude
instance.filters.dialog.title=Instance Filters
breakpoint.exception.breakpoint.display.name=''{0}''
exception.breakpoints.tab.title=Java Exception Breakpoints
field.watchpoints.tab.title=Java Field Watchpoints
collection.watchpoints.tab.title=Java Collection Watchpoints
line.breakpoints.tab.title=Java Line Breakpoints
method.breakpoints.tab.title=Java Method Breakpoints
method.breakpoints.slowness.warning=Method breakpoints may dramatically slow down debugging
title.error.evaluating.breakpoint.condition=Breakpoint Condition Error
title.error.evaluating.breakpoint.action=Breakpoint Action Error
error.evaluating.breakpoint.condition.or.action=Problem processing VM event:\nBreakpoint: ''{0}''\nError: {1}\nWould you like to stop at the breakpoint?
error.unable.to.evaluate.expression=Unable to evaluate the expression
error.unable.to.evaluate.children.expression=Unable to evaluate the children renderer expression
error.unable.to.evaluate.capture.expression=Unable to evaluate capture key expression: {0}
error.unable.to.evaluate.insert.expression=Unable to evaluate insert key expression: {0}
breakpoint.properties.panel.option.pass.count=&Pass count:
breakpoint.properties.panel.option.class.filters=C&lass filters:
breakpoint.properties.panel.option.instance.filters=&Instance filters:
breakpoint.property.name.pass.count=Pass count
breakpoint.property.name.class.filters=Class filters
breakpoint.property.name.instance.filters=Instance filters:
error.absent.exception.breakpoint.class.name=No class name for exception breakpoint
exception.breakpoint.console.message.location.info={0}:{1,number,#}
exception.breakpoint.console.message.location.info.absent=No Debug Info
exception.breakpoint.console.message.with.thread.info=Exception ''{0}'' occurred in thread ''{1}'' at {2}({3})
exception.breakpoint.console.message=Exception ''{0}'' occurred at {1}({2})
add.exception.breakpoint.classchooser.title=Enter Exception Class
label.exception.breakpoint.properties.panel.caught.exception=Caught exceptio&n
label.exception.breakpoint.properties.panel.uncaught.exception=Uncaught excepti&on
label.exception.breakpoint.properties.panel.group.notifications=Notifications
error.invalid.breakpoint.missing.field.in.class=Cannot find field ''{0}'' in  class ''{1}''
status.breakpoint.invalid=INVALID
error.field.breakpoint.class.name.not.specified=Cannot add watchpoint: a class name is not specified
error.field.breakpoint.field.name.not.specified=Cannot add watchpoint: a field name is not specified
error.field.breakpoint.field.not.found=Cannot create a field watchpoint for ''{0}.{1}''.\nField ''{2}'' not found
error.field.breakpoint.class.sources.not.found=Cannot create a field watchpoint for ''{0}.{1}''.\nNo sources for class ''{2}''
label.field.breakpoint.properties.panel.field.access=Field acce&ss
label.field.breakpoint.properties.panel.field.modification=Field &modification
label.group.watch.events=Watch
label.collection.breakpoint.properties.save.history=Save collection history
error.failed.evaluating.breakpoint.condition=Failed to evaluate breakpoint condition\n''{0}''\nReason: {1}
error.invalid.breakpoint.no.executable.code=No executable code found at line {0} in class {1}
error.invalid.breakpoint.no.line.info=Line numbers info is not available in class {0}
line.breakpoint.display.name=Line {0}
line.breakpoint.display.name.with.class.or.method=Line {0,number,#} in {1}
error.invalid.breakpoint.method.not.found=Method not found in class {0}
label.method.breakpoints.processing.classes=Processing classes for emulated method breakpoints
label.method.breakpoints.setting.breakpoints=Setting emulated method breakpoints
label.method.breakpoint.properties.panel.method.entry=Method entr&y
label.method.breakpoint.properties.panel.method.exit=Method e&xit
label.method.breakpoint.properties.panel.emulated=Em&ulated
error.invalid.field.name=Invalid field name ''{0}''
label.unknown.value=<unknown>
message.node.debug.info.not.available=Debug info not available
message.node.local.variables.debug.info.not.available=Variables debug info not available
message.node.local.variables.not.captured=Local variables are not captured for synthetic, bridge etc. methods
message.node.local.variables.capture.disabled=Local variables were not captured, you can change it in
message.node.array.elements.more=+{0} more
message.node.elements.null.hidden=Not showing null elements
message.node.all.array.elements.null=All elements in range ({0}, {1}) are null
message.node.all.elements.null=All elements are null
message.node.filtered=Filtered by:
message.node.empty.array=Empty
message.node.class.has.no.fields=Class has no fields
message.node.class.no.fields.to.display=No fields to display
message.node.object.collected=Object has been garbage collected during method invocation
message.node.thread.running=Thread is running
message.node.thread.has.no.frames=Thread has no frames
message.node.evaluation.not.possible=Target VM is not paused by breakpoint request. Evaluation of methods is not possible in this mode
message.node.show.image=\u2026 Show image
message.node.show.icon=\u2026 Show icon
message.node.navigate=\u2026 Navigate
message.node.toString=\u2026 toString()
message.node.evaluate=\u2026 Evaluate
label.thread.node.thread.collected=Thread ''{0}'' has been garbage-collected
label.thread.node=\"{0}\"@{1}: {2}
label.thread.node.in.group=\"{0}\"@{1} in group \"{3}\": {2}
label.thread.group.node.group.collected=Thread Group \"{0}\" has been garbage-collected
label.thread.group.node=Thread Group \"{0}\"@{1}
evaluation.error.invalid.type.name=Invalid type name: ''{0}''
label.undefined=undefined
error.running.to.cursor.no.executable.code=There is no executable code at {0}:{1}
evaluation.error.local.variable.declarations.not.supported=Local variable declarations are not supported here.
evaluation.error.unsupported.declaration=Invalid declaration : {0} Only local variable declarations are supported.
error.jdk.not.specified=JDK is not specified
error.field.not.found.in.class=No such field {0} in {1}
error.breakpoint.file.not.found=File ''{0}'' not found; breakpoints for this file will be ignored
error.cannot.load.breakpoint.file=Cannot load file ''{0}''; breakpoints for this file will be ignored
evaluation.error.invalid.this.expression=Cannot substitute ''{0}'' into ''{1}'' as ''this''
error.invalid.type.name=Invalid type name ''{0}''
error.cannot.create.expression.from.code.fragment=Cannot create expression from code fragment.
error.invalid.local.variable.name=Invalid local variable name ''{0}''
error.inconsistent.debug.info=Inconsistent debug information
error.invalid.stackframe=Internal exception - invalid stackframe
internal.debugger.error=Internal error. See logs for more details
error.text.invalid.port=Port is not specified
title.smart.step.popup=Method to Step Into
action.watch.method.return.value.description=Enables watching last executed method return value
action.watches.method.return.value.enable=Show Method Return Values
action.calculate.retained.size.info=Retained objects of ''{0}'' are highlighted
action.calculate.retained.size.title=Retained Size of ''{0}''
action.calculate.retained.size.text=Retained size of ''{0}'' is {1}, shallow size is {2}
action.calculate.retained.size.waiting.message=Calculating retained size...
action.watches.method.return.value.unavailable.reason=Feature is not supported by the target VM
action.auto.variables.mode=Show Variables Near Execution Point Only
action.auto.variables.mode.description=Show only variables used near the execution point
frame.panel.frames.not.available=Frames not available for unsuspended thread
frame.panel.thread.finished=Thread has finished execution
frame.panel.async.stacktrace=Async stack trace
error.corrupt.debug.info=Debug info might be corrupt: {0}
evaluation.error.unknown.method.return.type=Cannot resolve method return type: {0}
evaluation.error.unknown.type=Cannot resolve type: {0}
rule.name.group.by.class=Group by class
rule.name.group.by.package=Group by package
error.context.has.changed=Context has changed, operation is not possible
editor.notification.alternative.source=Alternative source available for the class {0}
label.threads.view.configurable.show.prams.types=Show method arguments types
breakpoint.properties.panel.option.catch.class.filters=Catc&h class filters:
breakpoint.properties.panel.option.caller.filter=Calle&r filters:
caller.filters.dialog.title=Caller Filters
settings.breakpoints.based=Breakpoints based:
settings.capture.column.capture.class.name=Capture class name
settings.capture.column.capture.method.name=Capture method name
settings.capture.column.capture.key.expression=Capture key expression
settings.capture.column.insert.class.name=Insert class name
settings.capture.column.insert.method.name=Insert method name
settings.capture.column.insert.key.expression=Insert key expression
settings.async.schedule=Async Schedule
settings.async.execute=Async Execute
settings.async.annotations.configuration=Async Annotations Configuration
action.AnActionButton.text.duplicate=Duplicate
action.AnActionButton.description.duplicate=Duplicate
action.AnActionButton.text.enable.selected=Enable Selected
action.AnActionButton.description.enable.selected=Enable Selected
action.AnActionButton.text.disable.selected=Disable Selected
action.AnActionButton.description.disable.selected=Disable Selected
action.AnActionButton.text.import=Import
action.AnActionButton.description.import=Import
action.AnActionButton.text.export=Export
action.AnActionButton.description.export=Export
warning.0=WARNING! {0}
instances.window.show.history=InstancesWindow.ShowHistory
select.stack.frame=Select stack frame
tracing.class.filters=Tracing Class Filters
filters=Filters...
export.failed=Export Failed
export.selected.capture.points.to.file=Export Selected Capture Points to File...
import.capture.points=Import Capture Points
please.select.a.file.to.import=Please select a file to import.
waiting.for.debugger.response=Waiting for the process to finish gracefully
thread.dump=Thread Dump
collection.history=Collection history
cancel.emulation=Cancel emulation
thread.operation.interrupt.is.not.supported.by.vm=Thread operation 'interrupt' is not supported by VM
add.stepping.filter=Add Stepping Filter
method.name.not.specified=Method name not specified
class.pattern.not.specified=Class pattern not specified
add.method.breakpoint=Add Method Breakpoint
if.the.value.is.referenced.by.a.constant.field=If the value is referenced by a constant field of an abstract class,\nIDEA could additionally mark all values referenced from this class with the names of referencing fields.
action.failed=Action failed
label.object.markup.dialog.mark.referenced=&Mark values referenced from constant fields
debugger.data.views.configurable.show.title=Show
overhead.toolwindow.title=Overhead
memory.toolwindow.title=Memory
checkbox.tracing=Tracing
enable.tracking.for.new.instances=Enable tracking for new instances
condition=Condition:
warning.filtering.may.have.side.effects=Warning: filtering may have side effects
invoke.completion.once.more=Invoke completion once more to see runtime type variants
debugger.actions.group.title=Debugger Actions
surround.with.runtime.type.template=((RuntimeType)expr)
command.name.surround.with.runtime.cast=Surround With Runtime Cast
checkbox.start.tracing=start
checkbox.stop.tracing=stop
checkbox.tracking.filters=filters
status.text.select.instance.to.see.stack.frame=Select instance to see stack frame
label.arrays.could.not.be.tracked=Arrays cannot be tracked
status.text.no.stack.frame.for.this.instance=No stack frame for this instance
label.capture.point.at=Capture point at {0}.{1}
dialog.title.exception.to.throw=Exception To Throw
notification.method.has.not.been.called=Method <b>{0}()</b> has not been called
error.no.debug.process=No debug process
error.context.not.available=Context is not available
error.internal=Internal error
label.too.many.frames.rest.truncated=Too many frames, the rest is truncated...
thread.dump.name=Dump {0}
collection.history.tab.title=History of {0}
error.unable.to.create.sapidattachingconnector=Unable to create SAPIDAttachingConnector
action.show.objects.text=Show {0} Objects...
progress.text.shown.x.of.y=Shown: {0} / {1}
progress.text.errors.count=Errors: {0}
progress.suffix.filtering.has.been.interrupted=(Filtering has been interrupted)
progress.suffix.limit.has.been.reached=(Limit has been reached)
button.perform.reload.classes=Perform &Reload Classes
button.skip.reload.classes=&Skip Reload Classes
call.tracer=Call Tracer
label.instrumentation.tracker=Instrumentation tracker: {0}
column.name.hits=Hits
column.name.time.ms=Time (ms)
renderer.name={0} renderer
action.do.not.stop.if.called.from.text=Do not stop if called from: {0}
action.stop.only.if.called.from.text=Stop only if called from: {0}
action.stop.only.in.current.object.text=Stop only in the current object
action.stop.only.in.class.text=Stop only in the class: {0}
action.do.not.stop.in.class.text=Do not stop in the class: {0}
dialog.title.return.value=Return Value
process.attach.run.configuration.type.name=Attach to process
memory.view.constructor.tracker.name=MemoryViewConstructorTracker: {0}
capture.node.settings.link=\ settings
array.filter.node.clear.link=\ clear
breakpoint.variant.text.line=Line
breakpoint.variant.text.line.and.lambda=Line and {0,choice,1#Lambda|2#Lambdas}
breakpoint.variant.text.line.and.lambda.uknown.count=Line and Lambda(s)
debugger.attach.group.name.java=Java
debugger.attach.group.name.java.read.only=Java Read Only
debugger.memory.agent.timeout.error=Calculation timeout (heap is too large and memory agent can't execute this operation in reasonable time, it's preferable to capture the heap dump)
debugger.memory.agent.loading.error=Memory agent couldn't be loaded to the VM
debugger.attach.password.for.sudo=Enter your password to attach with su privileges: 
notification.group.hotswap=Hot Swap performed
message.conditional.return.breakpoint.on.android=Breakpoint on conditional return is not yet supported on Android, regular line breakpoint is set.
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger;

import org.jetbrains.annotations.NotNull;

/**
 * @deprecated use {@link JavaDebuggerBundle} instead
 */
@Deprecated
public final class DebuggerBundle {
  @NotNull
  public static String message(@NotNull String key, Object @NotNull ... params) {
    return JavaDebuggerBundle.message(key, params);
  }
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger;

import com.intellij.debugger.engine.StackFrameContext;
import com.intellij.debugger.engine.SuspendContext;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.Nullable;

public interface DebuggerContext extends StackFrameContext {
  @Nullable
  SuspendContext getSuspendContext();

  Project getProject();
}
// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger;

import com.intellij.debugger.engine.DebugProcess;
import com.intellij.debugger.engine.DebugProcessListener;
import com.intellij.execution.process.ProcessHandler;
import com.intellij.openapi.project.Project;
import com.intellij.psi.PsiClass;

public abstract class DebuggerManager {
  public static DebuggerManager getInstance(Project project) {
    return project.getService(DebuggerManager.class);
  }

  public abstract DebugProcess getDebugProcess(ProcessHandler processHandler);

  public abstract void addDebugProcessListener(ProcessHandler processHandler, DebugProcessListener listener);

  public abstract void removeDebugProcessListener(ProcessHandler processHandler, DebugProcessListener listener);

  public abstract boolean isDebuggerManagerThread();

  public abstract void addClassNameMapper(NameMapper mapper);

  public abstract void removeClassNameMapper(NameMapper mapper);

  public abstract String getVMClassQualifiedName(PsiClass aClass);
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.engine;

import com.intellij.debugger.DebuggerContext;
import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.evaluation.TextWithImports;
import com.intellij.execution.ExecutionException;
import com.intellij.openapi.actionSystem.DataContext;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.fileTypes.FileType;
import com.intellij.openapi.fileTypes.LanguageFileType;
import com.intellij.openapi.project.IndexNotReadyException;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.roots.LanguageLevelProjectExtension;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.Ref;
import com.intellij.openapi.util.ThrowableComputable;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.pom.java.LanguageLevel;
import com.intellij.psi.*;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.util.ClassUtil;
import com.intellij.psi.util.InheritanceUtil;
import com.intellij.psi.util.PsiTypesUtil;
import com.intellij.util.CommonProcessors;
import com.intellij.util.IncorrectOperationException;
import com.intellij.util.Processor;
import com.intellij.util.containers.ContainerUtil;
import com.sun.jdi.*;
import org.jdom.Element;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;
import java.util.function.Function;

public abstract class DebuggerUtils {
  private static final Logger LOG = Logger.getInstance(DebuggerUtils.class);
  private static final Key<Method> TO_STRING_METHOD_KEY = new Key<>("CachedToStringMethod");
  public static final Set<String> ourPrimitiveTypeNames = Set.of(
    "byte", "short", "int", "long", "float", "double", "boolean", "char"
  );

  public static void cleanupAfterProcessFinish(DebugProcess debugProcess) {
    debugProcess.putUserData(TO_STRING_METHOD_KEY, null);
  }

  @NonNls
  public static String getValueAsString(final EvaluationContext evaluationContext, Value value) throws EvaluateException {
    try {
      if (value == null) {
        return "null";
      }
      if (value instanceof StringReference) {
        ensureNotInsideObjectConstructor((ObjectReference)value, evaluationContext);
        return ((StringReference)value).value();
      }
      if (isInteger(value)) {
        return String.valueOf(((PrimitiveValue)value).longValue());
      }
      if (value instanceof FloatValue) {
        return String.valueOf(((FloatValue)value).floatValue());
      }
      if (value instanceof DoubleValue) {
        return String.valueOf(((DoubleValue)value).doubleValue());
      }
      if (value instanceof BooleanValue) {
        return String.valueOf(((PrimitiveValue)value).booleanValue());
      }
      if (value instanceof CharValue) {
        return String.valueOf(((PrimitiveValue)value).charValue());
      }
      if (value instanceof ObjectReference objRef) {
        if (value instanceof ArrayReference arrayRef) {
          final StringJoiner joiner = new StringJoiner(",", "[", "]");
          for (final Value element : arrayRef.getValues()) {
            joiner.add(getValueAsString(evaluationContext, element));
          }
          return joiner.toString();
        }

        final DebugProcess debugProcess = evaluationContext.getDebugProcess();
        Method toStringMethod = debugProcess.getUserData(TO_STRING_METHOD_KEY);
        if (toStringMethod == null || !toStringMethod.virtualMachine().equals(objRef.virtualMachine())) {
          try {
            ReferenceType refType = getObjectClassType(objRef.virtualMachine());
            toStringMethod = findMethod(refType, "toString", "()Ljava/lang/String;");
            debugProcess.putUserData(TO_STRING_METHOD_KEY, toStringMethod);
          }
          catch (Exception ignored) {
            throw EvaluateExceptionUtil.createEvaluateException(
              JavaDebuggerBundle.message("evaluation.error.cannot.evaluate.tostring", objRef.referenceType().name()));
          }
        }
        if (toStringMethod == null) {
          throw EvaluateExceptionUtil.createEvaluateException(
            JavaDebuggerBundle.message("evaluation.error.cannot.evaluate.tostring", objRef.referenceType().name()));
        }
        Method finalToStringMethod = toStringMethod;
        return processCollectibleValue(
          () -> debugProcess.invokeInstanceMethod(evaluationContext, objRef, finalToStringMethod, Collections.emptyList(), 0),
          result -> {
            // while result must be of com.sun.jdi.StringReference type, it turns out that sometimes (jvm bugs?)
            // it is a plain com.sun.tools.jdi.ObjectReferenceImpl
            if (result == null) {
              return "null";
            }
            return result instanceof StringReference ? ((StringReference)result).value() : result.toString();
          }
        );
      }
      throw EvaluateExceptionUtil.createEvaluateException(JavaDebuggerBundle.message("evaluation.error.unsupported.expression.type"));
    }
    catch (ObjectCollectedException ignored) {
      throw EvaluateExceptionUtil.OBJECT_WAS_COLLECTED;
    }
  }

  public static <R, T extends Value> R processCollectibleValue(
    @NotNull ThrowableComputable<? extends T, ? extends EvaluateException> valueComputable,
    @NotNull Function<? super T, ? extends R> processor) throws EvaluateException {
    int retries = 10;
    while (true) {
      T result = valueComputable.compute();
      try {
        return processor.apply(result);
      }
      catch (ObjectCollectedException oce) {
        if (--retries < 0) {
          throw oce;
        }
      }
    }
  }

  public static void ensureNotInsideObjectConstructor(@NotNull ObjectReference reference, @NotNull EvaluationContext context)
    throws EvaluateException {
    Location location = getInstance().getLocation(context.getSuspendContext());
    if (location != null && location.method().isConstructor() && reference.equals(context.computeThisObject())) {
      throw EvaluateExceptionUtil.createEvaluateException(JavaDebuggerBundle.message("evaluation.error.object.is.being.initialized"));
    }
  }

  protected abstract Location getLocation(SuspendContext context);

  public static final int MAX_DISPLAY_LABEL_LENGTH = 1024 * 5;

  public static String convertToPresentationString(String str) {
    if (str.length() > MAX_DISPLAY_LABEL_LENGTH) {
      str = translateStringValue(str.substring(0, MAX_DISPLAY_LABEL_LENGTH));
      StringBuilder buf = new StringBuilder();
      buf.append(str);
      if (!str.endsWith("...")) {
        buf.append("...");
      }
      return buf.toString();
    }
    return translateStringValue(str);
  }

  @Nullable
  public static Method findMethod(@NotNull ReferenceType refType, @NonNls String methodName, @Nullable @NonNls String methodSignature) {
    if (refType instanceof ArrayType) {
      // for array types methodByName() in JDI always returns empty list
      Method method = findMethod(getObjectClassType(refType.virtualMachine()), methodName, methodSignature);
      if (method != null) {
        return method;
      }
      // for arrays, clone signature may return array of objects, there is no such method in Object class
      if ("clone".equals(methodName) && "()[Ljava/lang/Object;".equals(methodSignature)) {
        method = findMethod(getObjectClassType(refType.virtualMachine()), "clone", null);
        if (method != null) {
          return method;
        }
      }
    }

    Method method = null;
    // speedup the search by not gathering all methods through the class hierarchy
    if (refType instanceof ClassType) {
      method = concreteMethodByName((ClassType)refType, methodName, methodSignature);
    }
    if (method == null) {
      method = ContainerUtil.getFirstItem(
        methodSignature != null ? refType.methodsByName(methodName, methodSignature) : refType.methodsByName(methodName));
    }
    return method;
  }

  /**
   * Optimized version of {@link ClassType#concreteMethodByName(String, String)}.
   * It does not gather all visible methods before checking so can return early
   */
  @Nullable
  private static Method concreteMethodByName(@NotNull ClassType type, @NotNull String name, @Nullable String signature) {
    Processor<Method> signatureChecker = signature != null ? m -> m.signature().equals(signature) : CommonProcessors.alwaysTrue();
    LinkedList<ReferenceType> types = new LinkedList<>();
    // first check classes
    while (type != null) {
      for (Method candidate : type.methods()) {
        if (candidate.name().equals(name) && signatureChecker.process(candidate)) {
          return !candidate.isAbstract() ? candidate : null;
        }
      }
      types.add(type);
      type = type.superclass();
    }
    // then interfaces
    Set<ReferenceType> checkedInterfaces = new HashSet<>();
    ReferenceType t;
    while ((t = types.poll()) != null) {
      if (t instanceof ClassType) {
        types.addAll(0, ((ClassType)t).interfaces());
      }
      else if (t instanceof InterfaceType && checkedInterfaces.add(t)) {
        for (Method candidate : t.methods()) {
          if (candidate.name().equals(name) && signatureChecker.process(candidate) && !candidate.isAbstract()) {
            return candidate;
          }
        }
        types.addAll(0, ((InterfaceType)t).superinterfaces());
      }
    }
    return null;
  }

  public static boolean isNumeric(Value value) {
    return value != null &&
           (isInteger(value) ||
            value instanceof FloatValue ||
            value instanceof DoubleValue
           );
  }

  public static boolean isInteger(Value value) {
    return (value instanceof ByteValue ||
            value instanceof ShortValue ||
            value instanceof LongValue ||
            value instanceof IntegerValue
    );
  }

  public static String translateStringValue(final String str) {
    int length = str.length();
    final StringBuilder buffer = new StringBuilder();
    StringUtil.escapeStringCharacters(length, str, buffer);
    return buffer.toString();
  }

  @Nullable
  protected static ArrayClass getArrayClass(@NotNull String className) {
    boolean searchBracket = false;
    int dims = 0;
    int pos;

    for (pos = className.lastIndexOf(']'); pos >= 0; pos--) {
      char c = className.charAt(pos);

      if (searchBracket) {
        if (c == '[') {
          dims++;
          searchBracket = false;
        }
        else if (!Character.isWhitespace(c)) break;
      }
      else {
        if (c == ']') {
          searchBracket = true;
        }
        else if (!Character.isWhitespace(c)) break;
      }
    }

    if (searchBracket) return null;

    if (dims == 0) return null;

    return new ArrayClass(className.substring(0, pos + 1), dims);
  }

  public static boolean instanceOf(@NotNull String subType, @NotNull String superType, @Nullable Project project) {
    if (project == null) {
      return subType.equals(superType);
    }

    ArrayClass nodeClass = getArrayClass(subType);
    ArrayClass rendererClass = getArrayClass(superType);
    if (nodeClass == null || rendererClass == null) return false;

    if (nodeClass.dims == rendererClass.dims) {
      GlobalSearchScope scope = GlobalSearchScope.allScope(project);
      PsiClass psiNodeClass = JavaPsiFacade.getInstance(project).findClass(nodeClass.className, scope);
      PsiClass psiRendererClass = JavaPsiFacade.getInstance(project).findClass(rendererClass.className, scope);
      return InheritanceUtil.isInheritorOrSelf(psiNodeClass, psiRendererClass, true);
    }
    else if (nodeClass.dims > rendererClass.dims) {
      return rendererClass.className.equals(CommonClassNames.JAVA_LANG_OBJECT);
    }
    return false;
  }

  public static boolean instanceOf(@Nullable Type subType, @NotNull String superType) {
    if (subType == null || subType instanceof VoidType) {
      return false;
    }

    if (subType instanceof PrimitiveType) {
      return superType.equals(subType.name());
    }

    if (CommonClassNames.JAVA_LANG_OBJECT.equals(superType)) {
      return true;
    }

    if (subType instanceof ArrayType &&
        (CommonClassNames.JAVA_LANG_CLONEABLE.equals(superType) || CommonClassNames.JAVA_IO_SERIALIZABLE.equals(superType))) {
      return true;
    }

    return getSuperTypeInt(subType, superType) != null;
  }

  @Nullable
  public static Type getSuperType(@Nullable Type subType, @NotNull String superType) {
    if (subType == null || subType instanceof PrimitiveType || subType instanceof VoidType) {
      return null;
    }

    if (CommonClassNames.JAVA_LANG_OBJECT.equals(superType)) {
      return getObjectClassType(subType.virtualMachine());
    }

    return getSuperTypeInt(subType, superType);
  }

  private static ReferenceType getObjectClassType(VirtualMachine virtualMachine) {
    return ContainerUtil.getFirstItem(virtualMachine.classesByName(CommonClassNames.JAVA_LANG_OBJECT));
  }

  private static boolean typeEquals(@NotNull Type type, @NotNull String typeName) {
    int genericPos = typeName.indexOf('<');
    if (genericPos > -1) {
      typeName = typeName.substring(0, genericPos);
    }
    return type.name().replace('$', '.').equals(typeName.replace('$', '.'));
  }

  private static Type getSuperTypeInt(@NotNull Type subType, @NotNull String superType) {
    if (typeEquals(subType, superType)) {
      return subType;
    }

    Type result;
    if (subType instanceof ClassType) {
      try {
        ClassType clsType = (ClassType)subType;
        result = getSuperType(clsType.superclass(), superType);
        if (result != null) {
          return result;
        }

        for (InterfaceType iface : clsType.interfaces()) {
          result = getSuperType(iface, superType);
          if (result != null) {
            return result;
          }
        }
      }
      catch (ClassNotPreparedException e) {
        LOG.info(e);
      }
      return null;
    }

    if (subType instanceof InterfaceType) {
      try {
        for (InterfaceType iface : ((InterfaceType)subType).superinterfaces()) {
          result = getSuperType(iface, superType);
          if (result != null) {
            return result;
          }
        }
      }
      catch (ClassNotPreparedException e) {
        LOG.info(e);
      }
    }
    else if (subType instanceof ArrayType) {
      if (superType.endsWith("[]")) {
        try {
          String superTypeItem = superType.substring(0, superType.length() - 2);
          Type subTypeItem = ((ArrayType)subType).componentType();
          return instanceOf(subTypeItem, superTypeItem) ? subType : null;
        }
        catch (ClassNotLoadedException e) {
          LOG.info(e);
        }
      }
    }

    return null;
  }

  // workaround to get an array class of needed language version for correct HL in array renderers expression
  protected abstract PsiClass createArrayClass(Project project, LanguageLevel level);

  @Nullable
  public static PsiClass findClass(@NotNull String className, @NotNull Project project, @NotNull GlobalSearchScope scope) {
    return findClass(className, project, scope, true);
  }

  @Nullable
  public static PsiClass findClass(@NotNull String className,
                                   @NotNull Project project,
                                   @NotNull GlobalSearchScope scope,
                                   boolean fallbackToAllScope) {
    ApplicationManager.getApplication().assertReadAccessAllowed();
    try {
      if (getArrayClass(className) != null) {
        return getInstance().createArrayClass(project, LanguageLevelProjectExtension.getInstance(project).getLanguageLevel());
      }
      if (project.isDefault()) {
        return null;
      }

      // remove generics if any
      className = StringUtil.notNullize(StringUtil.substringBefore(className, "<"), className);

      PsiManager psiManager = PsiManager.getInstance(project);
      PsiClass psiClass = ClassUtil.findPsiClass(psiManager, className, null, true, scope);
      if (psiClass == null && fallbackToAllScope) {
        GlobalSearchScope globalScope = getInstance().getFallbackAllScope(scope, project);
        if (globalScope != null) {
          psiClass = ClassUtil.findPsiClass(psiManager, className, null, true, globalScope);
        }
      }

      return psiClass;
    }
    catch (IndexNotReadyException ignored) {
      return null;
    }
  }

  @Nullable
  protected abstract GlobalSearchScope getFallbackAllScope(@NotNull GlobalSearchScope scope, @NotNull Project project);

  @Nullable
  public static PsiType getType(@NotNull String className, @NotNull Project project) {
    ApplicationManager.getApplication().assertReadAccessAllowed();

    try {
      if (getArrayClass(className) != null) {
        return JavaPsiFacade.getElementFactory(project).createTypeFromText(className, null);
      }
      if (project.isDefault()) {
        return null;
      }
      PsiClass aClass = findClass(className, project, GlobalSearchScope.allScope(project));
      if (aClass != null) {
        return PsiTypesUtil.getClassType(aClass);
      }
    }
    catch (IncorrectOperationException ignored) {
    }
    return null;
  }

  public static void checkSyntax(PsiCodeFragment codeFragment) throws EvaluateException {
    PsiElement[] children = codeFragment.getChildren();

    if (children.length == 0) {
      throw EvaluateExceptionUtil.createEvaluateException(
        JavaDebuggerBundle.message("evaluation.error.empty.code.fragment"));
    }
    for (PsiElement child : children) {
      if (child instanceof PsiErrorElement) {
        throw EvaluateExceptionUtil.createEvaluateException(
          JavaDebuggerBundle.message("evaluation.error.invalid.expression", child.getText()));
      }
    }
  }

  public static boolean hasSideEffects(@Nullable PsiElement element) {
    return hasSideEffectsOrReferencesMissingVars(element, null);
  }

  public static boolean hasSideEffectsOrReferencesMissingVars(@Nullable PsiElement element,
                                                              @Nullable final Set<String> visibleLocalVariables) {
    if (element == null) {
      return false;
    }
    final Ref<Boolean> rv = new Ref<>(Boolean.FALSE);
    element.accept(new JavaRecursiveElementWalkingVisitor() {
      @Override
      public void visitPostfixExpression(final @NotNull PsiPostfixExpression expression) {
        rv.set(Boolean.TRUE);
      }

      @Override
      public void visitReferenceExpression(final @NotNull PsiReferenceExpression expression) {
        final PsiElement psiElement = expression.resolve();
        if (psiElement instanceof PsiLocalVariable) {
          if (visibleLocalVariables != null) {
            if (!visibleLocalVariables.contains(((PsiLocalVariable)psiElement).getName())) {
              rv.set(Boolean.TRUE);
            }
          }
        }
        else if (psiElement instanceof PsiMethod) {
          rv.set(Boolean.TRUE);
          //final PsiMethod method = (PsiMethod)psiElement;
          //if (!isSimpleGetter(method)) {
          //  rv.set(Boolean.TRUE);
          //}
        }
        if (!rv.get().booleanValue()) {
          super.visitReferenceExpression(expression);
        }
      }

      @Override
      public void visitPrefixExpression(final @NotNull PsiPrefixExpression expression) {
        final IElementType op = expression.getOperationTokenType();
        if (JavaTokenType.PLUSPLUS.equals(op) || JavaTokenType.MINUSMINUS.equals(op)) {
          rv.set(Boolean.TRUE);
        }
        else {
          super.visitPrefixExpression(expression);
        }
      }

      @Override
      public void visitAssignmentExpression(final @NotNull PsiAssignmentExpression expression) {
        rv.set(Boolean.TRUE);
      }

      @Override
      public void visitCallExpression(final @NotNull PsiCallExpression callExpression) {
        rv.set(Boolean.TRUE);
        //final PsiMethod method = callExpression.resolveMethod();
        //if (method == null || !isSimpleGetter(method)) {
        //  rv.set(Boolean.TRUE);
        //}
        //else {
        //  super.visitCallExpression(callExpression);
        //}
      }
    });
    return rv.get().booleanValue();
  }

  public abstract String findAvailableDebugAddress(boolean useSockets) throws ExecutionException;

  public static boolean isSynthetic(@Nullable TypeComponent typeComponent) {
    if (typeComponent == null) {
      return false;
    }
    if (ContainerUtil.exists(SyntheticTypeComponentProvider.EP_NAME.getExtensionList(),
                             provider -> provider.isNotSynthetic(typeComponent))) {
      return false;
    }
    return ContainerUtil.exists(SyntheticTypeComponentProvider.EP_NAME.getExtensionList(), provider -> provider.isSynthetic(typeComponent));
  }

  public static boolean isInsideSimpleGetter(@NotNull PsiElement contextElement) {
    return ContainerUtil.exists(SimplePropertyGetterProvider.EP_NAME.getExtensionList(),
                                provider -> provider.isInsideSimpleGetter(contextElement));
  }

  public static boolean isPrimitiveType(String typeName) {
    return typeName != null && ourPrimitiveTypeNames.contains(typeName);
  }

  protected record ArrayClass(String className, int dims) {
  }

  public static DebuggerUtils getInstance() {
    return ApplicationManager.getApplication().getService(DebuggerUtils.class);
  }

  public abstract PsiExpression substituteThis(PsiExpression expressionWithThis,
                                               PsiExpression howToEvaluateThis,
                                               Value howToEvaluateThisValue,
                                               StackFrameContext context) throws EvaluateException;

  public abstract DebuggerContext getDebuggerContext(DataContext context);

  public abstract Element writeTextWithImports(TextWithImports text);

  public abstract TextWithImports readTextWithImports(Element element);

  public abstract void writeTextWithImports(Element root, @NonNls String name, TextWithImports value);

  public abstract TextWithImports readTextWithImports(Element root, @NonNls String name);

  public abstract TextWithImports createExpressionWithImports(@NonNls String expression);

  public abstract PsiElement getContextElement(final StackFrameContext context);

  public abstract PsiClass chooseClassDialog(String title, Project project);

  public static boolean isBreakpointAware(@NotNull PsiFile file) {
    FileType fileType = file.getFileType();
    //noinspection deprecation
    if (fileType instanceof LanguageFileType && ((LanguageFileType)fileType).isJVMDebuggingSupported()) {
      return true;
    }

    return ContainerUtil.exists(JavaDebugAware.EP_NAME.getExtensionList(), provider -> provider.isBreakpointAware(file));
  }

  public static boolean isAndroidVM(@NotNull VirtualMachine virtualMachine) {
    return StringUtil.containsIgnoreCase(virtualMachine.name(), "dalvik");
  }
}
// Copyright 2000-2017 JetBrains s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package com.intellij.debugger.engine;

import com.intellij.debugger.PositionManager;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.intellij.debugger.engine.jdi.VirtualMachineProxy;
import com.intellij.debugger.engine.managerThread.DebuggerManagerThread;
import com.intellij.debugger.requests.RequestManager;
import com.intellij.execution.ExecutionResult;
import com.intellij.execution.process.ProcessHandler;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.UserDataHolder;
import com.intellij.psi.search.GlobalSearchScope;
import com.sun.jdi.*;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.List;

public interface DebugProcess extends UserDataHolder {
  @NonNls String JAVA_STRATUM = "Java";

  Project getProject();

  RequestManager getRequestsManager();

  @NotNull
  PositionManager getPositionManager();

  VirtualMachineProxy getVirtualMachineProxy();

  void addDebugProcessListener(DebugProcessListener listener, Disposable parentDisposable);

  void addDebugProcessListener(DebugProcessListener listener);

  void removeDebugProcessListener(DebugProcessListener listener);

  /**
   * The usual place to call this method is vmAttachedEvent. No additional actions are needed in this case.
   * If position manager is appended later, when DebugSession is up and running, one might need to call BreakpointManager.updateAllRequests()
   * to ensure that just added position manager was considered when creating breakpoint requests
   *
   * @param positionManager to be appended
   */
  void appendPositionManager(PositionManager positionManager);

  void waitFor();

  void waitFor(long timeout);

  void stop(boolean forceTerminate);

  ExecutionResult getExecutionResult();

  DebuggerManagerThread getManagerThread();

  Value invokeMethod(EvaluationContext evaluationContext,
                     ObjectReference objRef,
                     Method method,
                     List<? extends Value> args) throws EvaluateException;

  /**
   * Is equivalent to invokeInstanceMethod(evaluationContext, classType, method, args, 0)
   */
  Value invokeMethod(EvaluationContext evaluationContext,
                     ClassType classType,
                     Method method,
                     List<? extends Value> args) throws EvaluateException;

  Value invokeInstanceMethod(EvaluationContext evaluationContext,
                             ObjectReference objRef,
                             Method method,
                             List<? extends Value> args,
                             int invocationOptions) throws EvaluateException;

  ReferenceType findClass(@Nullable EvaluationContext evaluationContext,
                          String name,
                          ClassLoaderReference classLoader) throws EvaluateException;

  ArrayReference newInstance(ArrayType arrayType,
                             int dimension) throws EvaluateException;

  ObjectReference newInstance(EvaluationContext evaluationContext,
                              ClassType classType,
                              Method constructor,
                              List<? extends Value> paramList) throws EvaluateException;

  boolean isAttached();

  boolean isDetached();

  boolean isDetaching();

  /**
   * @return the search scope used by debugger to find sources corresponding to classes being executed
   */
  @NotNull
  GlobalSearchScope getSearchScope();

  void printToConsole(String text);

  ProcessHandler getProcessHandler();
}
/*
 * Copyright 2000-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine;

/**
 * @deprecated use {@link DebugProcessListener}
 */
@Deprecated(forRemoval = true)
public class DebugProcessAdapter implements DebugProcessListener {
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine;

import com.intellij.execution.ExecutionException;
import com.intellij.execution.configurations.RemoteConnection;
import com.intellij.execution.configurations.RunProfileState;
import com.sun.jdi.ThreadReference;
import org.jetbrains.annotations.NotNull;

import java.util.EventListener;


public interface DebugProcessListener extends EventListener {
  //executed in manager thread
  default void connectorIsReady() {
  }

  //executed in manager thread
  default void paused(@NotNull SuspendContext suspendContext) {
  }

  //executed in manager thread
  default void resumed(SuspendContext suspendContext) {
  }

  //executed in manager thread
  default void processDetached(@NotNull DebugProcess process, boolean closedByUser) {
  }

  //executed in manager thread
  default void processAttached(@NotNull DebugProcess process) {
  }

  default void attachException(RunProfileState state, ExecutionException exception, RemoteConnection remoteConnection) {
  }

  default void threadStarted(@NotNull DebugProcess proc, ThreadReference thread) {
  }

  default void threadStopped(@NotNull DebugProcess proc, ThreadReference thread) {
  }
}

// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.engine.evaluation;

public class AbsentInformationEvaluateException extends EvaluateException {
  public AbsentInformationEvaluateException(String msg, Throwable th) {
    super(msg, th);
  }

  @Override
  public synchronized Throwable fillInStackTrace() {
    return this;
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.engine.evaluation;

import com.intellij.debugger.engine.evaluation.expression.EvaluatorBuilder;
import com.intellij.openapi.extensions.ExtensionPointName;
import com.intellij.openapi.fileTypes.LanguageFileType;
import com.intellij.openapi.project.Project;
import com.intellij.psi.JavaCodeFragment;
import com.intellij.psi.PsiElement;
import org.jetbrains.annotations.NotNull;

/**
 * Allows to provide debugger editors support for non-java languages, for example in condition/log expression fields.
 */
public abstract class CodeFragmentFactory {
  public static final ExtensionPointName<CodeFragmentFactory> EXTENSION_POINT_NAME =
    ExtensionPointName.create("com.intellij.debugger.codeFragmentFactory");

  public abstract JavaCodeFragment createCodeFragment(TextWithImports item, PsiElement context, Project project);

  public abstract JavaCodeFragment createPresentationCodeFragment(TextWithImports item, PsiElement context, Project project);

  public abstract boolean isContextAccepted(PsiElement contextElement);

  @NotNull
  public abstract LanguageFileType getFileType();

  /**
   * In case if createCodeFragment returns java code use
   * com.intellij.debugger.engine.evaluation.expression.EvaluatorBuilderImpl#getInstance()
   *
   * @return builder, which can evaluate expression for your code fragment
   */
  public abstract EvaluatorBuilder getEvaluatorBuilder();
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.evaluation;

public enum CodeFragmentKind {
  EXPRESSION, CODE_BLOCK
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.engine.evaluation;

import com.intellij.openapi.diagnostic.Logger;
import com.sun.jdi.InvocationException;
import com.sun.jdi.ObjectReference;
import org.jetbrains.annotations.Nullable;

public class EvaluateException extends Exception {
  private static final Logger LOG = Logger.getInstance(EvaluateException.class);
  private ObjectReference myTargetException;

  public EvaluateException(final String message) {
    super(message);
    if (LOG.isDebugEnabled()) {
      LOG.debug(message);
    }
  }

  public EvaluateException(String msg, Throwable th) {
    super(msg, th);
    if (th instanceof EvaluateException evaluateException) {
      myTargetException = evaluateException.getExceptionFromTargetVM();
    }
    else if (th instanceof InvocationException invocationException) {
      myTargetException = invocationException.exception();
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(msg);
    }
  }

  @Nullable
  public ObjectReference getExceptionFromTargetVM() {
    return myTargetException;
  }

  public void setTargetException(final ObjectReference targetException) {
    myTargetException = targetException;
  }

  @Override
  public String getMessage() {
    final String errorMessage = super.getMessage();
    if (errorMessage != null) {
      return errorMessage;
    }
    final Throwable cause = getCause();
    final String causeMessage = cause != null ? cause.getMessage() : null;
    if (causeMessage != null) {
      return causeMessage;
    }
    return "unknown error";
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.engine.evaluation;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.openapi.util.text.StringUtil;
import com.sun.jdi.*;

public final class EvaluateExceptionUtil {
  public static final EvaluateException INCONSISTEND_DEBUG_INFO = createEvaluateException(
    JavaDebuggerBundle.message("evaluation.error.inconsistent.debug.info"));
  public static final EvaluateException BOOLEAN_EXPECTED = createEvaluateException(
    JavaDebuggerBundle.message("evaluation.error.boolean.value.expected.in.condition"));
  public static final EvaluateException PROCESS_EXITED = createEvaluateException(
    JavaDebuggerBundle.message("evaluation.error.process.exited"));
  public static final EvaluateException NULL_STACK_FRAME = createEvaluateException(
    JavaDebuggerBundle.message("evaluation.error.stack.frame.unavailable"));
  public static final EvaluateException NESTED_EVALUATION_ERROR = createEvaluateException(
    JavaDebuggerBundle.message("evaluation.error.nested.evaluation"));
  public static final EvaluateException INVALID_DEBUG_INFO = createEvaluateException(
    JavaDebuggerBundle.message("evaluation.error.sources.out.of.sync"));
  public static final EvaluateException CANNOT_FIND_SOURCE_CLASS = createEvaluateException(
    JavaDebuggerBundle.message("evaluation.error.cannot.find.stackframe.source"));
  public static final EvaluateException OBJECT_WAS_COLLECTED = createEvaluateException(
    JavaDebuggerBundle.message("evaluation.error.object.collected"));
  public static final EvaluateException ARRAY_WAS_COLLECTED = createEvaluateException(
    JavaDebuggerBundle.message("evaluation.error.array.collected"));
  public static final EvaluateException THREAD_WAS_RESUMED = createEvaluateException(
    JavaDebuggerBundle.message("evaluation.error.thread.resumed"));
  public static final EvaluateException DEBUG_INFO_UNAVAILABLE = createEvaluateException(
    JavaDebuggerBundle.message("evaluation.error.debug.info.unavailable"));

  private EvaluateExceptionUtil() {
  }

  public static EvaluateException createEvaluateException(Throwable th) {
    return createEvaluateException(null, th);
  }

  public static EvaluateException createEvaluateException(String msg, Throwable th) {
    String message = msg != null ? msg + ": " + reason(th) : reason(th);
    if (th instanceof EvaluateException) {
      th = th.getCause();
    }
    if (th instanceof AbsentInformationException) {
      return new AbsentInformationEvaluateException(message, th);
    }
    return new EvaluateException(message, th);
  }

  public static EvaluateException createEvaluateException(String reason) {
    return new EvaluateException(reason, null);
  }

  private static String reason(Throwable th) {
    if (th instanceof InvalidTypeException) {
      final String originalReason = th.getMessage();
      return JavaDebuggerBundle.message("evaluation.error.type.mismatch") + (originalReason != null ? " " + originalReason : "");
    }
    else if (th instanceof AbsentInformationException) {
      return JavaDebuggerBundle.message("evaluation.error.debug.info.unavailable");
    }
    else if (th instanceof ClassNotLoadedException) {
      return JavaDebuggerBundle.message("evaluation.error.class.not.loaded", ((ClassNotLoadedException)th).className());
    }
    else if (th instanceof ClassNotPreparedException) {
      return th.getMessage();
    }
    else if (th instanceof IncompatibleThreadStateException) {
      return JavaDebuggerBundle.message("evaluation.error.thread.not.at.breakpoint");
    }
    else if (th instanceof InconsistentDebugInfoException) {
      return JavaDebuggerBundle.message("evaluation.error.inconsistent.debug.info");
    }
    else if (th instanceof ObjectCollectedException) {
      return JavaDebuggerBundle.message("evaluation.error.object.collected");
    }
    else if (th instanceof InvocationException invocationException) {
      return JavaDebuggerBundle.message("evaluation.error.method.exception", invocationException.exception().referenceType().name());
    }
    else if (th instanceof EvaluateException) {
      return th.getMessage();
    }
    else {
      StringBuilder res = new StringBuilder(th.getClass().getName());
      String message = th.getMessage();
      if (!StringUtil.isEmpty(message)) {
        res.append(" : ").append(message);
      }
      return res.toString();
    }
  }
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.engine.evaluation;

import com.intellij.debugger.engine.DebugProcess;
import com.intellij.debugger.engine.StackFrameContext;
import com.intellij.debugger.engine.SuspendContext;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.ThrowableComputable;
import com.sun.jdi.ClassLoaderReference;
import com.sun.jdi.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public interface EvaluationContext extends StackFrameContext {
  @Override
  @NotNull
  DebugProcess getDebugProcess();

  EvaluationContext createEvaluationContext(Value value);

  @NotNull
  SuspendContext getSuspendContext();

  Project getProject();

  @Nullable
  ClassLoaderReference getClassLoader() throws EvaluateException;

  /**
   * @deprecated Use {@link #computeThisObject()} instead, EvaluationContext now may lazily compute this object
   */
  @Deprecated(forRemoval = true)
  @Nullable
  Value getThisObject();

  @Nullable
  Value computeThisObject() throws EvaluateException;

  void keep(Value value);

  <T extends Value> T computeAndKeep(@NotNull ThrowableComputable<T, EvaluateException> computable) throws EvaluateException;
}
/*
 * Copyright 2000-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.evaluation.expression;

import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.psi.PsiElement;
import org.jetbrains.annotations.NotNull;

/**
 * Main interface to extend evaluation for different JVM languages.
 *
 * @see com.intellij.debugger.engine.evaluation.CodeFragmentFactory
 */
public interface EvaluatorBuilder {
  @NotNull
  ExpressionEvaluator build(PsiElement codeFragment, final SourcePosition position) throws EvaluateException;
}
/*
 * Copyright 2000-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.evaluation.expression;

import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.engine.evaluation.EvaluationContext;
import com.sun.jdi.Value;

public interface ExpressionEvaluator {

  /**
   * @deprecated obsolete API, use {@link #evaluate(EvaluationContext)}
   */
  @Deprecated(forRemoval = true)
  default Value getValue() {
    return null;
  }

  //call evaluate before
  Modifier getModifier();

  Value evaluate(final EvaluationContext context) throws EvaluateException;
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Interface Modifier
 * @author Jeka
 */
package com.intellij.debugger.engine.evaluation.expression;

import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.intellij.debugger.ui.tree.NodeDescriptor;
import com.intellij.openapi.project.Project;
import com.sun.jdi.ClassNotLoadedException;
import com.sun.jdi.InvalidTypeException;
import com.sun.jdi.Type;
import com.sun.jdi.Value;

public interface Modifier {
  boolean canInspect();

  boolean canSetValue();

  /**
   * sets the value to the expression
   */
  void setValue(Value value) throws ClassNotLoadedException, InvalidTypeException, EvaluateException;

  /**
   * @return the expected type of the expression or null is class was not loaded
   */
  Type getExpectedType() throws ClassNotLoadedException, EvaluateException;

  NodeDescriptor getInspectItem(Project project);
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.engine.evaluation;

import com.intellij.openapi.fileTypes.FileType;
import com.intellij.openapi.util.NlsSafe;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public interface TextWithImports {
  @NlsSafe String getText();

  void setText(String newText);

  @NotNull
  String getImports();

  CodeFragmentKind getKind();

  boolean isEmpty();

  String toExternalForm();

  @Nullable
  FileType getFileType();
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.engine;

import com.intellij.openapi.extensions.ExtensionPointName;
import com.intellij.psi.PsiFile;
import org.jetbrains.annotations.NotNull;

/**
 * Allows to support java line breakpoints in non-java files
 */
public abstract class JavaDebugAware {
  static final ExtensionPointName<JavaDebugAware> EP_NAME = ExtensionPointName.create("com.intellij.debugger.javaDebugAware");

  public abstract boolean isBreakpointAware(@NotNull PsiFile psiFile);
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.jdi;

public interface LocalVariableProxy extends ObjectReferenceProxy {
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.jdi;

public interface ObjectReferenceProxy {
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.jdi;

import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.sun.jdi.ClassLoaderReference;
import com.sun.jdi.Location;
import com.sun.jdi.StackFrame;

public interface StackFrameProxy extends ObjectReferenceProxy {
  StackFrame getStackFrame() throws EvaluateException;

  int getFrameIndex() throws EvaluateException;

  VirtualMachineProxy getVirtualMachine();

  Location location() throws EvaluateException;

  ClassLoaderReference getClassLoader() throws EvaluateException;

  LocalVariableProxy visibleVariableByName(String name) throws EvaluateException;

  ThreadReferenceProxy threadProxy();
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.jdi;

import com.sun.jdi.ThreadGroupReference;

public interface ThreadGroupReferenceProxy extends ObjectReferenceProxy {
  ThreadGroupReference getThreadGroupReference();
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.jdi;

import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.sun.jdi.ThreadReference;

public interface ThreadReferenceProxy extends ObjectReferenceProxy {
  VirtualMachineProxy getVirtualMachine();

  ThreadReference getThreadReference();

  StackFrameProxy frame(int i) throws EvaluateException;

  int frameCount() throws EvaluateException;
}
/*
 * Copyright 2000-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.jdi;

import com.intellij.debugger.engine.DebugProcess;
import com.sun.jdi.ReferenceType;
import org.jetbrains.annotations.NotNull;

import java.util.List;

public interface VirtualMachineProxy {
  List<ReferenceType> allClasses();

  boolean canGetBytecodes();

  boolean versionHigher(String version);

  boolean canWatchFieldModification();

  boolean canWatchFieldAccess();

  boolean canInvokeMethods();

  DebugProcess getDebugProcess();

  List<ReferenceType> nestedTypes(ReferenceType refType);

  List<ReferenceType> classesByName(@NotNull String s);
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.engine;

import com.intellij.debugger.JavaDebuggerBundle;
import com.intellij.debugger.NoDataException;
import com.intellij.debugger.PositionManager;
import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.requests.ClassPrepareRequestor;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.fileTypes.FileType;
import com.intellij.openapi.fileTypes.LanguageFileType;
import com.intellij.openapi.util.Computable;
import com.intellij.psi.PsiFile;
import com.intellij.util.containers.ContainerUtil;
import com.sun.jdi.*;
import com.sun.jdi.request.ClassPrepareRequest;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;

import java.io.File;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author Eugene Zhuravlev
 */
public abstract class JSR45PositionManager<Scope> implements PositionManager {
  private static final Logger LOG = Logger.getInstance(JSR45PositionManager.class);
  protected final DebugProcess myDebugProcess;
  protected final Scope myScope;
  private final String myStratumId;
  protected final SourcesFinder<Scope> mySourcesFinder;
  protected final String GENERATED_CLASS_PATTERN;
  protected final Matcher myGeneratedClassPatternMatcher;
  private final Set<LanguageFileType> myFileTypes;

  public JSR45PositionManager(DebugProcess debugProcess, Scope scope, final String stratumId, final LanguageFileType[] acceptedFileTypes,
                              final SourcesFinder<Scope> sourcesFinder) {
    myDebugProcess = debugProcess;
    myScope = scope;
    myStratumId = stratumId;
    myFileTypes = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(acceptedFileTypes)));
    mySourcesFinder = sourcesFinder;
    String generatedClassPattern = getGeneratedClassesPackage();
    if (generatedClassPattern.length() == 0) {
      generatedClassPattern = getGeneratedClassesNamePattern();
    }
    else {
      generatedClassPattern = generatedClassPattern + "." + getGeneratedClassesNamePattern();
    }
    GENERATED_CLASS_PATTERN = generatedClassPattern;
    myGeneratedClassPatternMatcher = Pattern.compile(generatedClassPattern.replaceAll("\\*", ".*")).matcher("");
  }

  @NonNls
  protected abstract String getGeneratedClassesPackage();

  protected String getGeneratedClassesNamePattern() {
    return "*";
  }

  public final String getStratumId() {
    return myStratumId;
  }

  @Override
  public SourcePosition getSourcePosition(final Location location) throws NoDataException {
    SourcePosition sourcePosition = null;

    try {
      String sourcePath = getRelativeSourcePathByLocation(location);
      PsiFile file = mySourcesFinder.findSourceFile(sourcePath, myDebugProcess.getProject(), myScope);
      if (file != null) {
        int lineNumber = getLineNumber(location);
        sourcePosition = SourcePosition.createFromLine(file, lineNumber - 1);
      }
    }
    catch (AbsentInformationException ignored) { // ignored
    }
    catch (Throwable e) {
      LOG.info(e);
    }
    if (sourcePosition == null) {
      throw NoDataException.INSTANCE;
    }
    return sourcePosition;
  }

  protected String getRelativeSourcePathByLocation(final Location location) throws AbsentInformationException {
    return getRelativePath(location.sourcePath(myStratumId));
  }

  protected int getLineNumber(final Location location) {
    return location.lineNumber(myStratumId);
  }

  @Override
  @NotNull
  public List<ReferenceType> getAllClasses(@NotNull SourcePosition classPosition) throws NoDataException {
    checkSourcePositionFileType(classPosition);

    final List<ReferenceType> referenceTypes = myDebugProcess.getVirtualMachineProxy().allClasses();

    final List<ReferenceType> result = new ArrayList<>();

    for (final ReferenceType referenceType : referenceTypes) {
      myGeneratedClassPatternMatcher.reset(referenceType.name());
      if (myGeneratedClassPatternMatcher.matches()) {
        final List<Location> locations = locationsOfClassAt(referenceType, classPosition);
        if (locations != null && locations.size() > 0) {
          result.add(referenceType);
        }
      }
    }

    return result;
  }

  @NotNull
  @Override
  public Set<LanguageFileType> getAcceptedFileTypes() {
    return myFileTypes;
  }

  private void checkSourcePositionFileType(final SourcePosition classPosition) throws NoDataException {
    final FileType fileType = classPosition.getFile().getFileType();
    if (!myFileTypes.contains(fileType)) {
      throw NoDataException.INSTANCE;
    }
  }

  @Override
  @NotNull
  public List<Location> locationsOfLine(@NotNull final ReferenceType type, @NotNull final SourcePosition position) throws NoDataException {
    List<Location> locations = locationsOfClassAt(type, position);
    return locations != null ? locations : Collections.emptyList();
  }

  private List<Location> locationsOfClassAt(final ReferenceType type, final SourcePosition position) throws NoDataException {
    checkSourcePositionFileType(position);

    return ApplicationManager.getApplication().runReadAction(new Computable<>() {
      @Override
      public List<Location> compute() {
        try {
          final List<String> relativePaths = getRelativeSourePathsByType(type);
          for (String relativePath : relativePaths) {
            final PsiFile file = mySourcesFinder.findSourceFile(relativePath, myDebugProcess.getProject(), myScope);
            if (file != null && file.equals(position.getFile())) {
              return getLocationsOfLine(type, getSourceName(file.getName(), type), relativePath, position.getLine() + 1);
            }
          }
        }
        catch (ObjectCollectedException | ClassNotPreparedException | AbsentInformationException ignored) {
        }
        catch (InternalError ignored) {
          myDebugProcess.printToConsole(
            JavaDebuggerBundle.message("internal.error.locations.of.line", type.name()));
        }
        return null;
      }

      // Finds exact server file name (from available in type)
      // This is needed because some servers (e.g. WebSphere) put not exact file name such as 'A.jsp  '
      private String getSourceName(final String name, final ReferenceType type) throws AbsentInformationException {
        return type.sourceNames(myStratumId).stream()
          .filter(sourceNameFromType -> sourceNameFromType.contains(name))
          .findFirst().orElse(name);
      }
    });
  }

  protected List<String> getRelativeSourePathsByType(final ReferenceType type) throws AbsentInformationException {
    return ContainerUtil.map(type.sourcePaths(myStratumId), this::getRelativePath);
  }

  protected List<Location> getLocationsOfLine(final ReferenceType type, final String fileName,
                                              final String relativePath, final int lineNumber) throws AbsentInformationException {
    return type.locationsOfLine(myStratumId, fileName, lineNumber);
  }

  @Override
  public ClassPrepareRequest createPrepareRequest(@NotNull final ClassPrepareRequestor requestor, @NotNull final SourcePosition position)
    throws NoDataException {
    checkSourcePositionFileType(position);

    return myDebugProcess.getRequestsManager().createClassPrepareRequest(new ClassPrepareRequestor() {
      @Override
      public void processClassPrepare(DebugProcess debuggerProcess, ReferenceType referenceType) {
        onClassPrepare(debuggerProcess, referenceType, position, requestor);
      }
    }, GENERATED_CLASS_PATTERN);
  }

  protected void onClassPrepare(final DebugProcess debuggerProcess, final ReferenceType referenceType,
                                final SourcePosition position, final ClassPrepareRequestor requestor) {
    try {
      if (locationsOfClassAt(referenceType, position) != null) {
        requestor.processClassPrepare(debuggerProcess, referenceType);
      }
    }
    catch (NoDataException ignored) {
    }
  }

  protected String getRelativePath(String sourcePath) {

    if (sourcePath != null) {
      sourcePath = sourcePath.trim();
      String generatedClassesPackage = getGeneratedClassesPackage();
      final String prefix = generatedClassesPackage.replace('.', File.separatorChar);

      if (sourcePath.startsWith(prefix)) {
        sourcePath = sourcePath.substring(prefix.length());
        if (sourcePath.startsWith(File.separator)) {
          sourcePath = sourcePath.substring(1);
        }
      }
    }

    return sourcePath;
  }
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.managerThread;

public interface DebuggerCommand {
  void action();

  void commandCancelled();
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.managerThread;

public interface DebuggerManagerThread {
  /**
   * executes command in DebuggerManagerThread
   */
  void invokeCommand(DebuggerCommand command);
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine.managerThread;

import com.intellij.debugger.engine.SuspendContext;

public interface SuspendContextCommand extends DebuggerCommand {
  SuspendContext getSuspendContext();
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.engine;

import com.intellij.openapi.extensions.ExtensionPointName;
import com.intellij.psi.PsiElement;
import org.jetbrains.annotations.NotNull;

/**
 * Allows to support simple getter filtering during stepping for non-java languages
 */
public interface SimplePropertyGetterProvider {
  ExtensionPointName<SimplePropertyGetterProvider> EP_NAME =
    ExtensionPointName.create("com.intellij.debugger.simplePropertyGetterProvider");

  boolean isInsideSimpleGetter(@NotNull PsiElement element);
}
// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.engine;

import com.intellij.debugger.SourcePosition;
import com.intellij.openapi.extensions.ExtensionPointName;
import com.intellij.openapi.project.DumbService;
import com.intellij.openapi.util.TextRange;
import org.jetbrains.annotations.Nullable;

/**
 * During indexing, only extensions that implement {@link com.intellij.openapi.project.DumbAware} are called.
 * See also {@link DumbService}.
 *
 * @author Nikolay.Tropin
 */
public abstract class SourcePositionHighlighter {
  public static final ExtensionPointName<SourcePositionHighlighter> EP_NAME =
    ExtensionPointName.create("com.intellij.debugger.sourcePositionHighlighter");

  public abstract TextRange getHighlightRange(SourcePosition sourcePosition);

  @Nullable
  public static TextRange getHighlightRangeFor(SourcePosition sourcePosition) {
    for (SourcePositionHighlighter provider : DumbService.getDumbAwareExtensions(sourcePosition.getFile().getProject(), EP_NAME)) {
      TextRange range = provider.getHighlightRange(sourcePosition);
      if (range != null) {
        return range;
      }
    }
    return null;
  }
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine;

import com.intellij.openapi.project.Project;
import com.intellij.psi.PsiFile;
import org.jetbrains.annotations.Nullable;

/**
 * @author Eugene Zhuravlev
 */
public interface SourcesFinder<Scope> {
  /**
   * Searches for source file within the deployedModules
   *
   * @param relPath relative path of the source to be found (fetched from the class file)
   * @param scope   a search scope
   */
  @Nullable
  PsiFile findSourceFile(String relPath, Project project, Scope scope);
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine;

import com.intellij.debugger.engine.jdi.StackFrameProxy;
import org.jetbrains.annotations.Nullable;

public interface StackFrameContext {
  @Nullable
  StackFrameProxy getFrameProxy();

  @Nullable
  DebugProcess getDebugProcess();
}
/*
 * Copyright 2000-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.engine;

import com.intellij.debugger.engine.jdi.ThreadReferenceProxy;
import org.jetbrains.annotations.Nullable;

public interface SuspendContext extends StackFrameContext {
  int getSuspendPolicy();

  @Nullable
  ThreadReferenceProxy getThread();
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger.engine;

import com.intellij.openapi.extensions.ExtensionPointName;
import com.sun.jdi.TypeComponent;

/**
 * Allows to mark as synthetic more than what's marked in the bytecode, for example lambda classes
 */
public interface SyntheticTypeComponentProvider {
  ExtensionPointName<SyntheticTypeComponentProvider> EP_NAME = ExtensionPointName.create("com.intellij.debugger.syntheticProvider");

  boolean isSynthetic(TypeComponent typeComponent);

  //override this method to prevent other providers treating type component as synthetic
  default boolean isNotSynthetic(TypeComponent typeComponent) {
    return false;
  }
}
// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger;

import com.intellij.DynamicBundle;
import com.intellij.execution.configurations.RemoteConnection;
import com.intellij.openapi.util.text.StringUtil;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.PropertyKey;

import java.util.function.Supplier;

public final class JavaDebuggerBundle {
  private static final @NonNls String BUNDLE = "messages.JavaDebuggerBundle";
  private static final DynamicBundle INSTANCE = new DynamicBundle(JavaDebuggerBundle.class, BUNDLE);

  private JavaDebuggerBundle() {}

  public static @NotNull @Nls String message(@NotNull @PropertyKey(resourceBundle = BUNDLE) String key, Object @NotNull ... params) {
    return INSTANCE.getMessage(key, params);
  }

  public static @NotNull Supplier<@Nls String> messagePointer(@NotNull @PropertyKey(resourceBundle = BUNDLE) String key,
                                                              Object @NotNull ... params) {
    return INSTANCE.getLazyMessage(key, params);
  }

  public static String getAddressDisplayName(final RemoteConnection connection) {
    return connection.isUseSockets() ? StringUtil.notNullize(connection.getDebuggerHostName()) + ":" + connection.getDebuggerAddress()
                                     : connection.getDebuggerAddress();
  }

  public static String getTransportName(final RemoteConnection connection) {
    return connection.isUseSockets() ? message("transport.name.socket") : message("transport.name.shared.memory");
  }
}
/*
 * Copyright 2000-2014 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger;

import com.intellij.debugger.requests.ClassPrepareRequestor;
import com.sun.jdi.request.ClassPrepareRequest;
import org.jetbrains.annotations.NotNull;

import java.util.List;

public interface MultiRequestPositionManager extends PositionManager {

  /**
   * @see PositionManager#createPrepareRequest
   */
  @NotNull
  List<ClassPrepareRequest> createPrepareRequests(@NotNull ClassPrepareRequestor requestor, @NotNull SourcePosition position)
    throws NoDataException;
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger;

import com.intellij.psi.PsiClass;
import org.jetbrains.annotations.NotNull;

/**
 * Compilers of some java-based languages (like Scala) produce classes with names different from those declared in sources.
 * If for some language qualified names of compiled classes differ from names declared in the sources, a NameMapper must be registered
 * within the DebuggerManager class.
 * Multiple registered mappers forms a "chain of responsibility" and the first non-null result is returned.
 * If no mappers are registered or all mappers returned null, the result of
 * PsiClass.getQualifiedName() will be used as a qualified name of the compiled class
 */
public interface NameMapper {
  /**
   * @param aClass a top-level class
   * @return a qualified name of the corresponding compiled class or null if default machanism of getting qualified names must be used
   */
  String getQualifiedName(@NotNull PsiClass aClass);
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger;

import com.intellij.openapi.diagnostic.ControlFlowException;

public class NoDataException extends Exception implements ControlFlowException {
  public static final NoDataException INSTANCE = new NoDataException();

  /** @deprecated Use shared {@link NoDataException#INSTANCE} instead */
  @Deprecated(forRemoval = true)
  public NoDataException() { }

  @Override
  public synchronized Throwable fillInStackTrace() {
    return this;
  }
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

/**
 * Provides interfaces for interacting with IDEA's debugger.
 * <p>
 * The main extensibility point of the debugger allows a plugin
 * to provide custom mapping of positions in compiled classes to source code lines,
 * which is mostly necessary for JSP debugging.
 * Such mapping is provided through the {@link com.intellij.debugger.PositionManager} interface.
 * One standard implementation of this interface for application servers
 * compatible with the JSR-45 specification
 * is provided by the {@link com.intellij.debugger.engine.JSR45PositionManager} class.
 * Another implementation of this interface,
 * which can be used as an example for the debugger API,
 * is found in the Tomcat plugin.
 */
package com.intellij.debugger;
/*
 * Copyright 2000-2014 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger;

import com.intellij.debugger.requests.ClassPrepareRequestor;
import com.intellij.openapi.fileTypes.FileType;
import com.sun.jdi.Location;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.request.ClassPrepareRequest;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.List;
import java.util.Set;

/**
 * Manages the correspondence between source positions and bytecode locations during JVM debugging.
 * Instances of this class are created by the factory registered via the {@link PositionManagerFactory} extension point.
 *
 * @see com.intellij.debugger.engine.JSR45PositionManager
 */
public interface PositionManager {
  /**
   * Returns the source position corresponding to the specified bytecode location.
   *
   * @param location the bytecode location.
   * @return the corresponding source position.
   * @throws NoDataException if the location is not in the code managed by this {@code PositionManager}
   */
  @Nullable
  SourcePosition getSourcePosition(@Nullable Location location) throws NoDataException;

  /**
   * Returns the list of all Java classes corresponding to the specified position in the source code.
   *
   * @param classPosition the source position.
   * @return the list of corresponding Java classes.
   * @throws NoDataException if the location is not in the code managed by this {@code PositionManager}
   * @see com.intellij.debugger.engine.jdi.VirtualMachineProxy#classesByName
   */
  @NotNull
  List<ReferenceType> getAllClasses(@NotNull SourcePosition classPosition) throws NoDataException;

  /**
   * Returns the list of bytecode locations in a specific class corresponding to the specified position in the source code.
   *
   * @param type     a Java class (one of the list returned by {@link #getAllClasses}).
   * @param position the position in the source code.
   * @return the list of corresponding bytecode locations.
   * @throws NoDataException if the location is not in the code managed by this {@code PositionManager}
   * @see ReferenceType#locationsOfLine(int)
   */
  @NotNull
  List<Location> locationsOfLine(@NotNull ReferenceType type, @NotNull SourcePosition position) throws NoDataException;

  /**
   * Called to request the JVM to notify the debugger engine when a class corresponding to a breakpoint location is loaded.
   * The implementation should calculate the pattern of the class files corresponding to the breakpoint location and call
   * {@link com.intellij.debugger.requests.RequestManager#createClassPrepareRequest} to create the request.
   *
   * @param requestor the object to receive the notification from the JVM.
   * @param position  the location of a breakpoint.
   * @return the prepare request, or null if the code is managed by this {@code PositionManager} but no class prepare notification is needed
   * @throws NoDataException if the position is not in the code managed by this {@code PositionManager}
   */
  @Nullable
  ClassPrepareRequest createPrepareRequest(@NotNull ClassPrepareRequestor requestor, @NotNull SourcePosition position)
    throws NoDataException;

  /**
   * Return file types this position manager accepts
   *
   * @return set of accepted file types, or null if it accepts all
   */
  @Nullable
  default Set<? extends FileType> getAcceptedFileTypes() {
    return null;
  }
}
// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.debugger;

import com.intellij.debugger.engine.DebugProcess;
import com.intellij.openapi.extensions.ExtensionPointName;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * Provider for a {@link PositionManager},
 * <p>{@link #createPositionManager} is called once on debug process start
 */
public abstract class PositionManagerFactory {
  public static final ExtensionPointName<PositionManagerFactory> EP_NAME =
    ExtensionPointName.create("com.intellij.debugger.positionManagerFactory");

  @Nullable
  public abstract PositionManager createPositionManager(@NotNull DebugProcess process);
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.requests;

import com.intellij.debugger.engine.DebugProcess;
import com.sun.jdi.ReferenceType;

public interface ClassPrepareRequestor extends Requestor {
  void processClassPrepare(DebugProcess debuggerProcess, final ReferenceType referenceType);
}
/*
 * Copyright 2000-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.requests;

import com.intellij.debugger.SourcePosition;
import com.intellij.debugger.engine.evaluation.EvaluateException;
import com.sun.jdi.request.ClassPrepareRequest;
import com.sun.jdi.request.EventRequest;
import org.jetbrains.annotations.Nullable;

public interface RequestManager {
  void callbackOnPrepareClasses(ClassPrepareRequestor requestor, String classOrPatternToBeLoaded);

  void callbackOnPrepareClasses(ClassPrepareRequestor requestor, SourcePosition classPosition) throws EvaluateException;

  @Nullable
  ClassPrepareRequest createClassPrepareRequest(ClassPrepareRequestor requestor, String pattern);

  void enableRequest(EventRequest request);

  void setInvalid(Requestor requestor, String message);
}
/*
 * Copyright 2000-2009 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.requests;

public interface Requestor {
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.fileEditor.OpenFileDescriptor;
import com.intellij.openapi.progress.ProcessCanceledException;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Comparing;
import com.intellij.openapi.util.Computable;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.pom.Navigatable;
import com.intellij.psi.*;
import com.intellij.reference.SoftReference;
import com.intellij.util.containers.ContainerUtil;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.lang.ref.WeakReference;
import java.util.List;

public abstract class SourcePosition implements Navigatable {
  private static final Logger LOG = Logger.getInstance(SourcePosition.class);

  @NotNull
  public abstract PsiFile getFile();

  public abstract @Nullable PsiElement getElementAt();

  /**
   * @return a zero-based line number
   */
  public abstract int getLine();

  public abstract int getOffset();

  public abstract Editor openEditor(boolean requestFocus);

  private abstract static class SourcePositionCache extends SourcePosition {
    @NotNull private final PsiFile myFile;
    @Nullable private final SmartPsiElementPointer<PsiFile> myFilePointer;
    private long myModificationStamp;

    private WeakReference<PsiElement> myPsiElementRef;
    private Integer myLine;
    private Integer myOffset;

    SourcePositionCache(@NotNull PsiFile file) {
      myFile = file;
      myFilePointer = ReadAction.compute(
        () -> file.isValid() ? SmartPointerManager.getInstance(file.getProject()).createSmartPsiElementPointer(file) : null);
      myModificationStamp = file.getModificationStamp();
    }

    @Override
    @NotNull
    public PsiFile getFile() {
      PsiFile file = myFilePointer != null ? ReadAction.compute(myFilePointer::getElement) : null;
      return file != null ? file : myFile; // in case of full invalidation, rollback to the original psiFile
    }

    @Override
    public boolean canNavigate() {
      return getFile().isValid();
    }

    @Override
    public boolean canNavigateToSource() {
      return canNavigate();
    }

    @Override
    public void navigate(final boolean requestFocus) {
      ApplicationManager.getApplication().invokeLater(() -> {
        if (!canNavigate()) {
          return;
        }
        openEditor(requestFocus);
      });
    }

    @Override
    public Editor openEditor(final boolean requestFocus) {
      final PsiFile psiFile = getFile();
      final Project project = psiFile.getProject();
      if (project.isDisposed()) {
        return null;
      }
      final VirtualFile virtualFile = psiFile.getVirtualFile();
      if (virtualFile == null || !virtualFile.isValid()) {
        return null;
      }
      final int offset = getOffset();
      if (offset < 0) {
        return null;
      }
      return FileEditorManager.getInstance(project).openTextEditor(new OpenFileDescriptor(project, virtualFile, offset), requestFocus);
    }

    private void updateData() {
      if (dataUpdateNeeded()) {
        myModificationStamp = getFile().getModificationStamp();
        myLine = null;
        myOffset = null;
        myPsiElementRef = null;
      }
    }

    private boolean dataUpdateNeeded() {
      if (myModificationStamp != getFile().getModificationStamp()) {
        return true;
      }
      PsiElement psiElement = SoftReference.dereference(myPsiElementRef);
      return psiElement != null && !ReadAction.compute(psiElement::isValid);
    }

    @Override
    public int getLine() {
      updateData();
      if (myLine == null) {
        myLine = calcLine();
      }
      return myLine.intValue();
    }

    @Override
    public int getOffset() {
      updateData();
      if (myOffset == null) {
        myOffset = calcOffset();
      }
      return myOffset.intValue();
    }

    @Override
    public @Nullable PsiElement getElementAt() {
      updateData();
      PsiElement element = SoftReference.dereference(myPsiElementRef);
      if (element == null) {
        element = ReadAction.compute(this::calcPsiElement);
        myPsiElementRef = new WeakReference<>(element);
        return element;
      }
      return element;
    }

    protected int calcLine() {
      final PsiFile file = getFile();
      Document document = null;
      try {
        document = getDocument(file);
        if (document == null) { // may be decompiled psi - try to get document for the original file
          document = getDocument(file.getOriginalFile());
        }
      }
      catch (ProcessCanceledException ignored) {
      }
      catch (Throwable e) {
        LOG.error(e);
      }
      if (document != null) {
        try {
          return document.getLineNumber(calcOffset());
        }
        catch (IndexOutOfBoundsException e) {
          // may happen if document has been changed since the this SourcePosition was created
        }
      }
      return -1;
    }

    @Nullable
    private static Document getDocument(@NotNull PsiFile file) {
      Project project = file.getProject();
      if (project.isDisposed()) {
        return null;
      }
      return PsiDocumentManager.getInstance(project).getDocument(file);
    }

    protected int calcOffset() {
      final PsiFile file = getFile();
      final Document document = getDocument(file);
      if (document != null) {
        try {
          return document.getLineStartOffset(calcLine());
        }
        catch (IndexOutOfBoundsException e) {
          // may happen if document has been changed since the this SourcePosition was created
        }
      }
      return -1;
    }

    @Nullable
    protected PsiElement calcPsiElement() {
      // currently PsiDocumentManager does not store documents for mirror file, so we store original file
      PsiFile psiFile = getFile();
      if (!psiFile.isValid()) {
        return null;
      }

      int lineNumber = getLine();
      if (lineNumber < 0) {
        return psiFile;
      }

      Document document = getDocument(psiFile);
      if (document == null) {
        return null;
      }
      if (lineNumber >= document.getLineCount()) {
        return psiFile;
      }
      int startOffset = document.getLineStartOffset(lineNumber);
      if (startOffset == -1) {
        return null;
      }

      PsiElement rootElement = psiFile;
      List<PsiFile> allFiles = psiFile.getViewProvider().getAllFiles();
      if (allFiles.size() > 1) { // jsp & gsp
        PsiClassOwner owner = ContainerUtil.findInstance(allFiles, PsiClassOwner.class);
        if (owner != null) {
          PsiClass[] classes = owner.getClasses();
          if (classes.length == 1 && classes[0] instanceof SyntheticElement) {
            rootElement = classes[0];
          }
        }
      }

      PsiElement element = null;
      int offset = getOffset();
      while (true) {
        final CharSequence charsSequence = document.getCharsSequence();
        for (; offset < charsSequence.length(); offset++) {
          char c = charsSequence.charAt(offset);
          if (c != ' ' && c != '\t') {
            break;
          }
        }
        if (offset >= charsSequence.length()) break;

        element = rootElement.findElementAt(offset);

        if (element instanceof PsiComment) {
          offset = element.getTextRange().getEndOffset() + 1;
        }
        else {
          break;
        }
      }
      if (element != null && element.getParent() instanceof PsiForStatement) {
        return ((PsiForStatement)element.getParent()).getInitialization();
      }
      return element;
    }
  }

  public static SourcePosition createFromLineComputable(@NotNull final PsiFile file, final Computable<Integer> line) {
    return new SourcePositionCache(file) {
      @Override
      protected int calcLine() {
        return line.compute();
      }
    };
  }

  public static SourcePosition createFromLine(@NotNull final PsiFile file, final int line) {
    return new SourcePositionCache(file) {
      @Override
      protected int calcLine() {
        return line;
      }

      @Override
      public String toString() {
        return getFile().getName() + ":" + line;
      }
    };
  }

  public static SourcePosition createFromOffset(@NotNull final PsiFile file, final int offset) {
    return new SourcePositionCache(file) {
      @Override
      protected int calcOffset() {
        return offset;
      }

      @Override
      public String toString() {
        return getFile().getName() + " offset " + offset;
      }
    };
  }

  @Nullable
  public static SourcePosition createFromElement(@NotNull PsiElement element) {
    ApplicationManager.getApplication().assertReadAccessAllowed();
    PsiElement navigationElement = element.getNavigationElement();
    final SmartPsiElementPointer<PsiElement> pointer =
      SmartPointerManager.getInstance(navigationElement.getProject()).createSmartPsiElementPointer(navigationElement);
    final PsiFile psiFile;
    if (JspPsiUtil.isInJspFile(navigationElement)) {
      psiFile = JspPsiUtil.getJspFile(navigationElement);
    }
    else {
      psiFile = navigationElement.getContainingFile();
    }
    if (psiFile == null) return null;
    return new SourcePositionCache(psiFile) {
      @Override
      protected PsiElement calcPsiElement() {
        return pointer.getElement();
      }

      @Override
      protected int calcOffset() {
        return ReadAction.compute(() -> {
          PsiElement elem = pointer.getElement();
          return elem != null ? elem.getTextOffset() : -1;
        });
      }
    };
  }

  public boolean equals(Object o) {
    if (o instanceof SourcePosition sourcePosition) {
      return Comparing.equal(sourcePosition.getFile(), getFile()) && sourcePosition.getOffset() == getOffset();
    }

    return false;
  }
}
/*
 * Copyright 2000-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.intellij.debugger.ui.tree;

import com.intellij.openapi.util.UserDataHolder;

public interface NodeDescriptor extends UserDataHolder {

  String getName();

  String getLabel();

  void displayAs(NodeDescriptor descriptor);

  void setAncestor(NodeDescriptor oldDescriptor);
}
// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.debugger.ui.tree;

import com.intellij.openapi.extensions.ExtensionPointName;
import com.intellij.util.containers.ContainerUtil;
import org.jetbrains.annotations.NotNull;

/**
 * Allows to adjust variables names, for example trim outer class variable name prefix in java classes
 */
public abstract class NodeDescriptorNameAdjuster {
  public static final ExtensionPointName<NodeDescriptorNameAdjuster> EP_NAME =
    ExtensionPointName.create("com.intellij.debugger.nodeNameAdjuster");

  public abstract boolean isApplicable(@NotNull NodeDescriptor descriptor);

  public abstract String fixName(String name, @NotNull NodeDescriptor descriptor);

  public static NodeDescriptorNameAdjuster findFor(@NotNull NodeDescriptor descriptor) {
    return ContainerUtil.find(EP_NAME.getExtensionList(), adjuster -> adjuster.isApplicable(descriptor));
  }
}
<?xml version="1.0" encoding="UTF-8"?>
<module relativePaths="true" type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module" module-name="intellij.java" />
    <orderEntry type="module" module-name="intellij.java.execution" exported="" />
    <orderEntry type="module" module-name="intellij.java.rt" />
    <orderEntry type="module" module-name="intellij.java.debugger.impl" />
    <orderEntry type="module" module-name="intellij.platform.testRunner" exported="" />
    <orderEntry type="module" module-name="intellij.java.compiler" />
    <orderEntry type="module" module-name="intellij.java.impl" />
    <orderEntry type="module" module-name="intellij.java.indexing" />
    <orderEntry type="module" module-name="intellij.platform.smRunner" />
    <orderEntry type="module" module-name="intellij.java.jshell.protocol" />
    <orderEntry type="library" name="intellij-test-discovery" level="project" />
    <orderEntry type="module-library" scope="RUNTIME">
      <library name="jshell-frontend">
        <CLASSES>
          <root url="jar://$MODULE_DIR$/jshell-frontend.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module" module-name="intellij.platform.externalSystem" />
    <orderEntry type="module" module-name="intellij.platform.externalSystem.impl" />
    <orderEntry type="library" name="gson" level="project" />
    <orderEntry type="library" name="jackson" level="project" />
    <orderEntry type="library" name="miglayout-swing" level="project" />
    <orderEntry type="module" module-name="intellij.platform.vcs.impl" />
    <orderEntry type="library" name="NanoXML" level="project" />
    <orderEntry type="library" name="jackson-databind" level="project" />
    <orderEntry type="module" module-name="intellij.platform.debugger.impl" />
    <orderEntry type="library" name="fastutil-min" level="project" />
    <orderEntry type="module" module-name="intellij.platform.statistics" exported="" />
    <orderEntry type="module" module-name="intellij.platform.util.classLoader" />
    <orderEntry type="module" module-name="intellij.platform.core.ui" />
    <orderEntry type="module" module-name="intellij.platform.ide.util.io.impl" />
    <orderEntry type="module" module-name="intellij.platform.util.jdom" />
  </component>
  <component name="copyright">
    <Base>
      <setting name="state" value="1" />
    </Base>
  </component>
</module>
. 05, 2023 6:28:03 AM trigram.TrigramSearchApi constructIndexForFile
SEVERE: exception during constructing index for file C:\Users\user\programming\personal\intellij-community\java\execution\impl\jshell-frontend.jar: Input length = 2
java.nio.charset.MalformedInputException: Input length = 2
	at java.base/java.nio.charset.CoderResult.throwException(CoderResult.java:274)
	at java.base/sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)
	at java.base/sun.nio.cs.StreamDecoder.read(StreamDecoder.java:188)
	at java.base/java.io.InputStreamReader.read(InputStreamReader.java:177)
	at java.base/java.io.BufferedReader.fill(BufferedReader.java:162)
	at java.base/java.io.BufferedReader.readLine(BufferedReader.java:329)
	at java.base/java.io.BufferedReader.readLine(BufferedReader.java:396)
	at kotlin.io.LinesSequence$iterator$1.hasNext(ReadWrite.kt:79)
	at kotlin.sequences.TransformingSequence$iterator$1.hasNext(Sequences.kt:214)
	at trigram.TrigramSearchApi.constructIndexForFile(TrigramSearchApi.kt:314)
	at trigram.TrigramSearchApi.access$constructIndexForFile(TrigramSearchApi.kt:28)
	at trigram.TrigramSearchApi$asyncIndexingFiles$2.invokeSuspend(TrigramSearchApi.kt:133)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684)
. 05, 2023 6:28:03 AM trigram.TrigramSearchApi$asyncIndexing$2 invokeSuspend
SEVERE: exception during making index: Input length = 2
java.nio.charset.MalformedInputException: Input length = 2
	at java.base/java.nio.charset.CoderResult.throwException(CoderResult.java:274)
	at java.base/sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)
	at java.base/sun.nio.cs.StreamDecoder.read(StreamDecoder.java:188)
	at java.base/java.io.InputStreamReader.read(InputStreamReader.java:177)
	at java.base/java.io.BufferedReader.fill(BufferedReader.java:162)
	at java.base/java.io.BufferedReader.readLine(BufferedReader.java:329)
	at java.base/java.io.BufferedReader.readLine(BufferedReader.java:396)
	at kotlin.io.LinesSequence$iterator$1.hasNext(ReadWrite.kt:79)
	at kotlin.sequences.TransformingSequence$iterator$1.hasNext(Sequences.kt:214)
	at trigram.TrigramSearchApi.constructIndexForFile(TrigramSearchApi.kt:314)
	at trigram.TrigramSearchApi.access$constructIndexForFile(TrigramSearchApi.kt:28)
	at trigram.TrigramSearchApi$asyncIndexingFiles$2.invokeSuspend(TrigramSearchApi.kt:133)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684)
indexing folder 2,39 %, passed time:0 minutes 24 seconds 24167 milliseconds, indexed more 134 files, last file: C:\Users\user\programming\personal\intellij-community\java\execution\impl\intellij.java.execution.impl.iml
indexing folder 2,39 %, passed time:0 minutes 29 seconds 29208 milliseconds, indexed more 0 files
indexing folder 2,39 %, passed time:0 minutes 34 seconds 34257 milliseconds, indexed more 0 files
indexing folder 2,39 %, passed time:0 minutes 39 seconds 39307 milliseconds, indexed more 0 files
indexing folder 2,39 %, passed time:0 minutes 44 seconds 44355 milliseconds, indexed more 0 files
indexing folder 2,39 %, passed time:0 minutes 49 seconds 49404 milliseconds, indexed more 0 files
indexing folder 2,39 %, passed time:0 minutes 54 seconds 54458 milliseconds, indexed more 0 files
indexing folder 2,39 %, passed time:0 minutes 59 seconds 59505 milliseconds, indexed more 0 files
indexing folder 2,39 %, passed time:1 minutes 14 seconds 74533 milliseconds, indexed more 0 files
indexing folder 2,39 %, passed time:1 minutes 29 seconds 89546 milliseconds, indexed more 0 files
indexing folder 2,39 %, passed time:1 minutes 44 seconds 104574 milliseconds, indexed more 0 files
indexing folder 2,39 %, passed time:1 minutes 59 seconds 119575 milliseconds, indexed more 0 files
